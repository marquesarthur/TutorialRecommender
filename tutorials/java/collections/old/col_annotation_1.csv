,"Convenience Implementations","List View of an Array","<h2>List View of an Array</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> method returns a <code>List</code> view of its array argument. Changes to the <code>List</code> write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the <code>add</code> or the <code>remove</code> method is called on the <code>List</code>, an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code> will result.</p> 
<p>The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>. However, this implementation also has another use. If you need a fixed-size <code>List</code>, it's more efficient than any general-purpose <code>List</code> implementation. This is the idiom.</p> 
<p>Note that a reference to the backing array is not retained.</p>","Arrays","java.util.Arrays.asList","class",FALSE
,"Convenience Implementations","List View of an Array","<h2>List View of an Array</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> method returns a <code>List</code> view of its array argument. Changes to the <code>List</code> write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the <code>add</code> or the <code>remove</code> method is called on the <code>List</code>, an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code> will result.</p> 
<p>The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>. However, this implementation also has another use. If you need a fixed-size <code>List</code>, it's more efficient than any general-purpose <code>List</code> implementation. This is the idiom.</p> 
<p>Note that a reference to the backing array is not retained.</p>","UnsupportedOperationException","java.lang.UnsupportedOperationException","class",FALSE
,"Convenience Implementations","List View of an Array","<h2>List View of an Array</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> method returns a <code>List</code> view of its array argument. Changes to the <code>List</code> write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the <code>add</code> or the <code>remove</code> method is called on the <code>List</code>, an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code> will result.</p> 
<p>The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>. However, this implementation also has another use. If you need a fixed-size <code>List</code>, it's more efficient than any general-purpose <code>List</code> implementation. This is the idiom.</p> 
<p>Note that a reference to the backing array is not retained.</p>","Collection","java.util.Collection","class",FALSE
,"Convenience Implementations","Immutable Multiple-Copy List","<h2>Immutable Multiple-Copy List</h2> 
<p>Occasionally you'll need an immutable <code>List</code> consisting of multiple copies of the same element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#nCopies(int,%20T)""><code> 
   <clt fqn=""java.util.Collections.nCopies"" api=""Collections"" kind=""method"">
   Collections.nCopies
   </clt></code></a> method returns such a list. This implementation has two main uses. The first is to initialize a newly created <code>List</code>; for example, suppose you want an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> initially consisting of 1,000 <code>null</code> elements. The following incantation does the trick.</p> 
<p>Of course, the initial value of each element need not be <code>null</code>. The second main use is to grow an existing <code>List</code>. For example, suppose you want to add 69 copies of the string <code>&quot;fruit bat&quot;</code> to the end of a <code>List&lt;String&gt;</code>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it.</p> 
<p>By using the form of <code>addAll</code> that takes both an index and a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, you can add the new elements to the middle of a <code>List</code> instead of to the end of it.</p>","Collections","java.util.Collections.nCopies","class",FALSE
,"Convenience Implementations","Immutable Multiple-Copy List","<h2>Immutable Multiple-Copy List</h2> 
<p>Occasionally you'll need an immutable <code>List</code> consisting of multiple copies of the same element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#nCopies(int,%20T)""><code> 
   <clt fqn=""java.util.Collections.nCopies"" api=""Collections"" kind=""method"">
   Collections.nCopies
   </clt></code></a> method returns such a list. This implementation has two main uses. The first is to initialize a newly created <code>List</code>; for example, suppose you want an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> initially consisting of 1,000 <code>null</code> elements. The following incantation does the trick.</p> 
<p>Of course, the initial value of each element need not be <code>null</code>. The second main use is to grow an existing <code>List</code>. For example, suppose you want to add 69 copies of the string <code>&quot;fruit bat&quot;</code> to the end of a <code>List&lt;String&gt;</code>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it.</p> 
<p>By using the form of <code>addAll</code> that takes both an index and a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, you can add the new elements to the middle of a <code>List</code> instead of to the end of it.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"Convenience Implementations","Immutable Multiple-Copy List","<h2>Immutable Multiple-Copy List</h2> 
<p>Occasionally you'll need an immutable <code>List</code> consisting of multiple copies of the same element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#nCopies(int,%20T)""><code> 
   <clt fqn=""java.util.Collections.nCopies"" api=""Collections"" kind=""method"">
   Collections.nCopies
   </clt></code></a> method returns such a list. This implementation has two main uses. The first is to initialize a newly created <code>List</code>; for example, suppose you want an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> initially consisting of 1,000 <code>null</code> elements. The following incantation does the trick.</p> 
<p>Of course, the initial value of each element need not be <code>null</code>. The second main use is to grow an existing <code>List</code>. For example, suppose you want to add 69 copies of the string <code>&quot;fruit bat&quot;</code> to the end of a <code>List&lt;String&gt;</code>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it.</p> 
<p>By using the form of <code>addAll</code> that takes both an index and a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, you can add the new elements to the middle of a <code>List</code> instead of to the end of it.</p>","Collection","java.util.Collection","class",FALSE
,"Convenience Implementations","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Set","java.util.Set","class",FALSE
,"Convenience Implementations","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Collections","java.util.Collections.singleton","class",FALSE
,"Convenience Implementations","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Collection","java.util.Collection","class",FALSE
,"Convenience Implementations","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Map","java.util.Map","class",FALSE
,"Convenience Implementations","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Set","java.util.Set","class",FALSE
,"Convenience Implementations","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","List","java.util.List","class",FALSE
,"Convenience Implementations","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Map","java.util.Map","class",FALSE
,"Convenience Implementations","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Collections","java.util.Collections","class",FALSE
,"Convenience Implementations","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Collection","java.util.Collection","class",FALSE
,"Deque Implementations","Deque Implementations","<div id=""PageTitle""> 
 <h1>Deque Implementations</h1> 
</div> 
<p>The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface, pronounced as <em>&quot;deck&quot;</em>, represents a double-ended queue. The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface can be implemented as various types of <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface implementations are grouped into general-purpose and concurrent implementations.</p>","Deque","java.util.Deque","class",FALSE
,"Deque Implementations","Deque Implementations","<div id=""PageTitle""> 
 <h1>Deque Implementations</h1> 
</div> 
<p>The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface, pronounced as <em>&quot;deck&quot;</em>, represents a double-ended queue. The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface can be implemented as various types of <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface implementations are grouped into general-purpose and concurrent implementations.</p>","Collections","java.util.Collections","class",FALSE
,"Deque Implementations","General-Purpose Deque Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Implementations</h2> 
<p> The general-purpose implementations include <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> classes. The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface supports insertion, removal and retrieval of elements at both ends. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html""><code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code></a> class is the resizable array implementation of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface, whereas the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> class is the list implementation.</p> 
<p> The basic insertion, removal and retieval operations in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface <code>addFirst</code>, <code>addLast</code>, <code>removeFirst</code>, <code>removeLast</code>, <code>getFirst</code> and <code>getLast</code>. The method <code>addFirst</code> adds an element at the head whereas <code>addLast</code> adds an element at the tail of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance.</p> 
<p>The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation is more flexible than the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements all optional list operations. <code>null</code> elements are allowed in the <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation but not in the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation.</p> 
<p>In terms of efficiency, <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> is more efficient than the <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> for add and remove operation at both ends. The best operation in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation is removing the current element during the iteration. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementations are not ideal structures to iterate.</p> 
<p>The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation consumes more memory than the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation. For the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> instance traversal use any of the following: </p>","Deque","java.util.Deque","class",FALSE
,"Deque Implementations","General-Purpose Deque Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Implementations</h2> 
<p> The general-purpose implementations include <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> classes. The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface supports insertion, removal and retrieval of elements at both ends. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html""><code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code></a> class is the resizable array implementation of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface, whereas the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> class is the list implementation.</p> 
<p> The basic insertion, removal and retieval operations in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface <code>addFirst</code>, <code>addLast</code>, <code>removeFirst</code>, <code>removeLast</code>, <code>getFirst</code> and <code>getLast</code>. The method <code>addFirst</code> adds an element at the head whereas <code>addLast</code> adds an element at the tail of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance.</p> 
<p>The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation is more flexible than the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements all optional list operations. <code>null</code> elements are allowed in the <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation but not in the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation.</p> 
<p>In terms of efficiency, <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> is more efficient than the <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> for add and remove operation at both ends. The best operation in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation is removing the current element during the iteration. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementations are not ideal structures to iterate.</p> 
<p>The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation consumes more memory than the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation. For the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> instance traversal use any of the following: </p>","LinkedList","java.util.LinkedList","class",FALSE
,"Deque Implementations","General-Purpose Deque Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Implementations</h2> 
<p> The general-purpose implementations include <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> classes. The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface supports insertion, removal and retrieval of elements at both ends. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html""><code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code></a> class is the resizable array implementation of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface, whereas the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> class is the list implementation.</p> 
<p> The basic insertion, removal and retieval operations in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface <code>addFirst</code>, <code>addLast</code>, <code>removeFirst</code>, <code>removeLast</code>, <code>getFirst</code> and <code>getLast</code>. The method <code>addFirst</code> adds an element at the head whereas <code>addLast</code> adds an element at the tail of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance.</p> 
<p>The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation is more flexible than the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements all optional list operations. <code>null</code> elements are allowed in the <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation but not in the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation.</p> 
<p>In terms of efficiency, <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> is more efficient than the <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> for add and remove operation at both ends. The best operation in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation is removing the current element during the iteration. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementations are not ideal structures to iterate.</p> 
<p>The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation consumes more memory than the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> implementation. For the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> instance traversal use any of the following: </p>","ArrayDeque","java.util.ArrayDeque","class",FALSE
,"Deque Implementations","Concurrent Deque Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingDeque.html""><code> 
   <clt fqn=""java.util.concurrent.LinkedBlockingDeque"" api=""LinkedBlockingDeque"" kind=""class"">
     LinkedBlockingDeque 
   </clt></code></a> class is the concurrent implementation of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. If the deque is empty then methods such as <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeFirst"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeFirst
  </clt></code> and <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeLast"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeLast
  </clt></code> wait until the element becomes available, and then retrieves and removes the same element. </p>","Deque","java.util.Deque","class",FALSE
,"Deque Implementations","Concurrent Deque Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingDeque.html""><code> 
   <clt fqn=""java.util.concurrent.LinkedBlockingDeque"" api=""LinkedBlockingDeque"" kind=""class"">
     LinkedBlockingDeque 
   </clt></code></a> class is the concurrent implementation of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. If the deque is empty then methods such as <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeFirst"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeFirst
  </clt></code> and <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeLast"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeLast
  </clt></code> wait until the element becomes available, and then retrieves and removes the same element. </p>","LinkedBlockingDeque","java.util.concurrent.LinkedBlockingDeque","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","Lesson: Custom Collection Implementations","<div id=""PageTitle""> 
 <h1>Lesson: Custom 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt>Implementations</h1> 
</div> 
<p>Many programmers will never need to implement their own <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>s classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss <em>how</em> to write an implementation, let's discuss why you might want to write one.</p>","Collection","java.util.Collection","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","Reasons to Write an Implementation","<h2>Reasons to Write an Implementation</h2> 
<p>The following list illustrates the sort of custom <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>s you might want to implement. It is not intended to be exhaustive:</p> 
<ul> 
 <li><b>Persistent</b>: All of the built-in <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.</li> 
 <li><b>Application-specific</b>: This is a very broad category. One example is an unmodifiable <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the <code>get</code> operation.</li> 
 <li><b>High-performance, special-purpose</b>: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a <code>List</code> containing long runs of identical element values. Such lists, which occur frequently in text processing, can be <em>run-length encoded</em> ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code>.</li> 
 <li><b>High-performance, general-purpose</b>: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!</li> 
 <li><b>Enhanced functionality</b>: Suppose you need an efficient bag implementation (also known as a <em>multiset</em>): a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>.</li> 
 <li><b>Convenience</b>: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need <code>List</code> instances representing a contiguous range of <code> 
   <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
     Integer 
   </clt></code>s.</li> 
 <li><b>Adapter</b>: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An <em>adapter implementation</em> is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.</li> 
</ul>","Collection","java.util.Collection","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","Reasons to Write an Implementation","<h2>Reasons to Write an Implementation</h2> 
<p>The following list illustrates the sort of custom <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>s you might want to implement. It is not intended to be exhaustive:</p> 
<ul> 
 <li><b>Persistent</b>: All of the built-in <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.</li> 
 <li><b>Application-specific</b>: This is a very broad category. One example is an unmodifiable <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the <code>get</code> operation.</li> 
 <li><b>High-performance, special-purpose</b>: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a <code>List</code> containing long runs of identical element values. Such lists, which occur frequently in text processing, can be <em>run-length encoded</em> ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code>.</li> 
 <li><b>High-performance, general-purpose</b>: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!</li> 
 <li><b>Enhanced functionality</b>: Suppose you need an efficient bag implementation (also known as a <em>multiset</em>): a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>.</li> 
 <li><b>Convenience</b>: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need <code>List</code> instances representing a contiguous range of <code> 
   <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
     Integer 
   </clt></code>s.</li> 
 <li><b>Adapter</b>: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An <em>adapter implementation</em> is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.</li> 
</ul>","Map","java.util.Map","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","Reasons to Write an Implementation","<h2>Reasons to Write an Implementation</h2> 
<p>The following list illustrates the sort of custom <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>s you might want to implement. It is not intended to be exhaustive:</p> 
<ul> 
 <li><b>Persistent</b>: All of the built-in <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.</li> 
 <li><b>Application-specific</b>: This is a very broad category. One example is an unmodifiable <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the <code>get</code> operation.</li> 
 <li><b>High-performance, special-purpose</b>: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a <code>List</code> containing long runs of identical element values. Such lists, which occur frequently in text processing, can be <em>run-length encoded</em> ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code>.</li> 
 <li><b>High-performance, general-purpose</b>: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!</li> 
 <li><b>Enhanced functionality</b>: Suppose you need an efficient bag implementation (also known as a <em>multiset</em>): a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>.</li> 
 <li><b>Convenience</b>: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need <code>List</code> instances representing a contiguous range of <code> 
   <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
     Integer 
   </clt></code>s.</li> 
 <li><b>Adapter</b>: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An <em>adapter implementation</em> is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.</li> 
</ul>","ArrayList","java.util.ArrayList","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","Reasons to Write an Implementation","<h2>Reasons to Write an Implementation</h2> 
<p>The following list illustrates the sort of custom <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>s you might want to implement. It is not intended to be exhaustive:</p> 
<ul> 
 <li><b>Persistent</b>: All of the built-in <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.</li> 
 <li><b>Application-specific</b>: This is a very broad category. One example is an unmodifiable <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the <code>get</code> operation.</li> 
 <li><b>High-performance, special-purpose</b>: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a <code>List</code> containing long runs of identical element values. Such lists, which occur frequently in text processing, can be <em>run-length encoded</em> ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code>.</li> 
 <li><b>High-performance, general-purpose</b>: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!</li> 
 <li><b>Enhanced functionality</b>: Suppose you need an efficient bag implementation (also known as a <em>multiset</em>): a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>.</li> 
 <li><b>Convenience</b>: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need <code>List</code> instances representing a contiguous range of <code> 
   <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
     Integer 
   </clt></code>s.</li> 
 <li><b>Adapter</b>: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An <em>adapter implementation</em> is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.</li> 
</ul>","HashMap","java.util.HashMap","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","Reasons to Write an Implementation","<h2>Reasons to Write an Implementation</h2> 
<p>The following list illustrates the sort of custom <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>s you might want to implement. It is not intended to be exhaustive:</p> 
<ul> 
 <li><b>Persistent</b>: All of the built-in <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.</li> 
 <li><b>Application-specific</b>: This is a very broad category. One example is an unmodifiable <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the <code>get</code> operation.</li> 
 <li><b>High-performance, special-purpose</b>: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a <code>List</code> containing long runs of identical element values. Such lists, which occur frequently in text processing, can be <em>run-length encoded</em> ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code>.</li> 
 <li><b>High-performance, general-purpose</b>: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!</li> 
 <li><b>Enhanced functionality</b>: Suppose you need an efficient bag implementation (also known as a <em>multiset</em>): a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>.</li> 
 <li><b>Convenience</b>: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need <code>List</code> instances representing a contiguous range of <code> 
   <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
     Integer 
   </clt></code>s.</li> 
 <li><b>Adapter</b>: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An <em>adapter implementation</em> is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.</li> 
</ul>","Integer","java.lang.Integer","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation","<h2>How to Write a Custom Implementation</h2> 
<p>Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a>.</p> 
<p>Believe it or not, this is very close to the implementation that is contained in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. It's that simple! You provide a constructor and the <code>get</code>, <code>set</code>, and <code>size</code> methods, and <code> 
  <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
    AbstractList 
  </clt></code> does all the rest. You get the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, bulk operations, search operations, hash code computation, comparison, and string representation for free.</p> 
<p>Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the <code>toArray</code> method iterates over the <code>List</code>, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.</p>","Arrays","java.util.Arrays.asList","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation","<h2>How to Write a Custom Implementation</h2> 
<p>Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a>.</p> 
<p>Believe it or not, this is very close to the implementation that is contained in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. It's that simple! You provide a constructor and the <code>get</code>, <code>set</code>, and <code>size</code> methods, and <code> 
  <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
    AbstractList 
  </clt></code> does all the rest. You get the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, bulk operations, search operations, hash code computation, comparison, and string representation for free.</p> 
<p>Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the <code>toArray</code> method iterates over the <code>List</code>, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.</p>","AbstractList","java.util.AbstractList","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation","<h2>How to Write a Custom Implementation</h2> 
<p>Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a>.</p> 
<p>Believe it or not, this is very close to the implementation that is contained in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. It's that simple! You provide a constructor and the <code>get</code>, <code>set</code>, and <code>size</code> methods, and <code> 
  <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
    AbstractList 
  </clt></code> does all the rest. You get the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, bulk operations, search operations, hash code computation, comparison, and string representation for free.</p> 
<p>Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the <code>toArray</code> method iterates over the <code>List</code>, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.</p>","ListIterator","java.util.ListIterator","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Arrays","java.util.Arrays","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractCollection","java.util.AbstractCollection","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Collection","java.util.Collection","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Set","java.util.Set","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractSet","java.util.AbstractSet","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractList","java.util.AbstractList","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractSequentialList","java.util.AbstractSequentialList","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractQueue","java.util.AbstractQueue","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractMap","java.util.AbstractMap","class",FALSE
,"Lesson: Custom 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Implementations","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Map","java.util.Map","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","Set","java.util.Set","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","HashSet","java.util.HashSet","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","LinkedHashSet","java.util.LinkedHashSet","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","LinkedList","java.util.LinkedList","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","Deque","java.util.Deque","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","ArrayDeque","java.util.ArrayDeque","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","Map","java.util.Map","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","HashMap","java.util.HashMap","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","TreeMap","java.util.TreeMap","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","LinkedHashMap","java.util.LinkedHashMap","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 2","<h3>Lesson: Implementations - part 2</h3>
<p>The general-purpose implementations are summarized in the <span id=""table:General-purpose-implementations"">following table</span>.</p> 
<table summary=""General-purpose-implementations"" border=""2""> 
 <caption id=""General-purpose-implementations""> 
  <strong>General-purpose Implementations</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"" width=""15%"">Interfaces</th> 
   <th id=""h2"">Hash table Implementations</th> 
   <th id=""h3"">Resizable array Implementations</th> 
   <th id=""h4"">Tree Implementations</th> 
   <th id=""h5"">Linked list Implementations</th> 
   <th id=""h6"">Hash table + Linked list Implementations</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
       Set 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
       HashSet 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
       TreeSet 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
       LinkedHashSet 
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>List</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
       ArrayList 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Queue</code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
       Deque 
     </clt></code></td> 
   <td headers=""h2"">&nbsp;</td> 
   <td headers=""h3""><code> 
     <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
       ArrayDeque 
     </clt></code></td> 
   <td headers=""h4"">&nbsp;</td> 
   <td headers=""h5""><code> 
     <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
       LinkedList 
     </clt></code></td> 
   <td headers=""h6"">&nbsp;</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
       Map 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
       HashMap 
     </clt></code></td> 
   <td headers=""h3"">&nbsp;</td> 
   <td headers=""h4""><code> 
     <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
       TreeMap 
     </clt></code></td> 
   <td headers=""h5"">&nbsp;</td> 
   <td headers=""h6""><code> 
     <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
       LinkedHashMap 
     </clt></code></td> 
  </tr> 
 </tbody> 
</table> 
<p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> , and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> interfaces. In each case, one implementation ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a> ? is clearly the one to use for most applications, all other things being equal. Note that the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html"">(<code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>) and is listed in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> rows. There are two general-purpose <code>Queue</code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>, which is also a <code>List</code> implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a>, which is omitted from the table. These two implementations provide very different semantics: <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> provides FIFO semantics, while <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> orders its elements according to their values.</p>","PriorityQueue","java.util.PriorityQueue","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 3","<h3>Lesson: Implementations - part 3</h3>
<p>Each of the general-purpose implementations provides all optional operations contained in its interface. All permit <code>null</code> elements, keys, and values. None are synchronized (thread-safe). All have <em>fail-fast iterators</em>, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are <code> 
  <clt fqn=""java.io.Serializable"" api=""Serializable"" kind=""class"">
    Serializable 
  </clt></code> and all support a public <code>clone</code> method.</p> 
<p>The fact that these implementations are unsynchronized represents a break with the past: The legacy collections <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don't use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.</p>","Serializable","java.io.Serializable","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 3","<h3>Lesson: Implementations - part 3</h3>
<p>Each of the general-purpose implementations provides all optional operations contained in its interface. All permit <code>null</code> elements, keys, and values. None are synchronized (thread-safe). All have <em>fail-fast iterators</em>, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are <code> 
  <clt fqn=""java.io.Serializable"" api=""Serializable"" kind=""class"">
    Serializable 
  </clt></code> and all support a public <code>clone</code> method.</p> 
<p>The fact that these implementations are unsynchronized represents a break with the past: The legacy collections <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don't use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.</p>","Vector","java.util.Vector","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 3","<h3>Lesson: Implementations - part 3</h3>
<p>Each of the general-purpose implementations provides all optional operations contained in its interface. All permit <code>null</code> elements, keys, and values. None are synchronized (thread-safe). All have <em>fail-fast iterators</em>, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are <code> 
  <clt fqn=""java.io.Serializable"" api=""Serializable"" kind=""class"">
    Serializable 
  </clt></code> and all support a public <code>clone</code> method.</p> 
<p>The fact that these implementations are unsynchronized represents a break with the past: The legacy collections <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don't use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 4","<h3>Lesson: Implementations - part 4</h3>
<p>If you need thread-safe collections, the synchronization wrappers, described in the <a class=""TutorialLink"" target=""_top"" href=""wrapper.html"">Wrapper Implementations</a> section, allow <em>any</em> collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the <code>java.util.concurrent</code> package provides concurrent implementations of the <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> interface, which extends <code>Queue</code>, and of the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. These implementations offer much higher concurrency than mere synchronized implementations.</p> 
<p>As a rule, you should be thinking about the interfaces, <em> 
  <clt fqn=""java.math.BigInteger.not"" api=""BigInteger"" kind=""method"">
   BigInteger.not
  </clt></em> the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces</a> section, is to choose an implementation when a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.</p>","BlockingQueue","java.util.concurrent.BlockingQueue","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 4","<h3>Lesson: Implementations - part 4</h3>
<p>If you need thread-safe collections, the synchronization wrappers, described in the <a class=""TutorialLink"" target=""_top"" href=""wrapper.html"">Wrapper Implementations</a> section, allow <em>any</em> collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the <code>java.util.concurrent</code> package provides concurrent implementations of the <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> interface, which extends <code>Queue</code>, and of the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. These implementations offer much higher concurrency than mere synchronized implementations.</p> 
<p>As a rule, you should be thinking about the interfaces, <em> 
  <clt fqn=""java.math.BigInteger.not"" api=""BigInteger"" kind=""method"">
   BigInteger.not
  </clt></em> the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces</a> section, is to choose an implementation when a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.</p>","ConcurrentMap","java.util.concurrent.ConcurrentMap","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 4","<h3>Lesson: Implementations - part 4</h3>
<p>If you need thread-safe collections, the synchronization wrappers, described in the <a class=""TutorialLink"" target=""_top"" href=""wrapper.html"">Wrapper Implementations</a> section, allow <em>any</em> collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the <code>java.util.concurrent</code> package provides concurrent implementations of the <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> interface, which extends <code>Queue</code>, and of the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. These implementations offer much higher concurrency than mere synchronized implementations.</p> 
<p>As a rule, you should be thinking about the interfaces, <em> 
  <clt fqn=""java.math.BigInteger.not"" api=""BigInteger"" kind=""method"">
   BigInteger.not
  </clt></em> the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces</a> section, is to choose an implementation when a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.</p>","Map","java.util.Map","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 4","<h3>Lesson: Implementations - part 4</h3>
<p>If you need thread-safe collections, the synchronization wrappers, described in the <a class=""TutorialLink"" target=""_top"" href=""wrapper.html"">Wrapper Implementations</a> section, allow <em>any</em> collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the <code>java.util.concurrent</code> package provides concurrent implementations of the <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> interface, which extends <code>Queue</code>, and of the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. These implementations offer much higher concurrency than mere synchronized implementations.</p> 
<p>As a rule, you should be thinking about the interfaces, <em> 
  <clt fqn=""java.math.BigInteger.not"" api=""BigInteger"" kind=""method"">
   BigInteger.not
  </clt></em> the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces</a> section, is to choose an implementation when a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.</p>","BigInteger","java.math.BigInteger.not","class",FALSE
,"Lesson: Implementations","Lesson: Implementations - part 4","<h3>Lesson: Implementations - part 4</h3>
<p>If you need thread-safe collections, the synchronization wrappers, described in the <a class=""TutorialLink"" target=""_top"" href=""wrapper.html"">Wrapper Implementations</a> section, allow <em>any</em> collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the <code>java.util.concurrent</code> package provides concurrent implementations of the <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> interface, which extends <code>Queue</code>, and of the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. These implementations offer much higher concurrency than mere synchronized implementations.</p> 
<p>As a rule, you should be thinking about the interfaces, <em> 
  <clt fqn=""java.math.BigInteger.not"" api=""BigInteger"" kind=""method"">
   BigInteger.not
  </clt></em> the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces</a> section, is to choose an implementation when a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.</p>","Collection","java.util.Collection","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces","<div id=""PageTitle""> 
 <h1>Lesson: Interfaces</h1> 
</div> 
<p>The <i>core collection interfaces</i> encapsulate different types of collections, which are shown in the figure below. These interfaces allow collections to be manipulated independently of the details of their representation. Core collection interfaces are the foundation of the Java Collections Framework. As you can see in <span id=""figure:colls-coreInterfaces.gif"">the following figure</span>, the core collection interfaces form a hierarchy.</p> 
<center> 
 <p class=""FigureCaption"">The core collection interfaces.</p> 
</center> 
<p>A <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and so forth. Note also that the hierarchy consists of two distinct trees ? a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is not a true <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>Note that all the core collection interfaces are generic. For example, this is the declaration of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface.</p> 
<p>The <code>&lt;E&gt;</code> syntax tells you that the interface is generic. When you declare a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance you can <i>and should</i> specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. For information on generic types, see the <a class=""TutorialLink"" target=""_top"" href=""../../java/generics/index.html"">Generics (Updated)</a> lesson.</p>","Set","java.util.Set","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces","<div id=""PageTitle""> 
 <h1>Lesson: Interfaces</h1> 
</div> 
<p>The <i>core collection interfaces</i> encapsulate different types of collections, which are shown in the figure below. These interfaces allow collections to be manipulated independently of the details of their representation. Core collection interfaces are the foundation of the Java Collections Framework. As you can see in <span id=""figure:colls-coreInterfaces.gif"">the following figure</span>, the core collection interfaces form a hierarchy.</p> 
<center> 
 <p class=""FigureCaption"">The core collection interfaces.</p> 
</center> 
<p>A <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and so forth. Note also that the hierarchy consists of two distinct trees ? a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is not a true <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>Note that all the core collection interfaces are generic. For example, this is the declaration of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface.</p> 
<p>The <code>&lt;E&gt;</code> syntax tells you that the interface is generic. When you declare a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance you can <i>and should</i> specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. For information on generic types, see the <a class=""TutorialLink"" target=""_top"" href=""../../java/generics/index.html"">Generics (Updated)</a> lesson.</p>","Collection","java.util.Collection","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces","<div id=""PageTitle""> 
 <h1>Lesson: Interfaces</h1> 
</div> 
<p>The <i>core collection interfaces</i> encapsulate different types of collections, which are shown in the figure below. These interfaces allow collections to be manipulated independently of the details of their representation. Core collection interfaces are the foundation of the Java Collections Framework. As you can see in <span id=""figure:colls-coreInterfaces.gif"">the following figure</span>, the core collection interfaces form a hierarchy.</p> 
<center> 
 <p class=""FigureCaption"">The core collection interfaces.</p> 
</center> 
<p>A <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and so forth. Note also that the hierarchy consists of two distinct trees ? a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is not a true <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>Note that all the core collection interfaces are generic. For example, this is the declaration of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface.</p> 
<p>The <code>&lt;E&gt;</code> syntax tells you that the interface is generic. When you declare a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance you can <i>and should</i> specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. For information on generic types, see the <a class=""TutorialLink"" target=""_top"" href=""../../java/generics/index.html"">Generics (Updated)</a> lesson.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces","<div id=""PageTitle""> 
 <h1>Lesson: Interfaces</h1> 
</div> 
<p>The <i>core collection interfaces</i> encapsulate different types of collections, which are shown in the figure below. These interfaces allow collections to be manipulated independently of the details of their representation. Core collection interfaces are the foundation of the Java Collections Framework. As you can see in <span id=""figure:colls-coreInterfaces.gif"">the following figure</span>, the core collection interfaces form a hierarchy.</p> 
<center> 
 <p class=""FigureCaption"">The core collection interfaces.</p> 
</center> 
<p>A <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is a special kind of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and so forth. Note also that the hierarchy consists of two distinct trees ? a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is not a true <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>Note that all the core collection interfaces are generic. For example, this is the declaration of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface.</p> 
<p>The <code>&lt;E&gt;</code> syntax tells you that the interface is generic. When you declare a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance you can <i>and should</i> specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime. For information on generic types, see the <a class=""TutorialLink"" target=""_top"" href=""../../java/generics/index.html"">Generics (Updated)</a> lesson.</p>","Map","java.util.Map","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 2","<h3>Lesson: Interfaces - part 2</h3>
<p>When you understand how to use these interfaces, you will know most of what there is to know about the Java Collections Framework. This chapter discusses general guidelines for effective use of the interfaces, including when to use which interface. You'll also learn programming idioms for each interface to help you get the most out of it.</p> 
<p>To keep the number of core collection interfaces manageable, the Java platform doesn't provide separate interfaces for each variant of each collection type. (Such variants might include immutable, fixed-size, and append-only.) Instead, the modification operations in each interface are designated <i>optional</i> ? a given implementation may elect not to support all operations. If an unsupported operation is invoked, a collection throws an <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html""><code> 
   <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
     UnsupportedOperationException 
   </clt></code></a>. Implementations are responsible for documenting which of the optional operations they support. All of the Java platform's general-purpose implementations support all of the optional operations.</p>","UnsupportedOperationException","java.lang.UnsupportedOperationException","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 3","<h3>Lesson: Interfaces - part 3</h3>
<p>The following list describes the core collection interfaces:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> ? the root of the collection hierarchy. A collection represents a group of objects known as its <i>elements</i>. The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> and <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> ? a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section.</li> 
 <li><code>List</code> ? an ordered collection (sometimes called a <i>sequence</i>). <code>List</code>s can contain duplicate elements. The user of a <code>List</code> generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used <code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code>, you're familiar with the general flavor of <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""list.html"">The List Interface</a> section.</li> 
 <li><code>Queue</code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code>Queue</code> provides additional insertion, extraction, and inspection operations. <p>Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code> 
    <clt fqn=""java.util.Deque.poll"" api=""Deque"" kind=""method"">
     Deque.poll
    </clt></code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties. Also see <a class=""TutorialLink"" target=""_top"" href=""queue.html"">The Queue Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> provides additional insertion, extraction, and inspection operations. <p>Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see <a class=""TutorialLink"" target=""_top"" href=""deque.html"">The Deque Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> ? an object that maps keys to values. A <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> cannot contain duplicate keys; each key can map to at most one value. If you've used <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code>, you're already familiar with the basics of <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. Also see <a class=""TutorialLink"" target=""_top"" href=""map.html"">The Map Interface</a> section.</li> 
</ul>","Collection","java.util.Collection","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 3","<h3>Lesson: Interfaces - part 3</h3>
<p>The following list describes the core collection interfaces:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> ? the root of the collection hierarchy. A collection represents a group of objects known as its <i>elements</i>. The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> and <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> ? a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section.</li> 
 <li><code>List</code> ? an ordered collection (sometimes called a <i>sequence</i>). <code>List</code>s can contain duplicate elements. The user of a <code>List</code> generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used <code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code>, you're familiar with the general flavor of <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""list.html"">The List Interface</a> section.</li> 
 <li><code>Queue</code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code>Queue</code> provides additional insertion, extraction, and inspection operations. <p>Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code> 
    <clt fqn=""java.util.Deque.poll"" api=""Deque"" kind=""method"">
     Deque.poll
    </clt></code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties. Also see <a class=""TutorialLink"" target=""_top"" href=""queue.html"">The Queue Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> provides additional insertion, extraction, and inspection operations. <p>Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see <a class=""TutorialLink"" target=""_top"" href=""deque.html"">The Deque Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> ? an object that maps keys to values. A <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> cannot contain duplicate keys; each key can map to at most one value. If you've used <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code>, you're already familiar with the basics of <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. Also see <a class=""TutorialLink"" target=""_top"" href=""map.html"">The Map Interface</a> section.</li> 
</ul>","Set","java.util.Set","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 3","<h3>Lesson: Interfaces - part 3</h3>
<p>The following list describes the core collection interfaces:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> ? the root of the collection hierarchy. A collection represents a group of objects known as its <i>elements</i>. The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> and <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> ? a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section.</li> 
 <li><code>List</code> ? an ordered collection (sometimes called a <i>sequence</i>). <code>List</code>s can contain duplicate elements. The user of a <code>List</code> generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used <code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code>, you're familiar with the general flavor of <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""list.html"">The List Interface</a> section.</li> 
 <li><code>Queue</code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code>Queue</code> provides additional insertion, extraction, and inspection operations. <p>Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code> 
    <clt fqn=""java.util.Deque.poll"" api=""Deque"" kind=""method"">
     Deque.poll
    </clt></code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties. Also see <a class=""TutorialLink"" target=""_top"" href=""queue.html"">The Queue Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> provides additional insertion, extraction, and inspection operations. <p>Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see <a class=""TutorialLink"" target=""_top"" href=""deque.html"">The Deque Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> ? an object that maps keys to values. A <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> cannot contain duplicate keys; each key can map to at most one value. If you've used <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code>, you're already familiar with the basics of <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. Also see <a class=""TutorialLink"" target=""_top"" href=""map.html"">The Map Interface</a> section.</li> 
</ul>","Vector","java.util.Vector","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 3","<h3>Lesson: Interfaces - part 3</h3>
<p>The following list describes the core collection interfaces:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> ? the root of the collection hierarchy. A collection represents a group of objects known as its <i>elements</i>. The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> and <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> ? a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section.</li> 
 <li><code>List</code> ? an ordered collection (sometimes called a <i>sequence</i>). <code>List</code>s can contain duplicate elements. The user of a <code>List</code> generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used <code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code>, you're familiar with the general flavor of <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""list.html"">The List Interface</a> section.</li> 
 <li><code>Queue</code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code>Queue</code> provides additional insertion, extraction, and inspection operations. <p>Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code> 
    <clt fqn=""java.util.Deque.poll"" api=""Deque"" kind=""method"">
     Deque.poll
    </clt></code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties. Also see <a class=""TutorialLink"" target=""_top"" href=""queue.html"">The Queue Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> provides additional insertion, extraction, and inspection operations. <p>Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see <a class=""TutorialLink"" target=""_top"" href=""deque.html"">The Deque Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> ? an object that maps keys to values. A <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> cannot contain duplicate keys; each key can map to at most one value. If you've used <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code>, you're already familiar with the basics of <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. Also see <a class=""TutorialLink"" target=""_top"" href=""map.html"">The Map Interface</a> section.</li> 
</ul>","Deque","java.util.Deque.poll","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 3","<h3>Lesson: Interfaces - part 3</h3>
<p>The following list describes the core collection interfaces:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> ? the root of the collection hierarchy. A collection represents a group of objects known as its <i>elements</i>. The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> and <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> ? a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section.</li> 
 <li><code>List</code> ? an ordered collection (sometimes called a <i>sequence</i>). <code>List</code>s can contain duplicate elements. The user of a <code>List</code> generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used <code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code>, you're familiar with the general flavor of <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""list.html"">The List Interface</a> section.</li> 
 <li><code>Queue</code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code>Queue</code> provides additional insertion, extraction, and inspection operations. <p>Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code> 
    <clt fqn=""java.util.Deque.poll"" api=""Deque"" kind=""method"">
     Deque.poll
    </clt></code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties. Also see <a class=""TutorialLink"" target=""_top"" href=""queue.html"">The Queue Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> provides additional insertion, extraction, and inspection operations. <p>Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see <a class=""TutorialLink"" target=""_top"" href=""deque.html"">The Deque Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> ? an object that maps keys to values. A <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> cannot contain duplicate keys; each key can map to at most one value. If you've used <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code>, you're already familiar with the basics of <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. Also see <a class=""TutorialLink"" target=""_top"" href=""map.html"">The Map Interface</a> section.</li> 
</ul>","Map","java.util.Map","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 3","<h3>Lesson: Interfaces - part 3</h3>
<p>The following list describes the core collection interfaces:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> ? the root of the collection hierarchy. A collection represents a group of objects known as its <i>elements</i>. The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of collections allow duplicate elements, and others do not. Some are ordered and others are unordered. The Java platform doesn't provide any direct implementations of this interface but provides implementations of more specific subinterfaces, such as <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> and <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> ? a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student's schedule, or the processes running on a machine. See also <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section.</li> 
 <li><code>List</code> ? an ordered collection (sometimes called a <i>sequence</i>). <code>List</code>s can contain duplicate elements. The user of a <code>List</code> generally has precise control over where in the list each element is inserted and can access elements by their integer index (position). If you've used <code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code>, you're familiar with the general flavor of <code>List</code>. Also see <a class=""TutorialLink"" target=""_top"" href=""list.html"">The List Interface</a> section.</li> 
 <li><code>Queue</code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code>Queue</code> provides additional insertion, extraction, and inspection operations. <p>Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements' natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code> 
    <clt fqn=""java.util.Deque.poll"" api=""Deque"" kind=""method"">
     Deque.poll
    </clt></code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties. Also see <a class=""TutorialLink"" target=""_top"" href=""queue.html"">The Queue Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> ? a collection used to hold multiple elements prior to processing. Besides basic <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> operations, a <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> provides additional insertion, extraction, and inspection operations. <p>Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see <a class=""TutorialLink"" target=""_top"" href=""deque.html"">The Deque Interface</a> section.</p> </li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> ? an object that maps keys to values. A <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> cannot contain duplicate keys; each key can map to at most one value. If you've used <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code>, you're already familiar with the basics of <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. Also see <a class=""TutorialLink"" target=""_top"" href=""map.html"">The Map Interface</a> section.</li> 
</ul>","Hashtable","java.util.Hashtable","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 4","<h3>Lesson: Interfaces - part 4</h3>
<p>The last two core collection interfaces are merely sorted versions of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> that maintains its mappings in ascending key order. This is the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> analog of <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code>. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-map.html"">The SortedMap Interface</a> section.</li> 
</ul> 
<p>To understand how the sorted interfaces maintain the order of their elements, see the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. </p>","Set","java.util.Set","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 4","<h3>Lesson: Interfaces - part 4</h3>
<p>The last two core collection interfaces are merely sorted versions of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> that maintains its mappings in ascending key order. This is the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> analog of <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code>. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-map.html"">The SortedMap Interface</a> section.</li> 
</ul> 
<p>To understand how the sorted interfaces maintain the order of their elements, see the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. </p>","Map","java.util.Map","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 4","<h3>Lesson: Interfaces - part 4</h3>
<p>The last two core collection interfaces are merely sorted versions of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> that maintains its mappings in ascending key order. This is the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> analog of <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code>. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-map.html"">The SortedMap Interface</a> section.</li> 
</ul> 
<p>To understand how the sorted interfaces maintain the order of their elements, see the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. </p>","SortedSet","java.util.SortedSet","class",FALSE
,"Lesson: Interfaces","Lesson: Interfaces - part 4","<h3>Lesson: Interfaces - part 4</h3>
<p>The last two core collection interfaces are merely sorted versions of <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section.</li> 
 <li><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> that maintains its mappings in ascending key order. This is the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> analog of <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code>. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see <a class=""TutorialLink"" target=""_top"" href=""sorted-map.html"">The SortedMap Interface</a> section.</li> 
</ul> 
<p>To understand how the sorted interfaces maintain the order of their elements, see the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. </p>","SortedMap","java.util.SortedMap","class",FALSE
,"Lesson: Interoperability","Lesson: Interoperability","<div id=""PageTitle""> 
 <h1>Lesson: Interoperability</h1> 
</div> 
<p>In this section, you'll learn about the following two aspects of interoperability:</p> 
<ul> 
 <li> <a class=""TutorialLink"" target=""_top"" href=""compatibility.html"">Compatibility</a>: This subsection describes how collections can be made to work with older APIs that predate the addition of <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>s to the Java platform.</li> 
 <li> <a class=""TutorialLink"" target=""_top"" href=""api-design.html"">API Design</a>: This subsection describes how to design new APIs so that they will interoperate seamlessly with one another.</li> 
</ul>","Collection","java.util.Collection","class",FALSE
,"Lesson: Introduction to Collections","What Is a Collections Framework?","<h2>What Is a 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Framework?</h2> 
<p>A <i>collections framework</i> is a unified architecture for representing and manipulating collections. All collections frameworks contain the following:</p> 
<ul> 
 <li><b>Interfaces:</b> These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.</li> 
 <li><b>Implementations:</b> These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.</li> 
 <li><b>Algorithms:</b> These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be <i>polymorphic</i>: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.</li> 
</ul> 
<p>Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk's collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.</p>","Collections","java.util.Collections","class",FALSE
,"Lesson: Introduction to Collections","Benefits of the Java Collections Framework","<h2>Benefits of the Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Framework</h2> 
<p>The Java Collections Framework provides the following benefits:</p> 
<ul> 
 <li><b>Reduces programming effort:</b> By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level &quot;plumbing&quot; required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs.</li> 
 <li><b>Increases program speed and quality:</b> This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you're freed from the drudgery of writing your own data structures, you'll have more time to devote to improving programs' quality and performance.</li> 
 <li><b>Allows interoperability among unrelated APIs:</b> The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently.</li> 
 <li><b>Reduces effort to learn and to use new APIs:</b> Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away.</li> 
 <li><b>Reduces effort to design new APIs:</b> This is the flip side of the previous advantage. Designers and implementers don't have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces.</li> 
 <li><b>Fosters software reuse:</b> New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.</li> 
</ul>","Collections","java.util.Collections","class",FALSE
,"List Implementations","General-Purpose List Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p>There are two general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>. Most of the time, you'll probably use <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the <code>List</code>, and it can take advantage of <code> 
  <clt fqn=""java.lang.System.arraycopy"" api=""System"" kind=""method"">
   System.arraycopy
  </clt></code> when it has to move multiple elements at the same time. Think of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> as <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> without the synchronization overhead.</p> 
<p>If you frequently add elements to the beginning of the <code>List</code> or iterate over the <code>List</code> to delete elements from its interior, you should consider using <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>. These operations require constant-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and linear-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. But you pay a big price in performance. Positional access requires linear-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and constant-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. Furthermore, the constant factor for <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is much worse. If you think you want to use a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>, measure the performance of your application with both <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> before making your choice; <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> is usually faster.</p>","List","java.util.List","class",FALSE
,"List Implementations","General-Purpose List Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p>There are two general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>. Most of the time, you'll probably use <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the <code>List</code>, and it can take advantage of <code> 
  <clt fqn=""java.lang.System.arraycopy"" api=""System"" kind=""method"">
   System.arraycopy
  </clt></code> when it has to move multiple elements at the same time. Think of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> as <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> without the synchronization overhead.</p> 
<p>If you frequently add elements to the beginning of the <code>List</code> or iterate over the <code>List</code> to delete elements from its interior, you should consider using <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>. These operations require constant-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and linear-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. But you pay a big price in performance. Positional access requires linear-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and constant-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. Furthermore, the constant factor for <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is much worse. If you think you want to use a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>, measure the performance of your application with both <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> before making your choice; <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> is usually faster.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"List Implementations","General-Purpose List Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p>There are two general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>. Most of the time, you'll probably use <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the <code>List</code>, and it can take advantage of <code> 
  <clt fqn=""java.lang.System.arraycopy"" api=""System"" kind=""method"">
   System.arraycopy
  </clt></code> when it has to move multiple elements at the same time. Think of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> as <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> without the synchronization overhead.</p> 
<p>If you frequently add elements to the beginning of the <code>List</code> or iterate over the <code>List</code> to delete elements from its interior, you should consider using <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>. These operations require constant-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and linear-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. But you pay a big price in performance. Positional access requires linear-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and constant-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. Furthermore, the constant factor for <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is much worse. If you think you want to use a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>, measure the performance of your application with both <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> before making your choice; <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> is usually faster.</p>","LinkedList","java.util.LinkedList","class",FALSE
,"List Implementations","General-Purpose List Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p>There are two general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>. Most of the time, you'll probably use <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the <code>List</code>, and it can take advantage of <code> 
  <clt fqn=""java.lang.System.arraycopy"" api=""System"" kind=""method"">
   System.arraycopy
  </clt></code> when it has to move multiple elements at the same time. Think of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> as <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> without the synchronization overhead.</p> 
<p>If you frequently add elements to the beginning of the <code>List</code> or iterate over the <code>List</code> to delete elements from its interior, you should consider using <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>. These operations require constant-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and linear-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. But you pay a big price in performance. Positional access requires linear-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and constant-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. Furthermore, the constant factor for <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is much worse. If you think you want to use a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>, measure the performance of your application with both <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> before making your choice; <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> is usually faster.</p>","System","java.lang.System.arraycopy","class",FALSE
,"List Implementations","General-Purpose List Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p>There are two general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a>. Most of the time, you'll probably use <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the <code>List</code>, and it can take advantage of <code> 
  <clt fqn=""java.lang.System.arraycopy"" api=""System"" kind=""method"">
   System.arraycopy
  </clt></code> when it has to move multiple elements at the same time. Think of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> as <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> without the synchronization overhead.</p> 
<p>If you frequently add elements to the beginning of the <code>List</code> or iterate over the <code>List</code> to delete elements from its interior, you should consider using <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>. These operations require constant-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and linear-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. But you pay a big price in performance. Positional access requires linear-time in a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and constant-time in an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>. Furthermore, the constant factor for <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is much worse. If you think you want to use a <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code>, measure the performance of your application with both <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> and <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> before making your choice; <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> is usually faster.</p>","Vector","java.util.Vector","class",FALSE
,"List Implementations","General-Purpose List Implementations - part 2","<h3>General-Purpose List Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> has one tuning parameter ? the <em>initial capacity</em>, which refers to the number of elements the <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> can hold before it has to grow. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> has no tuning parameters and seven optional operations, one of which is <code>clone</code>. The other six are <code> 
  <clt fqn=""java.util.LinkedList.addFirst"" api=""LinkedList"" kind=""method"">
   LinkedList.addFirst
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.getFirst"" api=""LinkedList"" kind=""method"">
   LinkedList.getFirst
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.removeFirst"" api=""LinkedList"" kind=""method"">
   LinkedList.removeFirst
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.addLast"" api=""LinkedList"" kind=""method"">
   LinkedList.addLast
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.getLast"" api=""LinkedList"" kind=""method"">
   LinkedList.getLast
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedList.removeLast"" api=""LinkedList"" kind=""method"">
   LinkedList.removeLast
  </clt></code>. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> also implements the <code>Queue</code> interface.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"List Implementations","General-Purpose List Implementations - part 2","<h3>General-Purpose List Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> has one tuning parameter ? the <em>initial capacity</em>, which refers to the number of elements the <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> can hold before it has to grow. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> has no tuning parameters and seven optional operations, one of which is <code>clone</code>. The other six are <code> 
  <clt fqn=""java.util.LinkedList.addFirst"" api=""LinkedList"" kind=""method"">
   LinkedList.addFirst
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.getFirst"" api=""LinkedList"" kind=""method"">
   LinkedList.getFirst
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.removeFirst"" api=""LinkedList"" kind=""method"">
   LinkedList.removeFirst
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.addLast"" api=""LinkedList"" kind=""method"">
   LinkedList.addLast
  </clt></code>, <code> 
  <clt fqn=""java.util.LinkedList.getLast"" api=""LinkedList"" kind=""method"">
   LinkedList.getLast
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedList.removeLast"" api=""LinkedList"" kind=""method"">
   LinkedList.removeLast
  </clt></code>. <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> also implements the <code>Queue</code> interface.</p>","LinkedList","java.util.LinkedList","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","List","java.util.List","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","CopyOnWriteArrayList","java.util.concurrent.CopyOnWriteArrayList","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","CopyOnWriteArraySet","java.util.concurrent.CopyOnWriteArraySet","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","ConcurrentModificationException","java.util.ConcurrentModificationException","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","Vector","java.util.Vector","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","Collections","java.util.Collections","class",FALSE
,"List Implementations","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","Arrays","java.util.Arrays.asList","class",FALSE
,"Map Implementations","Map Implementations","<div id=""PageTitle""> 
 <h1>Map Implementations</h1> 
</div> 
<p><code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations are grouped into general-purpose, special-purpose, and concurrent implementations.</p>","Map","java.util.Map","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","Map","java.util.Map","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","HashMap","java.util.HashMap","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","TreeMap","java.util.TreeMap","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","LinkedHashMap","java.util.LinkedHashMap","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","Collection","java.util.Collection","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","Set","java.util.Set","class",FALSE
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","LinkedHashSet","java.util.LinkedHashSet","class",FALSE
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","Map","java.util.Map","class",FALSE
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","EnumMap","java.util.EnumMap","class",FALSE
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","WeakHashMap","java.util.WeakHashMap","class",FALSE
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","IdentityHashMap","java.util.IdentityHashMap","class",FALSE
,"Map Implementations","Special-Purpose Map Implementations - part 2","<h3>Special-Purpose Map Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> is an identity-based <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based &quot;node table&quot; that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting &quot;spoof attacks&quot; that are a result of intentionally perverse <code>equals</code> methods because <code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> never invokes the <code>equals</code> method on its keys. An added benefit of this implementation is that it is fast.</p>","IdentityHashMap","java.util.IdentityHashMap","class",FALSE
,"Map Implementations","Special-Purpose Map Implementations - part 2","<h3>Special-Purpose Map Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> is an identity-based <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based &quot;node table&quot; that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting &quot;spoof attacks&quot; that are a result of intentionally perverse <code>equals</code> methods because <code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> never invokes the <code>equals</code> method on its keys. An added benefit of this implementation is that it is fast.</p>","Map","java.util.Map","class",FALSE
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","Map","java.util.Map","class",FALSE
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","ConcurrentMap","java.util.concurrent.ConcurrentMap","class",FALSE
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","ConcurrentHashMap","java.util.concurrent.ConcurrentHashMap","class",FALSE
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","String","java.lang.String","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","Comparable","java.lang.Comparable","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","Character","java.lang.Character","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","Long","java.lang.Long","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","Integer","java.lang.Integer","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","Short","java.lang.Short","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","BigInteger","java.math.BigInteger","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","BigDecimal","java.math.BigDecimal","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","Boolean","java.lang.Boolean","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","File","java.io.File","class",FALSE
,"Object Ordering","Object Ordering","<div id=""PageTitle""> 
 <h1>Object Ordering</h1> 
</div> 
<p>A <code>List</code> <code>l</code> may be sorted as follows.</p> 
<p>If the <code>List</code> consists of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements, it will be sorted into alphabetical order. If it consists of <code>Date</code> elements, it will be sorted into chronological order. How does this happen? <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and <code>Date</code> both implement the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface. <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> implementations provide a <i>natural ordering</i> for a class, which allows objects of that class to be sorted automatically. The <span id=""table:comparable-implementations"">following table</span> summarizes some of the more important Java platform classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p> 
<table summary=""comparable-implementations"" border=""1""> 
 <caption id=""comparable-implementations""> 
  <strong>Classes Implementing Comparable</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Class</th> 
   <th id=""h2"">Natural Ordering</th> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Byte</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Character"" api=""Character"" kind=""class"">
       Character 
     </clt></code></td> 
   <td headers=""h2"">Unsigned numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Long"" api=""Long"" kind=""class"">
       Long 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Integer"" api=""Integer"" kind=""class"">
       Integer 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Short"" api=""Short"" kind=""class"">
       Short 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Double</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Float</code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigInteger"" api=""BigInteger"" kind=""class"">
       BigInteger 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.math.BigDecimal"" api=""BigDecimal"" kind=""class"">
       BigDecimal 
     </clt></code></td> 
   <td headers=""h2"">Signed numerical</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.Boolean"" api=""Boolean"" kind=""class"">
       Boolean 
     </clt></code></td> 
   <td headers=""h2""><code> 
     <clt fqn=""java.lang.Boolean.TRUE"" api=""Boolean"" kind=""field"">
      Boolean.FALSE &lt; Boolean.Boolean.TRUE
     </clt></code></td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.io.File"" api=""File"" kind=""class"">
       File 
     </clt></code></td> 
   <td headers=""h2"">System-dependent lexicographic on path name</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
       String 
     </clt></code></td> 
   <td headers=""h2"">Lexicographic</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code>Date</code></td> 
   <td headers=""h2"">Chronological</td> 
  </tr> 
  <tr> 
   <td headers=""h1""><code> 
     <clt fqn=""java.text.CollationKey"" api=""CollationKey"" kind=""class"">
       CollationKey 
     </clt></code></td> 
   <td headers=""h2"">Locale-specific lexicographic</td> 
  </tr> 
 </tbody> 
</table>","CollationKey","java.text.CollationKey","class",FALSE
,"Object Ordering","Object Ordering - part 2","<h3>Object Ordering - part 2</h3>
<p>If you try to sort a list, the elements of which do not implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>, <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.Collections.sort(list)
  </clt></code> will throw a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html""><code> 
   <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
     ClassCastException 
   </clt></code></a>. Similarly, <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.sort(list, comparator) 
  </clt></code> will throw a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if you try to sort a list whose elements cannot be compared to one another using the <code> 
  <clt fqn=""java.util.TreeSet.comparator"" api=""TreeSet"" kind=""method"">
   TreeSet.comparator
  </clt></code>. Elements that can be compared to one another are called <i>mutually comparable</i>. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison.</p> 
<p>This is all you really need to know about the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> type.</p>","Comparable","java.lang.Comparable","class",FALSE
,"Object Ordering","Object Ordering - part 2","<h3>Object Ordering - part 2</h3>
<p>If you try to sort a list, the elements of which do not implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>, <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.Collections.sort(list)
  </clt></code> will throw a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html""><code> 
   <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
     ClassCastException 
   </clt></code></a>. Similarly, <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.sort(list, comparator) 
  </clt></code> will throw a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if you try to sort a list whose elements cannot be compared to one another using the <code> 
  <clt fqn=""java.util.TreeSet.comparator"" api=""TreeSet"" kind=""method"">
   TreeSet.comparator
  </clt></code>. Elements that can be compared to one another are called <i>mutually comparable</i>. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison.</p> 
<p>This is all you really need to know about the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> type.</p>","Collections","java.util.Collections.sort","class",FALSE
,"Object Ordering","Object Ordering - part 2","<h3>Object Ordering - part 2</h3>
<p>If you try to sort a list, the elements of which do not implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>, <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.Collections.sort(list)
  </clt></code> will throw a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html""><code> 
   <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
     ClassCastException 
   </clt></code></a>. Similarly, <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.sort(list, comparator) 
  </clt></code> will throw a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if you try to sort a list whose elements cannot be compared to one another using the <code> 
  <clt fqn=""java.util.TreeSet.comparator"" api=""TreeSet"" kind=""method"">
   TreeSet.comparator
  </clt></code>. Elements that can be compared to one another are called <i>mutually comparable</i>. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison.</p> 
<p>This is all you really need to know about the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> type.</p>","ClassCastException","java.lang.ClassCastException","class",FALSE
,"Object Ordering","Object Ordering - part 2","<h3>Object Ordering - part 2</h3>
<p>If you try to sort a list, the elements of which do not implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>, <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.Collections.sort(list)
  </clt></code> will throw a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html""><code> 
   <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
     ClassCastException 
   </clt></code></a>. Similarly, <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.sort(list, comparator) 
  </clt></code> will throw a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if you try to sort a list whose elements cannot be compared to one another using the <code> 
  <clt fqn=""java.util.TreeSet.comparator"" api=""TreeSet"" kind=""method"">
   TreeSet.comparator
  </clt></code>. Elements that can be compared to one another are called <i>mutually comparable</i>. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison.</p> 
<p>This is all you really need to know about the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> type.</p>","TreeSet","java.util.TreeSet.comparator","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types","<h2>Writing Your Own 
 <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
   Comparable 
 </clt>Types</h2> 
<p>The <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface consists of the following method.</p> 
<p>The <code>compareTo</code> method compares the receiving object with the specified object and returns a negative integer, 0, or a positive integer depending on whether the receiving object is less than, equal to, or greater than the specified object. If the specified object cannot be compared to the receiving object, the method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>The <a class=""SourceLink"" target=""_blank"" href=""examples/Name.java"" onclick=""showCode('../../displayCode.html', 'examples/Name.java'); return false;""><code>following class representing a person's name</code></a> implements <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p>","Comparable","java.lang.Comparable","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types","<h2>Writing Your Own 
 <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
   Comparable 
 </clt>Types</h2> 
<p>The <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface consists of the following method.</p> 
<p>The <code>compareTo</code> method compares the receiving object with the specified object and returns a negative integer, 0, or a positive integer depending on whether the receiving object is less than, equal to, or greater than the specified object. If the specified object cannot be compared to the receiving object, the method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>The <a class=""SourceLink"" target=""_blank"" href=""examples/Name.java"" onclick=""showCode('../../displayCode.html', 'examples/Name.java'); return false;""><code>following class representing a person's name</code></a> implements <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>.</p>","ClassCastException","java.lang.ClassCastException","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types - part 2","<h3>Writing Your Own Comparable Types - part 2</h3>
<p>To keep the preceding example short, the class is somewhat limited: It doesn't support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are <i>immutable</i>. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>s or as keys in <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>s. These collections will break if you modify their elements or keys while they're in the collection.</li> 
 <li>The constructor checks its arguments for <code>null</code>. This ensures that all <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are well formed so that none of the other methods will ever throw a <code> 
   <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
     NullPointerException 
   </clt></code>.</li> 
 <li>The <code>hashCode</code> method is redefined. This is essential for any class that redefines the <code>equals</code> method. (Equal objects must have equal hash codes.)</li> 
 <li>The <code>equals</code> method returns <code>false</code> if the specified object is <code>null</code> or of an inappropriate type. The <code>compareTo</code> method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods.</li> 
 <li>The <code>toString</code> method has been redefined so it prints the <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types' <code>toString</code> methods depend on the <code>toString</code> methods of their elements, keys, and values.</li> 
</ul>","Name","java.util.jar.Attributes.Name","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types - part 2","<h3>Writing Your Own Comparable Types - part 2</h3>
<p>To keep the preceding example short, the class is somewhat limited: It doesn't support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are <i>immutable</i>. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>s or as keys in <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>s. These collections will break if you modify their elements or keys while they're in the collection.</li> 
 <li>The constructor checks its arguments for <code>null</code>. This ensures that all <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are well formed so that none of the other methods will ever throw a <code> 
   <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
     NullPointerException 
   </clt></code>.</li> 
 <li>The <code>hashCode</code> method is redefined. This is essential for any class that redefines the <code>equals</code> method. (Equal objects must have equal hash codes.)</li> 
 <li>The <code>equals</code> method returns <code>false</code> if the specified object is <code>null</code> or of an inappropriate type. The <code>compareTo</code> method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods.</li> 
 <li>The <code>toString</code> method has been redefined so it prints the <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types' <code>toString</code> methods depend on the <code>toString</code> methods of their elements, keys, and values.</li> 
</ul>","Set","java.util.Set","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types - part 2","<h3>Writing Your Own Comparable Types - part 2</h3>
<p>To keep the preceding example short, the class is somewhat limited: It doesn't support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are <i>immutable</i>. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>s or as keys in <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>s. These collections will break if you modify their elements or keys while they're in the collection.</li> 
 <li>The constructor checks its arguments for <code>null</code>. This ensures that all <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are well formed so that none of the other methods will ever throw a <code> 
   <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
     NullPointerException 
   </clt></code>.</li> 
 <li>The <code>hashCode</code> method is redefined. This is essential for any class that redefines the <code>equals</code> method. (Equal objects must have equal hash codes.)</li> 
 <li>The <code>equals</code> method returns <code>false</code> if the specified object is <code>null</code> or of an inappropriate type. The <code>compareTo</code> method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods.</li> 
 <li>The <code>toString</code> method has been redefined so it prints the <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types' <code>toString</code> methods depend on the <code>toString</code> methods of their elements, keys, and values.</li> 
</ul>","Map","java.util.Map","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types - part 2","<h3>Writing Your Own Comparable Types - part 2</h3>
<p>To keep the preceding example short, the class is somewhat limited: It doesn't support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are <i>immutable</i>. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>s or as keys in <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>s. These collections will break if you modify their elements or keys while they're in the collection.</li> 
 <li>The constructor checks its arguments for <code>null</code>. This ensures that all <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> objects are well formed so that none of the other methods will ever throw a <code> 
   <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
     NullPointerException 
   </clt></code>.</li> 
 <li>The <code>hashCode</code> method is redefined. This is essential for any class that redefines the <code>equals</code> method. (Equal objects must have equal hash codes.)</li> 
 <li>The <code>equals</code> method returns <code>false</code> if the specified object is <code>null</code> or of an inappropriate type. The <code>compareTo</code> method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods.</li> 
 <li>The <code>toString</code> method has been redefined so it prints the <code> 
   <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
     Name 
   </clt></code> in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types' <code>toString</code> methods depend on the <code>toString</code> methods of their elements, keys, and values.</li> 
</ul>","NullPointerException","java.lang.NullPointerException","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types - part 3","<h3>Writing Your Own Comparable Types - part 3</h3>
<p>Since this section is about element ordering, let's talk a bit more about <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code>'s <code>compareTo</code> method. It implements the standard name-ordering algorithm, where last names take precedence over first names. This is exactly what you want in a natural ordering. It would be very confusing indeed if the natural ordering were unnatural!</p> 
<p>Take a look at how <code>compareTo</code> is implemented, because it's quite typical. First, you compare the most significant part of the object (in this case, the last name). Often, you can just use the natural ordering of the part's type. In this case, the part is a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and the natural (lexicographic) ordering is exactly what's called for. If the comparison results in anything other than zero, which represents equality, you're done: You just return the result. If the most significant parts are equal, you go on to compare the next most-significant parts. In this case, there are only two parts ? first name and last name. If there were more parts, you'd proceed in the obvious fashion, comparing parts until you found two that weren't equal or you were comparing the least-significant parts, at which point you'd return the result of the comparison.</p>","Name","java.util.jar.Attributes.Name","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types - part 3","<h3>Writing Your Own Comparable Types - part 3</h3>
<p>Since this section is about element ordering, let's talk a bit more about <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code>'s <code>compareTo</code> method. It implements the standard name-ordering algorithm, where last names take precedence over first names. This is exactly what you want in a natural ordering. It would be very confusing indeed if the natural ordering were unnatural!</p> 
<p>Take a look at how <code>compareTo</code> is implemented, because it's quite typical. First, you compare the most significant part of the object (in this case, the last name). Often, you can just use the natural ordering of the part's type. In this case, the part is a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> and the natural (lexicographic) ordering is exactly what's called for. If the comparison results in anything other than zero, which represents equality, you're done: You just return the result. If the most significant parts are equal, you go on to compare the next most-significant parts. In this case, there are only two parts ? first name and last name. If there were more parts, you'd proceed in the obvious fashion, comparing parts until you found two that weren't equal or you were comparing the least-significant parts, at which point you'd return the result of the comparison.</p>","String","java.lang.String","class",FALSE
,"Object Ordering","Writing Your Own Comparable Types - part 4","<h3>Writing Your Own Comparable Types - part 4</h3>
<p>Just to show that it all works, here's <a class=""SourceLink"" target=""_blank"" href=""examples/NameSort.java"" onclick=""showCode('../../displayCode.html', 'examples/NameSort.java'); return false;""><code>a program that builds a list of names and sorts them</code></a>.</p> 
<p>If you run this program, here's what it prints.</p> 
<p>There are four restrictions on the behavior of the <code>compareTo</code> method, which we won't go into now because they're fairly technical and boring and are better left in the API documentation. It's really important that all classes that implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> obey these restrictions, so read the documentation for <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> if you're writing a class that implements it. Attempting to sort a list of objects that violate the restrictions has undefined behavior. Technically speaking, these restrictions ensure that the natural ordering is a <i>total order</i> on the objects of a class that implements it; this is necessary to ensure that sorting is well defined.</p>","Comparable","java.lang.Comparable","class",FALSE
,"Object Ordering","Comparators","<h2>Comparators</h2> 
<p>What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>? To do either of these things, you'll need to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> ? an object that encapsulates an ordering. Like the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface, the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface consists of a single method.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>, the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>Much of what was said about <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> applies to <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> as well. Writing a <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method is nearly identical to writing a <code>compareTo</code> method, except that the former gets both objects passed in as arguments. The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method has to obey the same four technical restrictions as <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>'s <code>compareTo</code> method for the same reason ? a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> must induce a total order on the objects it compares.</p>","Comparable","java.lang.Comparable","class",FALSE
,"Object Ordering","Comparators","<h2>Comparators</h2> 
<p>What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>? To do either of these things, you'll need to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> ? an object that encapsulates an ordering. Like the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface, the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface consists of a single method.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>, the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>Much of what was said about <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> applies to <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> as well. Writing a <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method is nearly identical to writing a <code>compareTo</code> method, except that the former gets both objects passed in as arguments. The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method has to obey the same four technical restrictions as <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>'s <code>compareTo</code> method for the same reason ? a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> must induce a total order on the objects it compares.</p>","Comparator","java.util.Comparator","class",FALSE
,"Object Ordering","Comparators","<h2>Comparators</h2> 
<p>What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>? To do either of these things, you'll need to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> ? an object that encapsulates an ordering. Like the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface, the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface consists of a single method.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>, the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>Much of what was said about <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> applies to <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> as well. Writing a <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method is nearly identical to writing a <code>compareTo</code> method, except that the former gets both objects passed in as arguments. The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method has to obey the same four technical restrictions as <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>'s <code>compareTo</code> method for the same reason ? a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> must induce a total order on the objects it compares.</p>","ClassCastException","java.lang.ClassCastException","class",FALSE
,"Object Ordering","Comparators - part 2","<h3>Comparators - part 2</h3>
<p>Suppose you have a class called <code>Employee</code>, as follows.</p> 
<p>Let's assume that the natural ordering of <code>Employee</code> instances is <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code> ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the program is reasonably straightforward. It relies on the natural ordering of <code>Date</code> applied to the values returned by the <code>hireDate</code> accessor method. Note that the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison.</p>","Name","java.util.jar.Attributes.Name","class",FALSE
,"Object Ordering","Comparators - part 2","<h3>Comparators - part 2</h3>
<p>Suppose you have a class called <code>Employee</code>, as follows.</p> 
<p>Let's assume that the natural ordering of <code>Employee</code> instances is <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code> ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the program is reasonably straightforward. It relies on the natural ordering of <code>Date</code> applied to the values returned by the <code>hireDate</code> accessor method. Note that the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison.</p>","Comparator","java.util.Comparator","class",FALSE
,"Object Ordering","Comparators - part 3","<h3>Comparators - part 3</h3>
<p>You should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the <code>compareTo</code> method can return any negative <code>int</code> if its argument is less than the object on which it is invoked. There is one negative <code>int</code> that remains negative when negated, strange as it may seem.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the preceding program works fine for sorting a <code>List</code>, but it does have one deficiency: It cannot be used to order a sorted collection, such as <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, because it generates an ordering that is <i>not compatible with</i> equals. This means that this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> equates objects that the <code>equals</code> method does not. In particular, any two employees who were hired on the same date will compare as equal. When you're sorting a <code>List</code>, this doesn't matter; but when you're using the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to order a sorted collection, it's fatal. If you use this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to insert multiple employees hired on the same date into a <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.</p>","Comparator","java.util.Comparator","class",FALSE
,"Object Ordering","Comparators - part 3","<h3>Comparators - part 3</h3>
<p>You should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the <code>compareTo</code> method can return any negative <code>int</code> if its argument is less than the object on which it is invoked. There is one negative <code>int</code> that remains negative when negated, strange as it may seem.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the preceding program works fine for sorting a <code>List</code>, but it does have one deficiency: It cannot be used to order a sorted collection, such as <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, because it generates an ordering that is <i>not compatible with</i> equals. This means that this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> equates objects that the <code>equals</code> method does not. In particular, any two employees who were hired on the same date will compare as equal. When you're sorting a <code>List</code>, this doesn't matter; but when you're using the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to order a sorted collection, it's fatal. If you use this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to insert multiple employees hired on the same date into a <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"Object Ordering","Comparators - part 4","<h3>Comparators - part 4</h3>
<p>To fix this problem, simply tweak the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> so that it produces an ordering that <i>is compatible with</i> <code>equals</code>. In other words, tweak it so that the only elements seen as equal when using <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> are those that are also seen as equal when compared using <code>equals</code>. The way to do this is to perform a two-part comparison (as for <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code>), where the first part is the one we're interested in ? in this case, the hire date ? and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that results.</p> 
<p>One last note: You might be tempted to replace the final <code>return</code> statement in the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> with the simpler:</p>","Comparator","java.util.Comparator","class",FALSE
,"Object Ordering","Comparators - part 4","<h3>Comparators - part 4</h3>
<p>To fix this problem, simply tweak the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> so that it produces an ordering that <i>is compatible with</i> <code>equals</code>. In other words, tweak it so that the only elements seen as equal when using <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> are those that are also seen as equal when compared using <code>equals</code>. The way to do this is to perform a two-part comparison (as for <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code>), where the first part is the one we're interested in ? in this case, the hire date ? and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that results.</p> 
<p>One last note: You might be tempted to replace the final <code>return</code> statement in the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> with the simpler:</p>","Name","java.util.jar.Attributes.Name","class",FALSE
,"Object Ordering","Comparators - part 5","<h3>Comparators - part 5</h3>
<p>Don't do it unless you're <i>absolutely sure</i> no one will ever have a negative employee number! This trick does not work in general because the signed integer type is not big enough to represent the difference of two arbitrary signed integers. If <code>i</code> is a large positive integer and <code>j</code> is a large negative integer, <code>i - j</code> will overflow and will return a negative integer. The resulting <code> 
  <clt fqn=""java.util.TreeSet.comparator"" api=""TreeSet"" kind=""method"">
   TreeSet.comparator
  </clt></code> violates one of the four technical restrictions we keep talking about (transitivity) and produces horrible, subtle bugs. This is not a purely theoretical concern; people get burned by it.</p>","TreeSet","java.util.TreeSet.comparator","class",FALSE
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code>peek</code>, and <code>element</code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Queue","java.util.Queue","class",FALSE
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code>peek</code>, and <code>element</code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","LinkedList","java.util.LinkedList","class",FALSE
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code>peek</code>, and <code>element</code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","PriorityQueue","java.util.PriorityQueue","class",FALSE
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code>peek</code>, and <code>element</code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Comparator","java.util.Comparator","class",FALSE
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code>peek</code>, and <code>element</code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Collection","java.util.Collection","class",FALSE
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code>peek</code>, and <code>element</code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Arrays","java.util.Arrays","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","Queue","java.awt.Queue","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","BlockingQueue","java.util.concurrent.BlockingQueue","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","LinkedBlockingQueue","java.util.concurrent.LinkedBlockingQueue","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","ArrayBlockingQueue","java.util.concurrent.ArrayBlockingQueue","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","PriorityBlockingQueue","java.util.concurrent.PriorityBlockingQueue","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","DelayQueue","java.util.concurrent.DelayQueue","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","SynchronousQueue","java.util.concurrent.SynchronousQueue","class",FALSE
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","TransferQueue","java.util.concurrent.SynchronousQueue.TransferQueue","class",FALSE
,"Set Implementations","Set Implementations","<div id=""PageTitle""> 
 <h1>Set Implementations</h1> 
</div> 
<p>The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations are grouped into general-purpose and special-purpose implementations.</p>","Set","java.util.Set","class",FALSE
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","Set","java.util.Set","class",FALSE
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","HashSet","java.util.HashSet","class",FALSE
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","LinkedHashSet","java.util.LinkedHashSet","class",FALSE
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"Set Implementations","General-Purpose Set Implementations - part 2","<h3>General-Purpose Set Implementations - part 2</h3>
<p>One thing worth keeping in mind about <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is that iteration is linear in the sum of the number of entries and the number of buckets (the <em>capacity</em>). Thus, choosing an initial capacity that's too high can waste both space and time. On the other hand, choosing an initial capacity that's too low wastes time by copying the data structure each time it's forced to increase its capacity. If you don't specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the <code>int</code> constructor. The following line of code allocates a <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> whose initial capacity is 64.</p>","HashSet","java.util.HashSet","class",FALSE
,"Set Implementations","General-Purpose Set Implementations - part 3","<h3>General-Purpose Set Implementations - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> class has one other tuning parameter called the <em>load factor</em>. If you care a lot about the space consumption of your <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, read the <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do.</p> 
<p>If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> has the same tuning parameters as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, but iteration time is not affected by capacity. <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> has no tuning parameters.</p>","HashSet","java.util.HashSet","class",FALSE
,"Set Implementations","General-Purpose Set Implementations - part 3","<h3>General-Purpose Set Implementations - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> class has one other tuning parameter called the <em>load factor</em>. If you care a lot about the space consumption of your <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, read the <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do.</p> 
<p>If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> has the same tuning parameters as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, but iteration time is not affected by capacity. <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> has no tuning parameters.</p>","LinkedHashSet","java.util.LinkedHashSet","class",FALSE
,"Set Implementations","General-Purpose Set Implementations - part 3","<h3>General-Purpose Set Implementations - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> class has one other tuning parameter called the <em>load factor</em>. If you care a lot about the space consumption of your <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, read the <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do.</p> 
<p>If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> has the same tuning parameters as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, but iteration time is not affected by capacity. <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> has no tuning parameters.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"Set Implementations","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","Set","java.util.Set","class",FALSE
,"Set Implementations","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","EnumSet","java.util.EnumSet","class",FALSE
,"Set Implementations","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","CopyOnWriteArraySet","java.util.concurrent.CopyOnWriteArraySet","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","Set","java.util.Set","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","HashSet","java.util.HashSet","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","Map","java.util.Map","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","HashMap","java.util.HashMap","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","LinkedList","java.util.LinkedList","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","Deque","java.util.Deque","class",FALSE
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>List</code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code>Queue</code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","ArrayDeque","java.util.ArrayDeque","class",FALSE
,"Summary of Implementations","Summary of Implementations - part 2","<h3>Summary of Implementations - part 2</h3>
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class (as opposed to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface), provides static methods that operate on or return collections, which are known as Wrapper implementations.</p> 
<p>Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.</p>","Collections","java.util.Collections","class",FALSE
,"Summary of Implementations","Summary of Implementations - part 2","<h3>Summary of Implementations - part 2</h3>
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class (as opposed to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface), provides static methods that operate on or return collections, which are known as Wrapper implementations.</p> 
<p>Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.</p>","Collection","java.util.Collection","class",FALSE
,"Wrapper Implementations","Wrapper Implementations","<div id=""PageTitle""> 
 <h1>Wrapper Implementations</h1> 
</div> 
<p>Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the <em>decorator</em> pattern. Although it may seem a bit exotic, it's really pretty straightforward.</p> 
<p>These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, which consists solely of static methods.</p>","Collections","java.util.Collections","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p>","Collection","java.util.Collection","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p>","Set","java.util.Set","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p>","Map","java.util.Map","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p>","Vector","java.util.Vector","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers - part 2","<h3>Synchronization Wrappers - part 2</h3>
<p>If an explicit iterator is used, the <code>iterator</code> method must be called from within the <code>synchronized</code> block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view of a synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is similar. It is imperative that the user synchronize on the synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> when iterating over any of its <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views rather than synchronizing on the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view itself, as shown in the following example.</p> 
<p>One minor downside of using wrapper implementations is that you do not have the ability to execute any <em>noninterface</em> operations of a wrapped implementation. So, for instance, in the preceding <code>List</code> example, you cannot call <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ensureCapacity(int)""><code>ensureCapacity</code></a> operation on the wrapped <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>.</p>","Collection","java.util.Collection","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers - part 2","<h3>Synchronization Wrappers - part 2</h3>
<p>If an explicit iterator is used, the <code>iterator</code> method must be called from within the <code>synchronized</code> block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view of a synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is similar. It is imperative that the user synchronize on the synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> when iterating over any of its <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views rather than synchronizing on the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view itself, as shown in the following example.</p> 
<p>One minor downside of using wrapper implementations is that you do not have the ability to execute any <em>noninterface</em> operations of a wrapped implementation. So, for instance, in the preceding <code>List</code> example, you cannot call <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ensureCapacity(int)""><code>ensureCapacity</code></a> operation on the wrapped <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>.</p>","Map","java.util.Map","class",FALSE
,"Wrapper Implementations","Synchronization Wrappers - part 2","<h3>Synchronization Wrappers - part 2</h3>
<p>If an explicit iterator is used, the <code>iterator</code> method must be called from within the <code>synchronized</code> block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view of a synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is similar. It is imperative that the user synchronize on the synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> when iterating over any of its <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views rather than synchronizing on the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view itself, as shown in the following example.</p> 
<p>One minor downside of using wrapper implementations is that you do not have the ability to execute any <em>noninterface</em> operations of a wrapped implementation. So, for instance, in the preceding <code>List</code> example, you cannot call <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ensureCapacity(int)""><code>ensureCapacity</code></a> operation on the wrapped <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"Wrapper Implementations","Unmodifiable Wrappers","<h2>Unmodifiable Wrappers</h2> 
<p>Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code>. Unmodifiable wrappers have two main uses, as follows:</p> 
<ul> 
 <li>To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.</li> 
 <li>To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.</li> 
</ul> 
<p>Like synchronization wrappers, each of the six core <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces has one static factory method.</p>","UnsupportedOperationException","java.lang.UnsupportedOperationException","class",FALSE
,"Wrapper Implementations","Unmodifiable Wrappers","<h2>Unmodifiable Wrappers</h2> 
<p>Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code>. Unmodifiable wrappers have two main uses, as follows:</p> 
<ul> 
 <li>To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.</li> 
 <li>To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.</li> 
</ul> 
<p>Like synchronization wrappers, each of the six core <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces has one static factory method.</p>","Collection","java.util.Collection","class",FALSE
,"Wrapper Implementations","Checked Interface Wrappers","<h2>Checked Interface Wrappers</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.checked 
  </clt></code> <em>interface</em> wrappers are provided for use with generic collections. These implementations return a <em>dynamically</em> type-safe view of the specified collection, which throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.</p>","Collections","java.util.Collections","class",FALSE
,"Wrapper Implementations","Checked Interface Wrappers","<h2>Checked Interface Wrappers</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.checked 
  </clt></code> <em>interface</em> wrappers are provided for use with generic collections. These implementations return a <em>dynamically</em> type-safe view of the specified collection, which throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.</p>","ClassCastException","java.lang.ClassCastException","class",FALSE
