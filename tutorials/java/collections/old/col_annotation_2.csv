,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","Collection","java.util.Collection","class",FALSE
,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","Set","java.util.Set","class",FALSE
,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","SortedSet","java.util.SortedSet","class",FALSE
,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","Deque","java.util.Deque","class",FALSE
,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","Map","java.util.Map","class",FALSE
,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","Hashtable","java.util.Hashtable","class",FALSE
,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","SortedMap","java.util.SortedMap","class",FALSE
,"Summary of Interfaces","Summary of Interfaces","<div id=""PageTitle""> 
 <h1>Summary of Interfaces</h1> 
</div> 
<p>The core collection interfaces are the foundation of the Java Collections Framework.</p> 
<p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p> 
<ul> 
 <li>The first tree starts with the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> interface, which provides for the basic functionality used by all collections, such as <code>add</code> and <code>remove</code> methods. Its subinterfaces ? <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, and <code>Queue</code> ? provide for more specialized collections.</li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The <code> 
    <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
      Set 
    </clt></code> interface has a subinterface, <code> 
    <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
      SortedSet 
    </clt></code>, that provides for ordering of elements in the set.</p></li> 
 <li><p>The <code>List</code> interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a <code>List</code> by their exact position.</p></li> 
 <li><p>The <code>Queue</code> interface enables additional insertion, extraction, and inspection operations. Elements in a <code>Queue</code> are typically ordered in on a FIFO basis.</p></li> 
 <li><p>The <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> interface enables insertion, deletion, and inspection operations at both the ends. Elements in a <code> 
    <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
      Deque 
    </clt></code> can be used in both LIFO and FIFO.</p></li> 
 <li><p>The second tree starts with the <code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code> interface, which maps keys and values similar to a <code> 
    <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
      Hashtable 
    </clt></code>.</p></li> 
 <li><p><code> 
    <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
      Map 
    </clt></code>'s subinterface, <code> 
    <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
      SortedMap 
    </clt></code>, maintains its key-value pairs in ascending order or in an order specified by a <code> 
    <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
      Comparator 
    </clt></code>.</p> </li> 
</ul>","Comparator","java.util.Comparator","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","The Collection Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> represents a group of objects known as its elements. The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface is used to pass around collections of objects where maximum generality is desired. For example, by convention all general-purpose collection implementations have a constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> argument. This constructor, known as a <i>conversion constructor</i>, initializes the new collection to contain all of the elements in the specified collection, whatever the given collection's subinterface or implementation type. In other words, it allows you to <i>convert</i> the collection's type.</p> 
<p>Suppose, for example, that you have a <code>Collection&lt;String&gt; c</code>, which may be a <code>List</code>, a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, or another kind of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. This idiom creates a new <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> (an implementation of the <code>List</code> interface), initially containing all the elements in <code>c</code>.</p> 
<p>The following shows the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","The Collection Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> represents a group of objects known as its elements. The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface is used to pass around collections of objects where maximum generality is desired. For example, by convention all general-purpose collection implementations have a constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> argument. This constructor, known as a <i>conversion constructor</i>, initializes the new collection to contain all of the elements in the specified collection, whatever the given collection's subinterface or implementation type. In other words, it allows you to <i>convert</i> the collection's type.</p> 
<p>Suppose, for example, that you have a <code>Collection&lt;String&gt; c</code>, which may be a <code>List</code>, a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, or another kind of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. This idiom creates a new <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> (an implementation of the <code>List</code> interface), initially containing all the elements in <code>c</code>.</p> 
<p>The following shows the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","The Collection Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> represents a group of objects known as its elements. The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface is used to pass around collections of objects where maximum generality is desired. For example, by convention all general-purpose collection implementations have a constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> argument. This constructor, known as a <i>conversion constructor</i>, initializes the new collection to contain all of the elements in the specified collection, whatever the given collection's subinterface or implementation type. In other words, it allows you to <i>convert</i> the collection's type.</p> 
<p>Suppose, for example, that you have a <code>Collection&lt;String&gt; c</code>, which may be a <code>List</code>, a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, or another kind of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. This idiom creates a new <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> (an implementation of the <code>List</code> interface), initially containing all the elements in <code>c</code>.</p> 
<p>The following shows the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","The Collection Interface - part 2","<h3>The Collection Interface - part 2</h3>
<p>The interface does about what you'd expect given that a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> represents a group of objects. The interface has methods to tell you how many elements are in the collection (<code>size</code>, <code>isEmpty</code>), to check whether a given object is in the collection (<code>contains</code>), to add and remove an element from the collection (<code>add</code>, <code>remove</code>), and to provide an iterator over the collection (<code>iterator</code>).</p> 
<p>The <code>add</code> method is defined generally enough so that it makes sense for collections that allow duplicates as well as those that don't. It guarantees that the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> will contain the specified element after the call completes, and returns <code>true</code> if the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> changes as a result of the call. Similarly, the <code>remove</code> method is designed to remove a single instance of the specified element from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, assuming that it contains the element to start with, and to return <code>true</code> if the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> was modified as a result. </p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Bulk Operations","<h2>Collection Interface Bulk Operations</h2> 
<p><i>Bulk operations</i> perform an operation on an entire <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. You could implement these shorthand operations using the basic operations, though in most cases such implementations would be less efficient. The following are the bulk operations:</p> 
<ul> 
 <li><code>containsAll</code> ? returns <code>true</code> if the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> contains all of the elements in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>addAll</code> ? adds all of the elements in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> to the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>removeAll</code> ? removes from the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> all of its elements that are also contained in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>retainAll</code> ? removes from the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> all its elements that are <i>not</i> also contained in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. That is, it retains only those elements in the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that are also contained in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>clear</code> ? removes all elements from the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
</ul> 
<p>The <code>addAll</code>, <code>removeAll</code>, and <code>retainAll</code> methods all return <code>true</code> if the target <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> was modified in the process of executing the operation.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Bulk Operations - part 2","<h3>Collection Interface Bulk Operations - part 2</h3>
<p>As a simple example of the power of bulk operations, consider the following idiom to remove <i>all</i> instances of a specified element, <code>e</code>, from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>.</p> 
<p>More specifically, suppose you want to remove all of the <code>null</code> elements from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>This idiom uses <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, which is a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> containing only the specified element. </p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Bulk Operations - part 2","<h3>Collection Interface Bulk Operations - part 2</h3>
<p>As a simple example of the power of bulk operations, consider the following idiom to remove <i>all</i> instances of a specified element, <code>e</code>, from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>.</p> 
<p>More specifically, suppose you want to remove all of the <code>null</code> elements from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>This idiom uses <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, which is a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> containing only the specified element. </p>","Collections","java.util.Collections.singleton","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Bulk Operations - part 2","<h3>Collection Interface Bulk Operations - part 2</h3>
<p>As a simple example of the power of bulk operations, consider the following idiom to remove <i>all</i> instances of a specified element, <code>e</code>, from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>.</p> 
<p>More specifically, suppose you want to remove all of the <code>null</code> elements from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>This idiom uses <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, which is a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> containing only the specified element. </p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","Array","java.sql.Array","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","Object","java.lang.Object","class",FALSE
,"The 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","String","java.lang.String","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","The List Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> is an ordered <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> (sometimes called a <i>sequence</i>). Lists may contain duplicate elements. In addition to the operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, the <code>List</code> interface includes operations for the following:</p> 
<ul> 
 <li><code>Positional access</code> ? manipulates elements based on their numerical position in the list</li> 
 <li><code>Search</code> ? searches for a specified object in the list and returns its numerical position</li> 
 <li><code>Iteration</code> ? extends <code>Iterator</code> semantics to take advantage of the list's sequential nature</li> 
 <li><code>Range-view</code> ? performs arbitrary <i>range operations</i> on the list.</li> 
</ul> 
<p>The <code>List</code> interface follows.</p> 
<p>The Java platform contains two general-purpose <code>List</code> implementations. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, which is usually the better-performing implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> which offers better performance under certain circumstances. Also, <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has been retrofitted to implement <code>List</code>.</p>","List","java.util.List","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","The List Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> is an ordered <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> (sometimes called a <i>sequence</i>). Lists may contain duplicate elements. In addition to the operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, the <code>List</code> interface includes operations for the following:</p> 
<ul> 
 <li><code>Positional access</code> ? manipulates elements based on their numerical position in the list</li> 
 <li><code>Search</code> ? searches for a specified object in the list and returns its numerical position</li> 
 <li><code>Iteration</code> ? extends <code>Iterator</code> semantics to take advantage of the list's sequential nature</li> 
 <li><code>Range-view</code> ? performs arbitrary <i>range operations</i> on the list.</li> 
</ul> 
<p>The <code>List</code> interface follows.</p> 
<p>The Java platform contains two general-purpose <code>List</code> implementations. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, which is usually the better-performing implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> which offers better performance under certain circumstances. Also, <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has been retrofitted to implement <code>List</code>.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","The List Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> is an ordered <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> (sometimes called a <i>sequence</i>). Lists may contain duplicate elements. In addition to the operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, the <code>List</code> interface includes operations for the following:</p> 
<ul> 
 <li><code>Positional access</code> ? manipulates elements based on their numerical position in the list</li> 
 <li><code>Search</code> ? searches for a specified object in the list and returns its numerical position</li> 
 <li><code>Iteration</code> ? extends <code>Iterator</code> semantics to take advantage of the list's sequential nature</li> 
 <li><code>Range-view</code> ? performs arbitrary <i>range operations</i> on the list.</li> 
</ul> 
<p>The <code>List</code> interface follows.</p> 
<p>The Java platform contains two general-purpose <code>List</code> implementations. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, which is usually the better-performing implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> which offers better performance under certain circumstances. Also, <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has been retrofitted to implement <code>List</code>.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","The List Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> is an ordered <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> (sometimes called a <i>sequence</i>). Lists may contain duplicate elements. In addition to the operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, the <code>List</code> interface includes operations for the following:</p> 
<ul> 
 <li><code>Positional access</code> ? manipulates elements based on their numerical position in the list</li> 
 <li><code>Search</code> ? searches for a specified object in the list and returns its numerical position</li> 
 <li><code>Iteration</code> ? extends <code>Iterator</code> semantics to take advantage of the list's sequential nature</li> 
 <li><code>Range-view</code> ? performs arbitrary <i>range operations</i> on the list.</li> 
</ul> 
<p>The <code>List</code> interface follows.</p> 
<p>The Java platform contains two general-purpose <code>List</code> implementations. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, which is usually the better-performing implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> which offers better performance under certain circumstances. Also, <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has been retrofitted to implement <code>List</code>.</p>","LinkedList","java.util.LinkedList","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","The List Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a> is an ordered <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> (sometimes called a <i>sequence</i>). Lists may contain duplicate elements. In addition to the operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, the <code>List</code> interface includes operations for the following:</p> 
<ul> 
 <li><code>Positional access</code> ? manipulates elements based on their numerical position in the list</li> 
 <li><code>Search</code> ? searches for a specified object in the list and returns its numerical position</li> 
 <li><code>Iteration</code> ? extends <code>Iterator</code> semantics to take advantage of the list's sequential nature</li> 
 <li><code>Range-view</code> ? performs arbitrary <i>range operations</i> on the list.</li> 
</ul> 
<p>The <code>List</code> interface follows.</p> 
<p>The Java platform contains two general-purpose <code>List</code> implementations. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html""><code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code></a>, which is usually the better-performing implementation, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html""><code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code></a> which offers better performance under certain circumstances. Also, <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has been retrofitted to implement <code>List</code>.</p>","Vector","java.util.Vector","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Comparison to Vector","<h2>Comparison to Vector</h2> 
<p>If you've used <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>, you're already familiar with the general basics of <code>List</code>. (Of course, <code>List</code> is an interface, while <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> is a concrete implementation.) <code>List</code> fixes several minor API deficiencies in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>. Commonly used <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> operations, such as <code> 
  <clt fqn=""java.util.Vector.elementAt"" api=""Vector"" kind=""method"">
   Vector.elementAt
  </clt></code> and <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, have been given much shorter names. When you consider that these two operations are the <code>List</code> analog of square brackets for arrays, it becomes apparent that shorter names are highly desirable. Consider the following assignment statement.</p> 
<p>The <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> equivalent is:</p> 
<p>The <code>List</code> equivalent is:</p> 
<p>You may already have noticed that the <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code> method, which replaces the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> method <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, reverses the order of the arguments so that they match the corresponding array operation. Consider the following assignment statement.</p> 
<p>The <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> equivalent is:</p> 
<p>The <code>List</code> equivalent is:</p> 
<p>For consistency's sake, the method <code> 
  <clt fqn=""java.util.Vector.add"" api=""Vector"" kind=""method"">
   Vector.add(int, E)
  </clt></code>, which replaces <code> 
  <clt fqn=""java.util.Vector.insertElementAt"" api=""Vector"" kind=""method"">
   Vector.insertElementAt(Object, int)
  </clt></code>, also reverses the order of the arguments.</p> 
<p>The three range operations in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> (<code>indexOf</code>, <code>lastIndexOf</code>, and <code> 
  <clt fqn=""java.util.Vector.setSize"" api=""Vector"" kind=""method"">
   Vector.setSize
  </clt></code>) have been replaced by a single range-view operation (<code> 
  <clt fqn=""java.util.Vector.subList"" api=""Vector"" kind=""method"">
   Vector.subList
  </clt></code>), which is far more powerful and consistent.</p>","Vector","java.util.Vector","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Collection Operations","<h2>Collection Operations</h2> 
<p>The operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> all do about what you'd expect them to do, assuming you're already familiar with them. If you're not familiar with them from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, now would be a good time to read <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section. The <code>remove</code> operation always removes <i>the first</i> occurrence of the specified element from the list. The <code>add</code> and <code>addAll</code> operations always append the new element(s) to the <i>end</i> of the list. Thus, the following idiom concatenates one list to another.</p> 
<p>Here's a nondestructive form of this idiom, which produces a third <code>List</code> consisting of the second list appended to the first.</p> 
<p>Note that the idiom, in its nondestructive form, takes advantage of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s standard conversion constructor.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> interface, <code>List</code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code>List</code> objects can be compared for logical equality without regard to their implementation classes. Two <code>List</code> objects are equal if they contain the same elements in the same order.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Collection Operations","<h2>Collection Operations</h2> 
<p>The operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> all do about what you'd expect them to do, assuming you're already familiar with them. If you're not familiar with them from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, now would be a good time to read <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section. The <code>remove</code> operation always removes <i>the first</i> occurrence of the specified element from the list. The <code>add</code> and <code>addAll</code> operations always append the new element(s) to the <i>end</i> of the list. Thus, the following idiom concatenates one list to another.</p> 
<p>Here's a nondestructive form of this idiom, which produces a third <code>List</code> consisting of the second list appended to the first.</p> 
<p>Note that the idiom, in its nondestructive form, takes advantage of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s standard conversion constructor.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> interface, <code>List</code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code>List</code> objects can be compared for logical equality without regard to their implementation classes. Two <code>List</code> objects are equal if they contain the same elements in the same order.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Collection Operations","<h2>Collection Operations</h2> 
<p>The operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> all do about what you'd expect them to do, assuming you're already familiar with them. If you're not familiar with them from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, now would be a good time to read <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section. The <code>remove</code> operation always removes <i>the first</i> occurrence of the specified element from the list. The <code>add</code> and <code>addAll</code> operations always append the new element(s) to the <i>end</i> of the list. Thus, the following idiom concatenates one list to another.</p> 
<p>Here's a nondestructive form of this idiom, which produces a third <code>List</code> consisting of the second list appended to the first.</p> 
<p>Note that the idiom, in its nondestructive form, takes advantage of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s standard conversion constructor.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> interface, <code>List</code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code>List</code> objects can be compared for logical equality without regard to their implementation classes. Two <code>List</code> objects are equal if they contain the same elements in the same order.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Positional Access and Search Operations","<h2>Positional Access and Search Operations</h2> 
<p>The basic <code>positional access</code> operations (<code> 
  <clt fqn=""java.util.Vector.get"" api=""Vector"" kind=""method"">
   Vector.get
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code>, <code>add</code> and <code>remove</code>) behave just like their longer-named counterparts in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> (<code> 
  <clt fqn=""java.util.Vector.elementAt"" api=""Vector"" kind=""method"">
   Vector.elementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.insertElementAt"" api=""Vector"" kind=""method"">
   Vector.insertElementAt
  </clt></code>, and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) with one noteworthy exception: The <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code> and <code>remove</code> operations return the old value that is being overwritten or removed; the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> counterparts (<code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code> and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) return nothing (<code>void</code>). The <code> 
  <clt fqn=""java.util.Stack.search"" api=""Stack"" kind=""method"">
   Stack.search
  </clt></code> operations <code>indexOf</code> and <code>lastIndexOf</code> behave exactly like the identically named operations in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>.</p> 
<p>The <code>addAll</code> operation inserts all the elements of the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> starting at the specified position. The elements are inserted in the order they are returned by the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s iterator. This call is the positional access analog of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s <code>addAll</code> operation.</p> 
<p>Here's a little method to swap two indexed values in a <code>List</code>. It should look familiar from Programming 101.</p>","Vector","java.util.Vector.get","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Positional Access and Search Operations","<h2>Positional Access and Search Operations</h2> 
<p>The basic <code>positional access</code> operations (<code> 
  <clt fqn=""java.util.Vector.get"" api=""Vector"" kind=""method"">
   Vector.get
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code>, <code>add</code> and <code>remove</code>) behave just like their longer-named counterparts in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> (<code> 
  <clt fqn=""java.util.Vector.elementAt"" api=""Vector"" kind=""method"">
   Vector.elementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.insertElementAt"" api=""Vector"" kind=""method"">
   Vector.insertElementAt
  </clt></code>, and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) with one noteworthy exception: The <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code> and <code>remove</code> operations return the old value that is being overwritten or removed; the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> counterparts (<code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code> and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) return nothing (<code>void</code>). The <code> 
  <clt fqn=""java.util.Stack.search"" api=""Stack"" kind=""method"">
   Stack.search
  </clt></code> operations <code>indexOf</code> and <code>lastIndexOf</code> behave exactly like the identically named operations in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>.</p> 
<p>The <code>addAll</code> operation inserts all the elements of the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> starting at the specified position. The elements are inserted in the order they are returned by the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s iterator. This call is the positional access analog of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s <code>addAll</code> operation.</p> 
<p>Here's a little method to swap two indexed values in a <code>List</code>. It should look familiar from Programming 101.</p>","Stack","java.util.Stack.search","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Positional Access and Search Operations","<h2>Positional Access and Search Operations</h2> 
<p>The basic <code>positional access</code> operations (<code> 
  <clt fqn=""java.util.Vector.get"" api=""Vector"" kind=""method"">
   Vector.get
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code>, <code>add</code> and <code>remove</code>) behave just like their longer-named counterparts in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> (<code> 
  <clt fqn=""java.util.Vector.elementAt"" api=""Vector"" kind=""method"">
   Vector.elementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.insertElementAt"" api=""Vector"" kind=""method"">
   Vector.insertElementAt
  </clt></code>, and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) with one noteworthy exception: The <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code> and <code>remove</code> operations return the old value that is being overwritten or removed; the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> counterparts (<code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code> and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) return nothing (<code>void</code>). The <code> 
  <clt fqn=""java.util.Stack.search"" api=""Stack"" kind=""method"">
   Stack.search
  </clt></code> operations <code>indexOf</code> and <code>lastIndexOf</code> behave exactly like the identically named operations in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>.</p> 
<p>The <code>addAll</code> operation inserts all the elements of the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> starting at the specified position. The elements are inserted in the order they are returned by the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s iterator. This call is the positional access analog of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s <code>addAll</code> operation.</p> 
<p>Here's a little method to swap two indexed values in a <code>List</code>. It should look familiar from Programming 101.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Positional Access and Search Operations - part 2","<h3>Positional Access and Search Operations - part 2</h3>
<p><a name=""shuffle"" id=""shuffle"">Of course, there's one big difference.</a> This is a polymorphic algorithm: It swaps two elements in any <code>List</code>, regardless of its implementation type. Here's another polymorphic algorithm that uses the preceding <code> 
  <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
   Collections.swap
  </clt></code> method.</p> 
<p>This algorithm, which is included in the Java platform's <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, randomly permutes the specified list using the specified source of randomness. It's a bit subtle: It runs up the list from the bottom, repeatedly swapping a randomly selected element into the current position. Unlike most naive attempts at shuffling, it's <i>fair</i> (all permutations occur with equal likelihood, assuming an unbiased source of randomness) and <i>fast</i> (requiring exactly <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()-1
  </clt></code> swaps). The following program uses this algorithm to print the words in its argument list in random order.</p>","Collections","java.util.Collections.swap","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Positional Access and Search Operations - part 2","<h3>Positional Access and Search Operations - part 2</h3>
<p><a name=""shuffle"" id=""shuffle"">Of course, there's one big difference.</a> This is a polymorphic algorithm: It swaps two elements in any <code>List</code>, regardless of its implementation type. Here's another polymorphic algorithm that uses the preceding <code> 
  <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
   Collections.swap
  </clt></code> method.</p> 
<p>This algorithm, which is included in the Java platform's <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, randomly permutes the specified list using the specified source of randomness. It's a bit subtle: It runs up the list from the bottom, repeatedly swapping a randomly selected element into the current position. Unlike most naive attempts at shuffling, it's <i>fair</i> (all permutations occur with equal likelihood, assuming an unbiased source of randomness) and <i>fast</i> (requiring exactly <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()-1
  </clt></code> swaps). The following program uses this algorithm to print the words in its argument list in random order.</p>","List","java.util.List.size","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Positional Access and Search Operations - part 3","<h3>Positional Access and Search Operations - part 3</h3>
<p>In fact, this program can be made even shorter and faster. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html""><code> 
   <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
     Arrays 
   </clt></code></a> class has a static factory method called <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code>, which allows an array to be viewed as a <code>List</code>. This method does not copy the array. Changes in the <code>List</code> write through to the array and vice versa. The resulting List is not a general-purpose <code>List</code> implementation, because it doesn't implement the (optional) <code>add</code> and <code>remove</code> operations: Arrays are not resizable. Taking advantage of <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> and calling the library version of <code>shuffle</code>, which uses a default source of randomness, you get the following <a class=""SourceLink"" target=""_blank"" href=""examples/Shuffle.java"" onclick=""showCode('../../displayCode.html', 'examples/Shuffle.java'); return false;""><code>tiny program</code></a> whose behavior is identical to the previous program.</p>","Arrays","java.util.Arrays","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators","<h2><a name=""Iterator"" id=""Iterator"">Iterators</a></h2> 
<p>As you'd expect, the <code>Iterator</code> returned by <code>List</code>'s <code>iterator</code> operation returns the elements of the list in proper sequence. <code>List</code> also provides a richer iterator, called a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, which allows you to traverse the list in either direction, modify the list during iteration, and obtain the current position of the iterator. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface follows.</p> 
<p>The three methods that <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> inherits from <code>Iterator</code> (<code> 
  <clt fqn=""java.util.ListIterator.hasNext"" api=""ListIterator"" kind=""method"">
   ListIterator.hasNext
  </clt></code>, <code>next</code>, and <code>remove</code>) do exactly the same thing in both interfaces. The <code> 
  <clt fqn=""java.util.ListIterator.hasPrevious"" api=""ListIterator"" kind=""method"">
   ListIterator.hasPrevious
  </clt></code> and the <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> operations are exact analogues of <code> 
  <clt fqn=""java.util.ListIterator.hasNext"" api=""ListIterator"" kind=""method"">
   ListIterator.hasNext
  </clt></code> and <code>next</code>. The former operations refer to the element before the (implicit) cursor, whereas the latter refer to the element after the cursor. The <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> operation moves the cursor backward, whereas <code>next</code> moves it forward.</p> 
<p>Here's the standard idiom for iterating backward through a list.</p>","ListIterator","java.util.ListIterator","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 2","<h3>Iterators - part 2</h3>
<p>Note the argument to <code>listIterator</code> in the preceding idiom. The <code>List</code> interface has two forms of the <code>listIterator</code> method. The form with no arguments returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the beginning of the list; the form with an <code>int</code> argument returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the specified index. The index refers to the element that would be returned by an initial call to <code>next</code>. An initial call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> would return the element whose index was <code>index-1</code>. In a list of length <code>n</code>, there are <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid values for <code>index</code>, from <code>0</code> to <code>n</code>, inclusive.</p> 
<p>Intuitively speaking, the cursor is always between two elements ? the one that would be returned by a call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> and the one that would be returned by a call to <code>next</code>. The <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid <code>index</code> values correspond to the <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> gaps between elements, from the gap before the first element to the gap after the last one. <span id=""figure:colls-fivePossibleCursor.gif"">The following figure</span> shows the five possible cursor positions in a list containing four elements.</p>","ListIterator","java.util.ListIterator","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 2","<h3>Iterators - part 2</h3>
<p>Note the argument to <code>listIterator</code> in the preceding idiom. The <code>List</code> interface has two forms of the <code>listIterator</code> method. The form with no arguments returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the beginning of the list; the form with an <code>int</code> argument returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the specified index. The index refers to the element that would be returned by an initial call to <code>next</code>. An initial call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> would return the element whose index was <code>index-1</code>. In a list of length <code>n</code>, there are <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid values for <code>index</code>, from <code>0</code> to <code>n</code>, inclusive.</p> 
<p>Intuitively speaking, the cursor is always between two elements ? the one that would be returned by a call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> and the one that would be returned by a call to <code>next</code>. The <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid <code>index</code> values correspond to the <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> gaps between elements, from the gap before the first element to the gap after the last one. <span id=""figure:colls-fivePossibleCursor.gif"">The following figure</span> shows the five possible cursor positions in a list containing four elements.</p>","CopiesList","java.util.Collections.CopiesList.n","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 3","<h3>Iterators - part 3</h3>
<center> 
 <p class=""FigureCaption"">The five possible cursor positions.</p> 
</center> 
<p>Calls to <code>next</code> and <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> can be intermixed, but you have to be a bit careful. The first call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> returns the same element as the last call to <code>next</code>. Similarly, the first call to <code>next</code> after a sequence of calls to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> returns the same element as the last call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>.</p> 
<p>It should come as no surprise that the <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> method returns the index of the element that would be returned by a subsequent call to <code>next</code>, and <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code> returns the index of the element that would be returned by a subsequent call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. These calls are typically used either to report the position where something was found or to record the position of the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> so that another <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> with identical position can be created.</p>","ListIterator","java.util.ListIterator.previous","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 4","<h3>Iterators - part 4</h3>
<p>It should also come as no surprise that the number returned by <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> is always one greater than the number returned by <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code>. This implies the behavior of the two boundary cases: (1) a call to <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code> when the cursor is before the initial element returns <code>-1</code> and (2) a call to <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> when the cursor is after the final element returns <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()
  </clt></code>. To make all this concrete, the following is a possible implementation of <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.List.indexOf
  </clt></code>.</p> 
<p>Note that the <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.indexOf
  </clt></code> method returns <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.previousIndex()
  </clt></code> even though it is traversing the list in the forward direction. The reason is that <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.nextIndex()
  </clt></code> would return the index of the element we are about to examine, and we want to return the index of the element we just examined.</p>","ListIterator","java.util.ListIterator.nextIndex","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 4","<h3>Iterators - part 4</h3>
<p>It should also come as no surprise that the number returned by <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> is always one greater than the number returned by <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code>. This implies the behavior of the two boundary cases: (1) a call to <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code> when the cursor is before the initial element returns <code>-1</code> and (2) a call to <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> when the cursor is after the final element returns <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()
  </clt></code>. To make all this concrete, the following is a possible implementation of <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.List.indexOf
  </clt></code>.</p> 
<p>Note that the <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.indexOf
  </clt></code> method returns <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.previousIndex()
  </clt></code> even though it is traversing the list in the forward direction. The reason is that <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.nextIndex()
  </clt></code> would return the index of the element we are about to examine, and we want to return the index of the element we just examined.</p>","List","java.util.List.size","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 5","<h3>Iterators - part 5</h3>
<p>The <code>Iterator</code> interface provides the <code>remove</code> operation to remove the last element returned by <code>next</code> from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. For <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, this operation removes the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface provides two additional operations to modify the list ? <code>set</code> and <code>add</code>. The <code>set</code> method overwrites the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> with the specified element. The following polymorphic algorithm uses <code>set</code> to replace all occurrences of one specified value with another.</p> 
<p>The only bit of trickiness in this example is the equality test between <code>val</code> and <code>it.next</code>. You need to special-case a <code>val</code> value of <code>null</code> to prevent a <code> 
  <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
    NullPointerException 
  </clt></code>.</p> 
<p>The <code>add</code> method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 5","<h3>Iterators - part 5</h3>
<p>The <code>Iterator</code> interface provides the <code>remove</code> operation to remove the last element returned by <code>next</code> from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. For <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, this operation removes the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface provides two additional operations to modify the list ? <code>set</code> and <code>add</code>. The <code>set</code> method overwrites the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> with the specified element. The following polymorphic algorithm uses <code>set</code> to replace all occurrences of one specified value with another.</p> 
<p>The only bit of trickiness in this example is the equality test between <code>val</code> and <code>it.next</code>. You need to special-case a <code>val</code> value of <code>null</code> to prevent a <code> 
  <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
    NullPointerException 
  </clt></code>.</p> 
<p>The <code>add</code> method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list.</p>","ListIterator","java.util.ListIterator","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Iterators - part 5","<h3>Iterators - part 5</h3>
<p>The <code>Iterator</code> interface provides the <code>remove</code> operation to remove the last element returned by <code>next</code> from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. For <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, this operation removes the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface provides two additional operations to modify the list ? <code>set</code> and <code>add</code>. The <code>set</code> method overwrites the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> with the specified element. The following polymorphic algorithm uses <code>set</code> to replace all occurrences of one specified value with another.</p> 
<p>The only bit of trickiness in this example is the equality test between <code>val</code> and <code>it.next</code>. You need to special-case a <code>val</code> value of <code>null</code> to prevent a <code> 
  <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
    NullPointerException 
  </clt></code>.</p> 
<p>The <code>add</code> method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list.</p>","NullPointerException","java.lang.NullPointerException","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Range-View Operation - part 2","<h3>Range-View Operation - part 2</h3>
<p>Any polymorphic algorithm that operates on a <code>List</code>, such as the <code>replace</code> and <code>shuffle</code> examples, works with the <code>List</code> returned by <code>subList</code>.</p> 
<p>Here's a polymorphic algorithm whose implementation uses <code>subList</code> to deal a hand from a deck. That is, it returns a new <code>List</code> (the &quot;hand&quot;) containing the specified number of elements taken from the end of the specified <code>List</code> (the &quot;deck&quot;). The elements returned in the hand are removed from the deck.</p> 
<p>Note that this algorithm removes the hand from the <i>end</i> of the deck. For many common <code>List</code> implementations, such as <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, the performance of removing elements from the end of the list is substantially better than that of removing elements from the beginning.</p> 
<p>The following is <a class=""SourceLink"" target=""_blank"" href=""examples/Deal.java"" onclick=""showCode('../../displayCode.html', 'examples/Deal.java'); return false;""><code>a program</code></a> that uses the <code>dealHand</code> method in combination with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.shuffle 
  </clt></code> to generate hands from a normal 52-card deck. The program takes two command-line arguments: (1) the number of hands to deal and (2) the number of cards in each hand.</p>","ArrayList","java.util.ArrayList","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Range-View Operation - part 2","<h3>Range-View Operation - part 2</h3>
<p>Any polymorphic algorithm that operates on a <code>List</code>, such as the <code>replace</code> and <code>shuffle</code> examples, works with the <code>List</code> returned by <code>subList</code>.</p> 
<p>Here's a polymorphic algorithm whose implementation uses <code>subList</code> to deal a hand from a deck. That is, it returns a new <code>List</code> (the &quot;hand&quot;) containing the specified number of elements taken from the end of the specified <code>List</code> (the &quot;deck&quot;). The elements returned in the hand are removed from the deck.</p> 
<p>Note that this algorithm removes the hand from the <i>end</i> of the deck. For many common <code>List</code> implementations, such as <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, the performance of removing elements from the end of the list is substantially better than that of removing elements from the beginning.</p> 
<p>The following is <a class=""SourceLink"" target=""_blank"" href=""examples/Deal.java"" onclick=""showCode('../../displayCode.html', 'examples/Deal.java'); return false;""><code>a program</code></a> that uses the <code>dealHand</code> method in combination with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.shuffle 
  </clt></code> to generate hands from a normal 52-card deck. The program takes two command-line arguments: (1) the number of hands to deal and (2) the number of cards in each hand.</p>","Collections","java.util.Collections","class",FALSE
,"The 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","List Algorithms","<h2>List Algorithms</h2> 
<p>Most polymorphic algorithms in the <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class apply specifically to <code>List</code>. Having all these algorithms at your disposal makes it very easy to manipulate lists. Here's a summary of these algorithms, which are described in more detail in the <a class=""TutorialLink"" target=""_top"" href=""../algorithms/index.html"">Algorithms</a> section.</p> 
<ul> 
 <li><code>sort</code> ? sorts a <code>List</code> using a merge sort algorithm, which provides a fast, stable sort. (A <i>stable sort</i> is one that does not reorder equal elements.)</li> 
 <li><code>shuffle</code> ? randomly permutes the elements in a <code>List</code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code>List</code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.rotate"" api=""Collections"" kind=""method"">
    Collections.rotate
   </clt></code> ? rotates all the elements in a <code>List</code> by a specified distance.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at specified positions in a <code>List</code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.replaceAll"" api=""Collections"" kind=""method"">
    Collections.replaceAll
   </clt></code> ? replaces all occurrences of one specified value with another.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code>List</code> with the specified value.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? copies the source <code>List</code> into the destination <code>List</code>.</li> 
 <li><code>binarySearch</code> ? searches for an element in an ordered <code>List</code> using the binary search algorithm.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.indexOfSubList"" api=""Collections"" kind=""method"">
    Collections.indexOfSubList
   </clt></code> ? returns the index of the first sublist of one <code>List</code> that is equal to another.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.lastIndexOfSubList"" api=""Collections"" kind=""method"">
    Collections.lastIndexOfSubList
   </clt></code> ? returns the index of the last sublist of one <code>List</code> that is equal to another.</li> 
</ul>","Collections","java.util.Collections","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","HashMap","java.util.HashMap","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","TreeMap","java.util.TreeMap","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","LinkedHashMap","java.util.LinkedHashMap","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","HashSet","java.util.HashSet","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","LinkedHashSet","java.util.LinkedHashSet","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","The Map Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <i>function</i> abstraction. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface follows.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. Their behavior and performance are precisely analogous to <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>, as described in <a class=""TutorialLink"" target=""_top"" href=""set.html"">The Set Interface</a> section. Also, <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Comparison to Hashtable","<h2>Comparison to Hashtable</h2> 
<p>If you've used <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you're already familiar with the general basics of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. (Of course, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is an interface, while <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is a concrete implementation.) The following are the major differences:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views instead of direct support for iteration via <code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code> objects. <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views greatly enhance the expressiveness of the interface, as discussed later in this section.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> allows you to iterate over keys, values, or key-value pairs; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> does not provide the third option.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides a safe way to remove entries in the midst of iteration; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> did not.</li> 
</ul> 
<p>Finally, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> fixes a minor deficiency in the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> interface. <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> has a method called <code>contains</code>, which returns <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contains a given <i>value</i>. Given its name, you'd expect this method to return <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contained a given <i>key</i>, because the key is the primary access mechanism for a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface eliminates this source of confusion by renaming the method <code>containsValue</code>. Also, this improves the interface's consistency ? <code>containsValue</code> parallels <code>containsKey</code>.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Comparison to Hashtable","<h2>Comparison to Hashtable</h2> 
<p>If you've used <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you're already familiar with the general basics of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. (Of course, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is an interface, while <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is a concrete implementation.) The following are the major differences:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views instead of direct support for iteration via <code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code> objects. <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views greatly enhance the expressiveness of the interface, as discussed later in this section.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> allows you to iterate over keys, values, or key-value pairs; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> does not provide the third option.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides a safe way to remove entries in the midst of iteration; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> did not.</li> 
</ul> 
<p>Finally, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> fixes a minor deficiency in the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> interface. <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> has a method called <code>contains</code>, which returns <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contains a given <i>value</i>. Given its name, you'd expect this method to return <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contained a given <i>key</i>, because the key is the primary access mechanism for a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface eliminates this source of confusion by renaming the method <code>containsValue</code>. Also, this improves the interface's consistency ? <code>containsValue</code> parallels <code>containsKey</code>.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Comparison to Hashtable","<h2>Comparison to Hashtable</h2> 
<p>If you've used <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you're already familiar with the general basics of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. (Of course, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is an interface, while <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is a concrete implementation.) The following are the major differences:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views instead of direct support for iteration via <code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code> objects. <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views greatly enhance the expressiveness of the interface, as discussed later in this section.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> allows you to iterate over keys, values, or key-value pairs; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> does not provide the third option.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides a safe way to remove entries in the midst of iteration; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> did not.</li> 
</ul> 
<p>Finally, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> fixes a minor deficiency in the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> interface. <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> has a method called <code>contains</code>, which returns <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contains a given <i>value</i>. Given its name, you'd expect this method to return <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contained a given <i>key</i>, because the key is the primary access mechanism for a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface eliminates this source of confusion by renaming the method <code>containsValue</code>. Also, this improves the interface's consistency ? <code>containsValue</code> parallels <code>containsKey</code>.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Comparison to Hashtable","<h2>Comparison to Hashtable</h2> 
<p>If you've used <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you're already familiar with the general basics of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. (Of course, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is an interface, while <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is a concrete implementation.) The following are the major differences:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views instead of direct support for iteration via <code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code> objects. <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views greatly enhance the expressiveness of the interface, as discussed later in this section.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> allows you to iterate over keys, values, or key-value pairs; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> does not provide the third option.</li> 
 <li><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> provides a safe way to remove entries in the midst of iteration; <code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code> did not.</li> 
</ul> 
<p>Finally, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> fixes a minor deficiency in the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> interface. <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> has a method called <code>contains</code>, which returns <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contains a given <i>value</i>. Given its name, you'd expect this method to return <code>true</code> if the <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> contained a given <i>key</i>, because the key is the primary access mechanism for a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface eliminates this source of confusion by renaming the method <code>containsValue</code>. Also, this improves the interface's consistency ? <code>containsValue</code> parallels <code>containsKey</code>.</p>","Enumeration","java.util.Enumeration","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","HashMap","java.util.HashMap","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","TreeMap","java.util.TreeMap","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","LinkedHashMap","java.util.LinkedHashMap","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","HashMap","java.util.HashMap","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Bulk Operations","<h2>Map Interface Bulk Operations</h2> 
<p>The <code>clear</code> operation does exactly what you would think it could do: It removes all the mappings from the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analogue of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface's <code> 
  <clt fqn=""java.util.Collection.addAll"" api=""Collection"" kind=""method"">
   Collection.addAll
  </clt></code> operation. In addition to its obvious use of dumping one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> into another, it has a second, more subtle use. Suppose a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is used to represent a collection of attribute-value pairs; the <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation, in combination with the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Interface Bulk Operations","<h2>Map Interface Bulk Operations</h2> 
<p>The <code>clear</code> operation does exactly what you would think it could do: It removes all the mappings from the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analogue of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface's <code> 
  <clt fqn=""java.util.Collection.addAll"" api=""Collection"" kind=""method"">
   Collection.addAll
  </clt></code> operation. In addition to its obvious use of dumping one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> into another, it has a second, more subtle use. Suppose a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is used to represent a collection of attribute-value pairs; the <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation, in combination with the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Entry","java.io.ExpiringCache.Entry","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Entry","java.io.ExpiringCache.Entry","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Iterator","java.util.Iterator.remove","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views - part 3","<h3>Collection Views - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views <i>do not</i> support element addition under any circumstances. It would make no sense for the <code> 
  <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
   Map.keySet
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
   Map.values
  </clt></code> views, and it's unnecessary for the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, because the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Map.put"" api=""Map"" kind=""method"">
   Map.put
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> methods provide the same functionality.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Collection Views - part 3","<h3>Collection Views - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views <i>do not</i> support element addition under any circumstances. It would make no sense for the <code> 
  <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
   Map.keySet
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
   Map.values
  </clt></code> views, and it's unnecessary for the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, because the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Map.put"" api=""Map"" kind=""method"">
   Map.put
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> methods provide the same functionality.</p>","Map","java.util.Map.keySet","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Fancy Uses of Collection Views: Map Algebra","<h2>Fancy Uses of 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Views: 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Algebra</h2> 
<p>When applied to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, bulk operations (<code>containsAll</code>, <code>removeAll</code>, and <code>retainAll</code>) are surprisingly potent tools. For starters, suppose you want to know whether one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is a submap of another ? that is, whether the first <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> contains all the key-value mappings in the second. The following idiom does the trick.</p> 
<p>Along similar lines, suppose you want to know whether two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects contain mappings for all of the same keys.</p> 
<p>Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that represents a collection of attribute-value pairs, and two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.</p> 
<p>Suppose you want to know all the keys common to two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Fancy Uses of Collection Views: Map Algebra","<h2>Fancy Uses of 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Views: 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Algebra</h2> 
<p>When applied to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, bulk operations (<code>containsAll</code>, <code>removeAll</code>, and <code>retainAll</code>) are surprisingly potent tools. For starters, suppose you want to know whether one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is a submap of another ? that is, whether the first <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> contains all the key-value mappings in the second. The following idiom does the trick.</p> 
<p>Along similar lines, suppose you want to know whether two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects contain mappings for all of the same keys.</p> 
<p>Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that represents a collection of attribute-value pairs, and two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.</p> 
<p>Suppose you want to know all the keys common to two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Fancy Uses of Collection Views: Map Algebra","<h2>Fancy Uses of 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Views: 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Algebra</h2> 
<p>When applied to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, bulk operations (<code>containsAll</code>, <code>removeAll</code>, and <code>retainAll</code>) are surprisingly potent tools. For starters, suppose you want to know whether one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is a submap of another ? that is, whether the first <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> contains all the key-value mappings in the second. The following idiom does the trick.</p> 
<p>Along similar lines, suppose you want to know whether two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects contain mappings for all of the same keys.</p> 
<p>Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that represents a collection of attribute-value pairs, and two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.</p> 
<p>Suppose you want to know all the keys common to two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Fancy Uses of Collection Views: Map Algebra - part 2","<h3>Fancy Uses of Collection Views: Map Algebra - part 2</h3>
<p>A similar idiom gets you the common values.</p> 
<p>All the idioms presented thus far have been nondestructive; that is, they don't modify the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Here are a few that do. Suppose you want to remove all of the key-value pairs that one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has in common with another.</p> 
<p>Suppose you want to remove from one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> all of the keys that have mappings in another.</p> 
<p>What happens when you start mixing keys and values in the same bulk operation? Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, <code>managers</code>, that maps each employee in a company to the employee's manager. We'll be deliberately vague about the types of the key and the value objects. It doesn't matter, as long as they're the same. Now suppose you want to know who all the &quot;individual contributors&quot; (or nonmanagers) are. The following snippet tells you exactly what you want to know.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Fancy Uses of Collection Views: Map Algebra - part 3","<h3>Fancy Uses of Collection Views: Map Algebra - part 3</h3>
<p>Suppose you want to fire all the employees who report directly to some manager, Simon.</p> 
<p>Note that this idiom makes use of <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> with the single, specified element.</p> 
<p>Once you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.</p> 
<p>This example is a bit tricky. First, it makes a temporary copy of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and it removes from the temporary copy all entries whose (manager) value is a key in the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Remember that the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has an entry for each employee. Thus, the remaining entries in the temporary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> comprise all the entries from the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.</p>","Collections","java.util.Collections.singleton","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Fancy Uses of Collection Views: Map Algebra - part 3","<h3>Fancy Uses of Collection Views: Map Algebra - part 3</h3>
<p>Suppose you want to fire all the employees who report directly to some manager, Simon.</p> 
<p>Note that this idiom makes use of <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> with the single, specified element.</p> 
<p>Once you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.</p> 
<p>This example is a bit tricky. First, it makes a temporary copy of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and it removes from the temporary copy all entries whose (manager) value is a key in the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Remember that the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has an entry for each employee. Thus, the remaining entries in the temporary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> comprise all the entries from the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Fancy Uses of Collection Views: Map Algebra - part 3","<h3>Fancy Uses of Collection Views: Map Algebra - part 3</h3>
<p>Suppose you want to fire all the employees who report directly to some manager, Simon.</p> 
<p>Note that this idiom makes use of <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> with the single, specified element.</p> 
<p>Once you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.</p> 
<p>This example is a bit tricky. First, it makes a temporary copy of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and it removes from the temporary copy all entries whose (manager) value is a key in the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Remember that the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has an entry for each employee. Thus, the remaining entries in the temporary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> comprise all the entries from the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Multimaps","<h2>Multimaps</h2> 
<p>A <i>multimap</i> is like a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> but it can map each key to multiple values. The Java Collections Framework doesn't include an interface for multimaps because they aren't used all that commonly. It's a fairly simple matter to use a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose values are <code>List</code> instances as a multimap. This technique is demonstrated in the next code example, which reads a word list containing one word per line (all lowercase) and prints out all the anagram groups that meet a size criterion. An <i>anagram group</i> is a bunch of words, all of which contain exactly the same letters but in a different order. The program takes two arguments on the command line: (1) the name of the dictionary file and (2) the minimum size of anagram group to print out. Anagram groups containing fewer words than the specified minimum are not printed.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html""><code>Queue</code></a> is a collection for holding elements prior to processing. Besides basic <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> operations, queues provide additional insertion, removal, and inspection operations. The <code>Queue</code> interface follows.</p> 
<p>Each <code>Queue</code> method exists in two forms: (1) one throws an exception if the operation fails, and (2) the other returns a special value if the operation fails (either <code>null</code> or <code>false</code>, depending on the operation). The regular structure of the interface is illustrated in <span id=""table:queue-structure"">the following table</span>.</p> 
<table summary=""queue-structure"" border=""1""> 
 <caption id=""queue-structure""> 
  <strong>Queue Interface Structure</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Type of Operation</th> 
   <th id=""h2"">Throws exception</th> 
   <th id=""h3"">Returns special value</th> 
  </tr> 
  <tr> 
   <td headers=""h1"">Insert</td> 
   <td headers=""h2""><code>add(e)</code></td> 
   <td headers=""h3""><code>offer(e)</code></td> 
  </tr> 
  <tr> 
   <td headers=""h1"">Remove</td> 
   <td headers=""h2""><code>remove()</code></td> 
   <td headers=""h3""><code>poll()</code></td> 
  </tr> 
  <tr> 
   <td headers=""h1"">Examine</td> 
   <td headers=""h2""><code>element()</code></td> 
   <td headers=""h3""><code>peek()</code></td> 
  </tr> 
 </tbody> 
</table>","Queue","java.util.Queue","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html""><code>Queue</code></a> is a collection for holding elements prior to processing. Besides basic <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> operations, queues provide additional insertion, removal, and inspection operations. The <code>Queue</code> interface follows.</p> 
<p>Each <code>Queue</code> method exists in two forms: (1) one throws an exception if the operation fails, and (2) the other returns a special value if the operation fails (either <code>null</code> or <code>false</code>, depending on the operation). The regular structure of the interface is illustrated in <span id=""table:queue-structure"">the following table</span>.</p> 
<table summary=""queue-structure"" border=""1""> 
 <caption id=""queue-structure""> 
  <strong>Queue Interface Structure</strong> 
 </caption> 
 <tbody> 
  <tr> 
   <th id=""h1"">Type of Operation</th> 
   <th id=""h2"">Throws exception</th> 
   <th id=""h3"">Returns special value</th> 
  </tr> 
  <tr> 
   <td headers=""h1"">Insert</td> 
   <td headers=""h2""><code>add(e)</code></td> 
   <td headers=""h3""><code>offer(e)</code></td> 
  </tr> 
  <tr> 
   <td headers=""h1"">Remove</td> 
   <td headers=""h2""><code>remove()</code></td> 
   <td headers=""h3""><code>poll()</code></td> 
  </tr> 
  <tr> 
   <td headers=""h1"">Examine</td> 
   <td headers=""h2""><code>element()</code></td> 
   <td headers=""h3""><code>peek()</code></td> 
  </tr> 
 </tbody> 
</table>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface - part 2","<h3>The Queue Interface - part 2</h3>
<p>Queues typically, but not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to their values ? see the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section for details). Whatever ordering is used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code>poll</code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties.</p> 
<p>It is possible for a <code>Queue</code> implementation to restrict the number of elements that it holds; such queues are known as <i>bounded</i>. Some <code>Queue</code> implementations in <code>java.util.concurrent</code> are bounded, but the implementations in <code>java.util</code> are not.</p> 
<p>The <code>add</code> method, which <code>Queue</code> inherits from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, inserts an element unless it would violate the queue's capacity restrictions, in which case it throws <code> 
  <clt fqn=""java.lang.IllegalStateException"" api=""IllegalStateException"" kind=""class"">
    IllegalStateException 
  </clt></code>. The <code>offer</code> method, which is intended solely for use on bounded queues, differs from <code>add</code> only in that it indicates failure to insert an element by returning <code>false</code>.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface - part 2","<h3>The Queue Interface - part 2</h3>
<p>Queues typically, but not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to their values ? see the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section for details). Whatever ordering is used, the head of the queue is the element that would be removed by a call to <code>remove</code> or <code>poll</code>. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every <code>Queue</code> implementation must specify its ordering properties.</p> 
<p>It is possible for a <code>Queue</code> implementation to restrict the number of elements that it holds; such queues are known as <i>bounded</i>. Some <code>Queue</code> implementations in <code>java.util.concurrent</code> are bounded, but the implementations in <code>java.util</code> are not.</p> 
<p>The <code>add</code> method, which <code>Queue</code> inherits from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, inserts an element unless it would violate the queue's capacity restrictions, in which case it throws <code> 
  <clt fqn=""java.lang.IllegalStateException"" api=""IllegalStateException"" kind=""class"">
    IllegalStateException 
  </clt></code>. The <code>offer</code> method, which is intended solely for use on bounded queues, differs from <code>add</code> only in that it indicates failure to insert an element by returning <code>false</code>.</p>","IllegalStateException","java.lang.IllegalStateException","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface - part 3","<h3>The Queue Interface - part 3</h3>
<p>The <code>remove</code> and <code>poll</code> methods both remove and return the head of the queue. Exactly which element gets removed is a function of the queue's ordering policy. The <code>remove</code> and <code>poll</code> methods differ in their behavior only when the queue is empty. Under these circumstances, <code>remove</code> throws <code> 
  <clt fqn=""java.util.NoSuchElementException"" api=""NoSuchElementException"" kind=""class"">
    NoSuchElementException 
  </clt></code>, while <code>poll</code> returns <code>null</code>.</p> 
<p>The <code>element</code> and <code>peek</code> methods return, but do not remove, the head of the queue. They differ from one another in precisely the same fashion as <code>remove</code> and <code>poll</code>: If the queue is empty, <code>element</code> throws <code> 
  <clt fqn=""java.util.NoSuchElementException"" api=""NoSuchElementException"" kind=""class"">
    NoSuchElementException 
  </clt></code>, while <code>peek</code> returns <code>null</code>.</p> 
<p><code>Queue</code> implementations generally do not allow insertion of <code>null</code> elements. The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation, which was retrofitted to implement <code>Queue</code>, is an exception. For historical reasons, it permits <code>null</code> elements, but you should refrain from taking advantage of this, because <code>null</code> is used as a special return value by the <code>poll</code> and <code>peek</code> methods.</p>","NoSuchElementException","java.util.NoSuchElementException","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface - part 3","<h3>The Queue Interface - part 3</h3>
<p>The <code>remove</code> and <code>poll</code> methods both remove and return the head of the queue. Exactly which element gets removed is a function of the queue's ordering policy. The <code>remove</code> and <code>poll</code> methods differ in their behavior only when the queue is empty. Under these circumstances, <code>remove</code> throws <code> 
  <clt fqn=""java.util.NoSuchElementException"" api=""NoSuchElementException"" kind=""class"">
    NoSuchElementException 
  </clt></code>, while <code>poll</code> returns <code>null</code>.</p> 
<p>The <code>element</code> and <code>peek</code> methods return, but do not remove, the head of the queue. They differ from one another in precisely the same fashion as <code>remove</code> and <code>poll</code>: If the queue is empty, <code>element</code> throws <code> 
  <clt fqn=""java.util.NoSuchElementException"" api=""NoSuchElementException"" kind=""class"">
    NoSuchElementException 
  </clt></code>, while <code>peek</code> returns <code>null</code>.</p> 
<p><code>Queue</code> implementations generally do not allow insertion of <code>null</code> elements. The <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implementation, which was retrofitted to implement <code>Queue</code>, is an exception. For historical reasons, it permits <code>null</code> elements, but you should refrain from taking advantage of this, because <code>null</code> is used as a special return value by the <code>poll</code> and <code>peek</code> methods.</p>","LinkedList","java.util.LinkedList","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface - part 4","<h3>The Queue Interface - part 4</h3>
<p>Queue implementations generally do not define element-based versions of the <code>equals</code> and <code>hashCode</code> methods but instead inherit the identity-based versions from <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>.</p> 
<p>The <code>Queue</code> interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the interface <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     java.util.concurrent.BlockingQueue 
   </clt></code></a>, which extends <code>Queue</code>.</p> 
<p>In the following example program, a queue is used to implement a countdown timer. The queue is preloaded with all the integer values from a number specified on the command line to zero, in descending order. Then, the values are removed from the queue and printed at one-second intervals. The program is artificial in that it would be more natural to do the same thing without using a queue, but it illustrates the use of a queue to store elements prior to subsequent processing.</p>","Object","java.lang.Object","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface - part 4","<h3>The Queue Interface - part 4</h3>
<p>Queue implementations generally do not define element-based versions of the <code>equals</code> and <code>hashCode</code> methods but instead inherit the identity-based versions from <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>.</p> 
<p>The <code>Queue</code> interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the interface <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     java.util.concurrent.BlockingQueue 
   </clt></code></a>, which extends <code>Queue</code>.</p> 
<p>In the following example program, a queue is used to implement a countdown timer. The queue is preloaded with all the integer values from a number specified on the command line to zero, in descending order. Then, the values are removed from the queue and printed at one-second intervals. The program is artificial in that it would be more natural to do the same thing without using a queue, but it illustrates the use of a queue to store elements prior to subsequent processing.</p>","BlockingQueue","java.util.concurrent.BlockingQueue","class",FALSE
,"The 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","The Queue Interface - part 5","<h3>The Queue Interface - part 5</h3>
<p>In the following example, a priority queue is used to sort a collection of elements. Again this program is artificial in that there is no reason to use it in favor of the <code>sort</code> method provided in <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code>, but it illustrates the behavior of priority queues.</p>","Collections","java.util.Collections","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","The Set Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> that cannot contain duplicate elements. It models the mathematical set abstraction. The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface contains <i>only</i> methods inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and adds the restriction that duplicate elements are prohibited. <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> also adds a stronger contract on the behavior of the <code>equals</code> and <code>hashCode</code> operations, allowing <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances to be compared meaningfully even if their implementation types differ. Two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances are equal if they contain the same elements.</p> 
<p>The following is the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations: <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, which stores its elements in a hash table, is the best-performing implementation; however it makes no guarantees concerning the order of iteration. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, which stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>, which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order). <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> at a cost that is only slightly higher.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","The Set Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> that cannot contain duplicate elements. It models the mathematical set abstraction. The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface contains <i>only</i> methods inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and adds the restriction that duplicate elements are prohibited. <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> also adds a stronger contract on the behavior of the <code>equals</code> and <code>hashCode</code> operations, allowing <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances to be compared meaningfully even if their implementation types differ. Two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances are equal if they contain the same elements.</p> 
<p>The following is the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations: <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, which stores its elements in a hash table, is the best-performing implementation; however it makes no guarantees concerning the order of iteration. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, which stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>, which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order). <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> at a cost that is only slightly higher.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","The Set Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> that cannot contain duplicate elements. It models the mathematical set abstraction. The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface contains <i>only</i> methods inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and adds the restriction that duplicate elements are prohibited. <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> also adds a stronger contract on the behavior of the <code>equals</code> and <code>hashCode</code> operations, allowing <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances to be compared meaningfully even if their implementation types differ. Two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances are equal if they contain the same elements.</p> 
<p>The following is the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations: <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, which stores its elements in a hash table, is the best-performing implementation; however it makes no guarantees concerning the order of iteration. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, which stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>, which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order). <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> at a cost that is only slightly higher.</p>","HashSet","java.util.HashSet","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","The Set Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> that cannot contain duplicate elements. It models the mathematical set abstraction. The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface contains <i>only</i> methods inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and adds the restriction that duplicate elements are prohibited. <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> also adds a stronger contract on the behavior of the <code>equals</code> and <code>hashCode</code> operations, allowing <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances to be compared meaningfully even if their implementation types differ. Two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances are equal if they contain the same elements.</p> 
<p>The following is the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations: <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, which stores its elements in a hash table, is the best-performing implementation; however it makes no guarantees concerning the order of iteration. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, which stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>, which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order). <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> at a cost that is only slightly higher.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","The Set Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> that cannot contain duplicate elements. It models the mathematical set abstraction. The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface contains <i>only</i> methods inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and adds the restriction that duplicate elements are prohibited. <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> also adds a stronger contract on the behavior of the <code>equals</code> and <code>hashCode</code> operations, allowing <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances to be compared meaningfully even if their implementation types differ. Two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instances are equal if they contain the same elements.</p> 
<p>The following is the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface.</p> 
<p>The Java platform contains three general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations: <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, and <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, which stores its elements in a hash table, is the best-performing implementation; however it makes no guarantees concerning the order of iteration. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, which stores its elements in a red-black tree, orders its elements based on their values; it is substantially slower than <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>, which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order). <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> at a cost that is only slightly higher.</p>","LinkedHashSet","java.util.LinkedHashSet","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","The Set Interface - part 2","<h3>The Set Interface - part 2</h3>
<p>Here's a simple but useful <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> idiom. Suppose you have a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>, and you want to create another <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> containing the same elements but with all duplicates eliminated. The following one-liner does the trick.</p> 
<p>It works by creating a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> (which, by definition, cannot contain a duplicate), initially containing all the elements in <code>c</code>. It uses the standard conversion constructor described in the <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p> 
<p>Here is a minor variant of this idiom that preserves the order of the original collection while removing duplicate element.</p> 
<p>The following is a generic method that encapsulates the preceding idiom, returning a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> of the same generic type as the one passed.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","The Set Interface - part 2","<h3>The Set Interface - part 2</h3>
<p>Here's a simple but useful <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> idiom. Suppose you have a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>, and you want to create another <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> containing the same elements but with all duplicates eliminated. The following one-liner does the trick.</p> 
<p>It works by creating a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> (which, by definition, cannot contain a duplicate), initially containing all the elements in <code>c</code>. It uses the standard conversion constructor described in the <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p> 
<p>Here is a minor variant of this idiom that preserves the order of the original collection while removing duplicate element.</p> 
<p>The following is a generic method that encapsulates the preceding idiom, returning a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> of the same generic type as the one passed.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Basic Operations","<h2>Set Interface Basic Operations</h2> 
<p>The <code>size</code> operation returns the number of elements in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> (its <i>cardinality</i>). The <code>isEmpty</code> method does exactly what you think it would. The <code>add</code> method adds the specified element to the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> if it's not already present and returns a boolean indicating whether the element was added. Similarly, the <code>remove</code> method removes the specified element from the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> if it's present and returns a boolean indicating whether the element was present. The <code>iterator</code> method returns an <code>Iterator</code> over the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>.</p> 
<p>The following <a class=""SourceLink"" target=""_blank"" href=""examples/FindDups.java"" onclick=""showCode('../../displayCode.html', 'examples/FindDups.java'); return false;""><code>program</code></a> takes the words in its argument list and prints out any duplicate words, the number of distinct words, and a list of the words with duplicates eliminated.</p> 
<p>Now run the program.</p> 
<p>The following output is produced.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Basic Operations - part 2","<h3>Set Interface Basic Operations - part 2</h3>
<p>Note that the code always refers to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> by its interface type (<code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>) rather than by its implementation type (<code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>). This is a <i>strongly</i> recommended programming practice because it gives you the flexibility to change implementations merely by changing the constructor. If either of the variables used to store a collection or the parameters used to pass it around are declared to be of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s implementation type rather than its interface type, <i>all</i> such variables and parameters must be changed in order to change its implementation type.</p> 
<p>Furthermore, there's no guarantee that the resulting program will work. If the program uses any nonstandard operations present in the original implementation type but not in the new one, the program will fail. Referring to collections only by their interface prevents you from using any nonstandard operations.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Basic Operations - part 2","<h3>Set Interface Basic Operations - part 2</h3>
<p>Note that the code always refers to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> by its interface type (<code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>) rather than by its implementation type (<code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>). This is a <i>strongly</i> recommended programming practice because it gives you the flexibility to change implementations merely by changing the constructor. If either of the variables used to store a collection or the parameters used to pass it around are declared to be of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s implementation type rather than its interface type, <i>all</i> such variables and parameters must be changed in order to change its implementation type.</p> 
<p>Furthermore, there's no guarantee that the resulting program will work. If the program uses any nonstandard operations present in the original implementation type but not in the new one, the program will fail. Referring to collections only by their interface prevents you from using any nonstandard operations.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Basic Operations - part 2","<h3>Set Interface Basic Operations - part 2</h3>
<p>Note that the code always refers to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> by its interface type (<code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>) rather than by its implementation type (<code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>). This is a <i>strongly</i> recommended programming practice because it gives you the flexibility to change implementations merely by changing the constructor. If either of the variables used to store a collection or the parameters used to pass it around are declared to be of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s implementation type rather than its interface type, <i>all</i> such variables and parameters must be changed in order to change its implementation type.</p> 
<p>Furthermore, there's no guarantee that the resulting program will work. If the program uses any nonstandard operations present in the original implementation type but not in the new one, the program will fail. Referring to collections only by their interface prevents you from using any nonstandard operations.</p>","HashSet","java.util.HashSet","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Basic Operations - part 3","<h3>Set Interface Basic Operations - part 3</h3>
<p>The implementation type of the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> in the preceding example is <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, which makes no guarantees as to the order of the elements in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. If you want the program to print the word list in alphabetical order, merely change the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s implementation type from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Making this trivial one-line change causes the command line in the previous example to generate the following output.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Basic Operations - part 3","<h3>Set Interface Basic Operations - part 3</h3>
<p>The implementation type of the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> in the preceding example is <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, which makes no guarantees as to the order of the elements in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. If you want the program to print the word list in alphabetical order, merely change the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s implementation type from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Making this trivial one-line change causes the command line in the previous example to generate the following output.</p>","HashSet","java.util.HashSet","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Basic Operations - part 3","<h3>Set Interface Basic Operations - part 3</h3>
<p>The implementation type of the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> in the preceding example is <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, which makes no guarantees as to the order of the elements in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. If you want the program to print the word list in alphabetical order, merely change the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s implementation type from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Making this trivial one-line change causes the command line in the previous example to generate the following output.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Bulk Operations","<h2>Set Interface Bulk Operations</h2> 
<p>Bulk operations are particularly well suited to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s; when applied, they perform standard set-algebraic operations. Suppose <code>s1</code> and <code>s2</code> are sets. Here's what bulk operations do:</p> 
<ul> 
 <li><code>s1.containsAll(s2)</code> ? returns <code>true</code> if <code>s2</code> is a <b>subset</b> of <code>s1</code>. (<code>s2</code> is a subset of <code>s1</code> if set <code>s1</code> contains all of the elements in <code>s2</code>.)</li> 
 <li><code>s1.addAll(s2)</code> ? transforms <code>s1</code> into the <b>union</b> of <code>s1</code> and <code>s2</code>. (The union of two sets is the set containing all of the elements contained in either set.)</li> 
 <li><code>s1.retainAll(s2)</code> ? transforms <code>s1</code> into the intersection of <code>s1</code> and <code>s2</code>. (The intersection of two sets is the set containing only the elements common to both sets.)</li> 
 <li><code>s1.removeAll(s2)</code> ? transforms <code>s1</code> into the (asymmetric) set difference of <code>s1</code> and <code>s2</code>. (For example, the set difference of <code>s1</code> minus <code>s2</code> is the set containing all of the elements found in <code>s1</code> but not in <code>s2</code>.)</li> 
</ul>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Bulk Operations - part 2","<h3>Set Interface Bulk Operations - part 2</h3>
<p>To calculate the union, intersection, or set difference of two sets <i>nondestructively</i> (without modifying either set), the caller must copy one set before calling the appropriate bulk operation. The following are the resulting idioms.</p> 
<p>The implementation type of the result <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> in the preceding idioms is <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, which is, as already mentioned, the best all-around <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation in the Java platform. However, any general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation could be substituted.</p> 
<p>Let's revisit the <code>FindDups</code> program. Suppose you want to know which words in the argument list occur only once and which occur more than once, but you do not want any duplicates printed out repeatedly. This effect can be achieved by generating two sets ? one containing every word in the argument list and the other containing only the duplicates. The words that occur only once are the set difference of these two sets, which we know how to compute. Here's how <a class=""SourceLink"" target=""_blank"" href=""examples/FindDups2.java"" onclick=""showCode('../../displayCode.html', 'examples/FindDups2.java'); return false;""><code>the resulting program</code></a> looks.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Bulk Operations - part 2","<h3>Set Interface Bulk Operations - part 2</h3>
<p>To calculate the union, intersection, or set difference of two sets <i>nondestructively</i> (without modifying either set), the caller must copy one set before calling the appropriate bulk operation. The following are the resulting idioms.</p> 
<p>The implementation type of the result <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> in the preceding idioms is <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, which is, as already mentioned, the best all-around <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation in the Java platform. However, any general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation could be substituted.</p> 
<p>Let's revisit the <code>FindDups</code> program. Suppose you want to know which words in the argument list occur only once and which occur more than once, but you do not want any duplicates printed out repeatedly. This effect can be achieved by generating two sets ? one containing every word in the argument list and the other containing only the duplicates. The words that occur only once are the set difference of these two sets, which we know how to compute. Here's how <a class=""SourceLink"" target=""_blank"" href=""examples/FindDups2.java"" onclick=""showCode('../../displayCode.html', 'examples/FindDups2.java'); return false;""><code>the resulting program</code></a> looks.</p>","HashSet","java.util.HashSet","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Array Operations","<h2>Set Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The array operations don't do anything special for <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s beyond what they do for any other <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. These operations are described in <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p>","Array","java.sql.Array","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Array Operations","<h2>Set Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The array operations don't do anything special for <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s beyond what they do for any other <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. These operations are described in <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Interface Array Operations","<h2>Set Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The array operations don't do anything special for <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s beyond what they do for any other <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. These operations are described in <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","The SortedMap Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> that maintains its entries in ascending order, sorted according to the keys' natural ordering, or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> provided at the time of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> creation. Natural ordering and <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>s are discussed in the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface provides operations for normal <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> operations and for the following:</p> 
<ul> 
 <li><code>Range view</code> ? performs arbitrary range operations on the sorted map</li> 
 <li><code>Endpoints</code> ? returns the first or the last key in the sorted map</li> 
 <li><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator access 
   </clt></code> ? returns the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code>, if any, used to sort the map</li> 
</ul> 
<p>The following interface is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","The SortedMap Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> that maintains its entries in ascending order, sorted according to the keys' natural ordering, or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> provided at the time of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> creation. Natural ordering and <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>s are discussed in the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface provides operations for normal <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> operations and for the following:</p> 
<ul> 
 <li><code>Range view</code> ? performs arbitrary range operations on the sorted map</li> 
 <li><code>Endpoints</code> ? returns the first or the last key in the sorted map</li> 
 <li><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator access 
   </clt></code> ? returns the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code>, if any, used to sort the map</li> 
</ul> 
<p>The following interface is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","The SortedMap Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> that maintains its entries in ascending order, sorted according to the keys' natural ordering, or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> provided at the time of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> creation. Natural ordering and <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>s are discussed in the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface provides operations for normal <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> operations and for the following:</p> 
<ul> 
 <li><code>Range view</code> ? performs arbitrary range operations on the sorted map</li> 
 <li><code>Endpoints</code> ? returns the first or the last key in the sorted map</li> 
 <li><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator access 
   </clt></code> ? returns the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code>, if any, used to sort the map</li> 
</ul> 
<p>The following interface is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>.</p>","Comparator","java.util.Comparator","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","The SortedMap Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> that maintains its entries in ascending order, sorted according to the keys' natural ordering, or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> provided at the time of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> creation. Natural ordering and <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>s are discussed in the <a class=""TutorialLink"" target=""_top"" href=""order.html"">Object Ordering</a> section. The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface provides operations for normal <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> operations and for the following:</p> 
<ul> 
 <li><code>Range view</code> ? performs arbitrary range operations on the sorted map</li> 
 <li><code>Endpoints</code> ? returns the first or the last key in the sorted map</li> 
 <li><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator access 
   </clt></code> ? returns the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code>, if any, used to sort the map</li> 
</ul> 
<p>The following interface is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Map Operations","<h2>Map Operations</h2> 
<p>The operations <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> inherits from <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> behave identically on sorted maps and normal maps with two exceptions:</p> 
<ul> 
 <li>The <code>Iterator</code> returned by the <code> 
   <clt fqn=""java.util.Collection.iterator"" api=""Collection"" kind=""method"">
    Collection.iterator
   </clt></code> operation on any of the sorted map's <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views traverse the collections in order.</li> 
 <li>The arrays returned by the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views' <code>toArray</code> operations contain the keys, values, or entries in order.</li> 
</ul> 
<p>Although it isn't guaranteed by the interface, the <code>toString</code> method of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views in all the Java platform's <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations returns a string containing all the elements of the view, in order.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Map Operations","<h2>Map Operations</h2> 
<p>The operations <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> inherits from <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> behave identically on sorted maps and normal maps with two exceptions:</p> 
<ul> 
 <li>The <code>Iterator</code> returned by the <code> 
   <clt fqn=""java.util.Collection.iterator"" api=""Collection"" kind=""method"">
    Collection.iterator
   </clt></code> operation on any of the sorted map's <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views traverse the collections in order.</li> 
 <li>The arrays returned by the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views' <code>toArray</code> operations contain the keys, values, or entries in order.</li> 
</ul> 
<p>Although it isn't guaranteed by the interface, the <code>toString</code> method of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views in all the Java platform's <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations returns a string containing all the elements of the view, in order.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Map Operations","<h2>Map Operations</h2> 
<p>The operations <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> inherits from <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> behave identically on sorted maps and normal maps with two exceptions:</p> 
<ul> 
 <li>The <code>Iterator</code> returned by the <code> 
   <clt fqn=""java.util.Collection.iterator"" api=""Collection"" kind=""method"">
    Collection.iterator
   </clt></code> operation on any of the sorted map's <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views traverse the collections in order.</li> 
 <li>The arrays returned by the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> views' <code>toArray</code> operations contain the keys, values, or entries in order.</li> 
</ul> 
<p>Although it isn't guaranteed by the interface, the <code>toString</code> method of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views in all the Java platform's <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations returns a string containing all the elements of the view, in order.</p>","Collection","java.util.Collection.iterator","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","TreeMap","java.util.TreeMap","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","Attributes","java.util.jar.Attributes.map","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","Comparator","java.util.Comparator","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Comparison to SortedSet","<h2>Comparison to SortedSet</h2> 
<p>Because this interface is a precise <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, all the idioms and code examples in <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section apply to <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> with only trivial modifications.</p>","Map","java.util.Map","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Comparison to SortedSet","<h2>Comparison to SortedSet</h2> 
<p>Because this interface is a precise <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, all the idioms and code examples in <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section apply to <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> with only trivial modifications.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Comparison to SortedSet","<h2>Comparison to SortedSet</h2> 
<p>Because this interface is a precise <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, all the idioms and code examples in <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section apply to <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> with only trivial modifications.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","The SortedSet Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> that maintains its elements in ascending order, sorted according to the elements' natural ordering or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> provided at <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> creation time. In addition to the normal <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> operations, the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface provides operations for the following:</p> 
<ul> 
 <li><code>Range view</code> ? allows arbitrary range operations on the sorted set</li> 
 <li><code>Endpoints</code> ? returns the first or last element in the sorted set</li> 
 <li><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator access 
   </clt></code> ? returns the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code>, if any, used to sort the set</li> 
</ul> 
<p>The code for the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface follows.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","The SortedSet Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> that maintains its elements in ascending order, sorted according to the elements' natural ordering or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> provided at <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> creation time. In addition to the normal <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> operations, the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface provides operations for the following:</p> 
<ul> 
 <li><code>Range view</code> ? allows arbitrary range operations on the sorted set</li> 
 <li><code>Endpoints</code> ? returns the first or last element in the sorted set</li> 
 <li><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator access 
   </clt></code> ? returns the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code>, if any, used to sort the set</li> 
</ul> 
<p>The code for the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface follows.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","The SortedSet Interface","<div id=""PageTitle""> 
 <h1>The 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt>Interface</h1> 
</div> 
<p>A <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a> is a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> that maintains its elements in ascending order, sorted according to the elements' natural ordering or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> provided at <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> creation time. In addition to the normal <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> operations, the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface provides operations for the following:</p> 
<ul> 
 <li><code>Range view</code> ? allows arbitrary range operations on the sorted set</li> 
 <li><code>Endpoints</code> ? returns the first or last element in the sorted set</li> 
 <li><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator access 
   </clt></code> ? returns the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code>, if any, used to sort the set</li> 
</ul> 
<p>The code for the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface follows.</p>","Comparator","java.util.Comparator","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Set Operations","<h2>Set Operations</h2> 
<p>The operations that <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> inherits from <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> behave identically on sorted sets and normal sets with two exceptions:</p> 
<ul> 
 <li>The <code>Iterator</code> returned by the <code> 
   <clt fqn=""java.util.Set.iterator"" api=""Set"" kind=""method"">
    Set.iterator
   </clt></code> operation traverses the sorted set in order.</li> 
 <li>The array returned by <code>toArray</code> contains the sorted set's elements in order.</li> 
</ul> 
<p>Although the interface doesn't guarantee it, the <code>toString</code> method of the Java platform's <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations returns a string containing all the elements of the sorted set, in order.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Set Operations","<h2>Set Operations</h2> 
<p>The operations that <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> inherits from <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> behave identically on sorted sets and normal sets with two exceptions:</p> 
<ul> 
 <li>The <code>Iterator</code> returned by the <code> 
   <clt fqn=""java.util.Set.iterator"" api=""Set"" kind=""method"">
    Set.iterator
   </clt></code> operation traverses the sorted set in order.</li> 
 <li>The array returned by <code>toArray</code> contains the sorted set's elements in order.</li> 
</ul> 
<p>Although the interface doesn't guarantee it, the <code>toString</code> method of the Java platform's <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations returns a string containing all the elements of the sorted set, in order.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Standard Constructors","<h2><a name=""constructor"" id=""constructor"">Standard Constructors</a></h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> instance and, if so, to sort the new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> took the approach that it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).</p> 
<p><code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty set sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.</p>","Collection","java.util.Collection","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Standard Constructors","<h2><a name=""constructor"" id=""constructor"">Standard Constructors</a></h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> instance and, if so, to sort the new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> took the approach that it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).</p> 
<p><code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty set sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Standard Constructors","<h2><a name=""constructor"" id=""constructor"">Standard Constructors</a></h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> instance and, if so, to sort the new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> took the approach that it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).</p> 
<p><code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty set sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.</p>","TreeSet","java.util.TreeSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 2","<h3>Range-view Operations - part 2</h3>
<p>Sorted sets provide three <code>range-view</code> operations. The first, <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code>, takes two endpoints, like <code>subList</code>. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> or the natural ordering of its elements, whichever the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> uses to order itself. Like <code>subList</code>, the range is half open, including its low endpoint but excluding the high one.</p> 
<p>Thus, the following line of code tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including <code>&quot;doorbell&quot;</code> but excluding <code>&quot;pickle&quot;</code>, are contained in a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> of strings called <code>dictionary</code>:</p> 
<p>In like manner, the following one-liner removes all the elements beginning with the letter <code>f</code>.</p> 
<p>A similar trick can be used to print a table telling you how many words begin with each letter.</p>","SortedSet","java.util.SortedSet.subSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 2","<h3>Range-view Operations - part 2</h3>
<p>Sorted sets provide three <code>range-view</code> operations. The first, <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code>, takes two endpoints, like <code>subList</code>. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> or the natural ordering of its elements, whichever the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> uses to order itself. Like <code>subList</code>, the range is half open, including its low endpoint but excluding the high one.</p> 
<p>Thus, the following line of code tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including <code>&quot;doorbell&quot;</code> but excluding <code>&quot;pickle&quot;</code>, are contained in a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> of strings called <code>dictionary</code>:</p> 
<p>In like manner, the following one-liner removes all the elements beginning with the letter <code>f</code>.</p> 
<p>A similar trick can be used to print a table telling you how many words begin with each letter.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 2","<h3>Range-view Operations - part 2</h3>
<p>Sorted sets provide three <code>range-view</code> operations. The first, <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code>, takes two endpoints, like <code>subList</code>. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> or the natural ordering of its elements, whichever the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> uses to order itself. Like <code>subList</code>, the range is half open, including its low endpoint but excluding the high one.</p> 
<p>Thus, the following line of code tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including <code>&quot;doorbell&quot;</code> but excluding <code>&quot;pickle&quot;</code>, are contained in a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> of strings called <code>dictionary</code>:</p> 
<p>In like manner, the following one-liner removes all the elements beginning with the letter <code>f</code>.</p> 
<p>A similar trick can be used to print a table telling you how many words begin with each letter.</p>","Comparator","java.util.Comparator","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","SortedSet","java.util.SortedSet.subSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","TreeMap","java.util.TreeMap.successor","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","String","java.lang.String","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","CheckedEntrySet","java.util.Collections.CheckedMap.CheckedEntrySet.s","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 4","<h3>Range-view Operations - part 4</h3>
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains two more <code>range-view</code> operations ? <code> 
  <clt fqn=""java.util.SortedSet.headSet"" api=""SortedSet"" kind=""method"">
   SortedSet.headSet
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code>, both of which take a single <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> argument. The former returns a view of the initial portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, up to but not including the specified object. The latter returns a view of the final portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, beginning with the specified object and continuing to the end of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. Thus, the following code allows you to view the dictionary as two disjoint <code>volumes</code> (<code>a-m</code> and <code>n-z</code>).</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Range-view Operations - part 4","<h3>Range-view Operations - part 4</h3>
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains two more <code>range-view</code> operations ? <code> 
  <clt fqn=""java.util.SortedSet.headSet"" api=""SortedSet"" kind=""method"">
   SortedSet.headSet
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code>, both of which take a single <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> argument. The former returns a view of the initial portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, up to but not including the specified object. The latter returns a view of the final portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, beginning with the specified object and continuing to the end of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. Thus, the following code allows you to view the dictionary as two disjoint <code>volumes</code> (<code>a-m</code> and <code>n-z</code>).</p>","Object","java.lang.Object","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Endpoint Operations","<h2>Endpoint Operations</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains operations to return the first and last elements in the sorted set, not surprisingly called <code> 
  <clt fqn=""java.util.SortedSet.first"" api=""SortedSet"" kind=""method"">
   SortedSet.first
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code>. In addition to their obvious uses, <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code> allows a workaround for a deficiency in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface. One thing you'd like to do with a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is to go into the interior of the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and iterate forward or backward. It's easy enough to go forward from the interior: Just get a <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code> and iterate over it. Unfortunately, there's no easy way to go backward.</p> 
<p>The following idiom obtains the first element that is less than a specified object <code>o</code> in the element space.</p> 
<p>This is a fine way to go one element backward from a point in the interior of a sorted set. It could be applied repeatedly to iterate backward, but this is very inefficient, requiring a lookup for each element returned.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Endpoint Operations","<h2>Endpoint Operations</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains operations to return the first and last elements in the sorted set, not surprisingly called <code> 
  <clt fqn=""java.util.SortedSet.first"" api=""SortedSet"" kind=""method"">
   SortedSet.first
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code>. In addition to their obvious uses, <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code> allows a workaround for a deficiency in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface. One thing you'd like to do with a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is to go into the interior of the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and iterate forward or backward. It's easy enough to go forward from the interior: Just get a <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code> and iterate over it. Unfortunately, there's no easy way to go backward.</p> 
<p>The following idiom obtains the first element that is less than a specified object <code>o</code> in the element space.</p> 
<p>This is a fine way to go one element backward from a point in the interior of a sorted set. It could be applied repeatedly to iterate backward, but this is very inefficient, requiring a lookup for each element returned.</p>","Set","java.util.Set","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Comparator Accessor","<h2>Comparator Accessor</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains an accessor method called <code> 
  <clt fqn=""java.util.SortedSet.comparator"" api=""SortedSet"" kind=""method"">
   SortedSet.comparator
  </clt></code> that returns the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> used to sort the set, or <code>null</code> if the set is sorted according to the <i>natural ordering</i> of its elements. This method is provided so that sorted sets can be copied into new sorted sets with the same ordering. It is used by the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> constructor described <a href=""#constructor"">previously</a>.</p>","SortedSet","java.util.SortedSet","class",FALSE
,"The 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Comparator Accessor","<h2>Comparator Accessor</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains an accessor method called <code> 
  <clt fqn=""java.util.SortedSet.comparator"" api=""SortedSet"" kind=""method"">
   SortedSet.comparator
  </clt></code> that returns the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> used to sort the set, or <code>null</code> if the set is sorted according to the <i>natural ordering</i> of its elements. This method is provided so that sorted sets can be copied into new sorted sets with the same ordering. It is used by the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> constructor described <a href=""#constructor"">previously</a>.</p>","Comparator","java.util.Comparator","class",FALSE
,"API Design","Parameters","<h2>Parameters</h2> 
<p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">interface</a> types. <b>Never</b> use an <a class=""TutorialLink"" target=""_top"" href=""../implementations/index.html"">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p> 
<p>Further, you should always use the least-specific type that makes sense. For example, don't require a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html""><code>List</code></a> or a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> if a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> would do. It's not that you should never require a <code>List</code> or a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a <code>List</code> on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""note""> 
 <strong>Caution:</strong>&nbsp;Never define your own ad hoc 
 <code>collection</code> class and require objects of this class on input. By doing this, you'd lose all the 
 <a class=""TutorialLink"" target=""_top"" href=""../intro/index.html"">benefits provided by the Java Collections Framework</a>. 
</div>","Set","java.util.Set","class",FALSE
,"API Design","Parameters","<h2>Parameters</h2> 
<p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">interface</a> types. <b>Never</b> use an <a class=""TutorialLink"" target=""_top"" href=""../implementations/index.html"">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p> 
<p>Further, you should always use the least-specific type that makes sense. For example, don't require a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html""><code>List</code></a> or a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> if a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> would do. It's not that you should never require a <code>List</code> or a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a <code>List</code> on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""note""> 
 <strong>Caution:</strong>&nbsp;Never define your own ad hoc 
 <code>collection</code> class and require objects of this class on input. By doing this, you'd lose all the 
 <a class=""TutorialLink"" target=""_top"" href=""../intro/index.html"">benefits provided by the Java Collections Framework</a>. 
</div>","Collection","java.util.Collection","class",FALSE
,"API Design","Parameters","<h2>Parameters</h2> 
<p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">interface</a> types. <b>Never</b> use an <a class=""TutorialLink"" target=""_top"" href=""../implementations/index.html"">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p> 
<p>Further, you should always use the least-specific type that makes sense. For example, don't require a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html""><code>List</code></a> or a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> if a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> would do. It's not that you should never require a <code>List</code> or a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a <code>List</code> on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""note""> 
 <strong>Caution:</strong>&nbsp;Never define your own ad hoc 
 <code>collection</code> class and require objects of this class on input. By doing this, you'd lose all the 
 <a class=""TutorialLink"" target=""_top"" href=""../intro/index.html"">benefits provided by the Java Collections Framework</a>. 
</div>","Map","java.util.Map","class",FALSE
,"API Design","Return Values","<h2>Return Values</h2> 
<p>You can afford to be much more flexible with return values than with input parameters. It's fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces.</p> 
<p>For example, one could imagine an image-processing package, called <code>ImageList</code>, that returned objects of a new class that implements <code>List</code>. In addition to the <code>List</code> operations, <code>ImageList</code> could support any application-specific operations that seemed desirable. For example, it might provide an <code>indexImage</code> operation that returned an image containing thumbnail images of each graphic in the <code>ImageList</code>. It's critical to note that even if the API furnishes <code>ImageList</code> instances on output, it should accept arbitrary <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> (or perhaps <code>List</code>) instances on input.</p>","Collection","java.util.Collection","class",FALSE
,"API Design","Return Values - part 2","<h3>Return Values - part 2</h3>
<p>In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, you should give the relevant method the return type of <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> rather than <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> instances are more time-consuming to build than ordinary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances and are also more powerful. Given that your module has already invested the time to build a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, as well as those that accept any <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","SortedMap","java.util.SortedMap","class",FALSE
,"API Design","Return Values - part 2","<h3>Return Values - part 2</h3>
<p>In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, you should give the relevant method the return type of <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> rather than <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> instances are more time-consuming to build than ordinary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances and are also more powerful. Given that your module has already invested the time to build a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, as well as those that accept any <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","Map","java.util.Map","class",FALSE
,"Compatibility","Compatibility","<div id=""PageTitle""> 
 <h1>Compatibility</h1> 
</div> 
<p>The Java Collections Framework was designed to ensure complete interoperability between the core <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">collection interfaces</a> and the types that were used to represent collections in the early versions of the Java platform: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html""><code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code></a>, <a class=""TutorialLink"" target=""_top"" href=""../../java/nutsandbolts/arrays.html"">array</a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html""><code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code></a>. In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.</p>","Vector","java.util.Vector","class",FALSE
,"Compatibility","Compatibility","<div id=""PageTitle""> 
 <h1>Compatibility</h1> 
</div> 
<p>The Java Collections Framework was designed to ensure complete interoperability between the core <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">collection interfaces</a> and the types that were used to represent collections in the early versions of the Java platform: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html""><code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code></a>, <a class=""TutorialLink"" target=""_top"" href=""../../java/nutsandbolts/arrays.html"">array</a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html""><code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code></a>. In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"Compatibility","Compatibility","<div id=""PageTitle""> 
 <h1>Compatibility</h1> 
</div> 
<p>The Java Collections Framework was designed to ensure complete interoperability between the core <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">collection interfaces</a> and the types that were used to represent collections in the early versions of the Java platform: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html""><code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code></a>, <a class=""TutorialLink"" target=""_top"" href=""../../java/nutsandbolts/arrays.html"">array</a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html""><code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code></a>. In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.</p>","Enumeration","java.util.Enumeration","class",FALSE
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Collection","java.util.Collection","class",FALSE
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Arrays","java.util.Arrays.asList","class",FALSE
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Vector","java.util.Vector","class",FALSE
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Map","java.util.Map","class",FALSE
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Enumeration","java.util.Enumeration","class",FALSE
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Collections","java.util.Collections.list","class",FALSE
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Collection","java.util.Collection","class",FALSE
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Object","java.lang.Object","class",FALSE
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","String","java.lang.String","class",FALSE
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Vector","java.util.Vector","class",FALSE
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Hashtable","java.util.Hashtable","class",FALSE
,"Compatibility","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Enumeration","java.util.Enumeration","class",FALSE
,"Compatibility","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Collections","java.util.Collections","class",FALSE
,"Compatibility","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Collection","java.util.Collection","class",FALSE
,"Lesson: Algorithms","Lesson: Algorithms","<div id=""PageTitle""> 
 <h1>Lesson: Algorithms</h1> 
</div> 
<p>The <em>polymorphic algorithms</em> described here are pieces of reusable functionality provided by the Java platform. All of them come from the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code></a> instances, but a few of them operate on arbitrary <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> instances. This section briefly describes the following algorithms:</p> 
<ul> 
 <li><a href=""#sorting"">Sorting</a></li> 
 <li><a href=""#shuffling"">Shuffling</a></li> 
 <li><a href=""#rdm"">Routine Data Manipulation</a></li> 
 <li><a href=""#searching"">Searching</a></li> 
 <li><a href=""#composition"">Composition</a></li> 
 <li><a href=""#fev"">Finding Extreme Values</a></li> 
</ul>","Collections","java.util.Collections","class",FALSE
,"Lesson: Algorithms","Lesson: Algorithms","<div id=""PageTitle""> 
 <h1>Lesson: Algorithms</h1> 
</div> 
<p>The <em>polymorphic algorithms</em> described here are pieces of reusable functionality provided by the Java platform. All of them come from the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code></a> instances, but a few of them operate on arbitrary <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> instances. This section briefly describes the following algorithms:</p> 
<ul> 
 <li><a href=""#sorting"">Sorting</a></li> 
 <li><a href=""#shuffling"">Shuffling</a></li> 
 <li><a href=""#rdm"">Routine Data Manipulation</a></li> 
 <li><a href=""#searching"">Searching</a></li> 
 <li><a href=""#composition"">Composition</a></li> 
 <li><a href=""#fev"">Finding Extreme Values</a></li> 
</ul>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Lesson: Algorithms","<div id=""PageTitle""> 
 <h1>Lesson: Algorithms</h1> 
</div> 
<p>The <em>polymorphic algorithms</em> described here are pieces of reusable functionality provided by the Java platform. All of them come from the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code></a> instances, but a few of them operate on arbitrary <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> instances. This section briefly describes the following algorithms:</p> 
<ul> 
 <li><a href=""#sorting"">Sorting</a></li> 
 <li><a href=""#shuffling"">Shuffling</a></li> 
 <li><a href=""#rdm"">Routine Data Manipulation</a></li> 
 <li><a href=""#searching"">Searching</a></li> 
 <li><a href=""#composition"">Composition</a></li> 
 <li><a href=""#fev"">Finding Extreme Values</a></li> 
</ul>","Collection","java.util.Collection","class",FALSE
,"Lesson: Algorithms","Sorting","<h2>Sorting</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm reorders a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and sorts it according to its elements' <em>natural ordering</em>. If you're unfamiliar with the concept of natural ordering, read the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/order.html"">Object Ordering</a> section.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> operation uses a slightly optimized <em>merge sort</em> algorithm that is fast and stable:</p> 
<ul> 
 <li><b>Fast</b>: It is guaranteed to run in <code>n log(n)</code> time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn't stable and doesn't guarantee <code>n log(n)</code> performance.</li> 
 <li><b>Stable</b>: It doesn't reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable.</li> 
</ul>","Collections","java.util.Collections.sort","class",FALSE
,"Lesson: Algorithms","Sorting","<h2>Sorting</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm reorders a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and sorts it according to its elements' <em>natural ordering</em>. If you're unfamiliar with the concept of natural ordering, read the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/order.html"">Object Ordering</a> section.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> operation uses a slightly optimized <em>merge sort</em> algorithm that is fast and stable:</p> 
<ul> 
 <li><b>Fast</b>: It is guaranteed to run in <code>n log(n)</code> time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn't stable and doesn't guarantee <code>n log(n)</code> performance.</li> 
 <li><b>Stable</b>: It doesn't reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable.</li> 
</ul>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Sorting - part 2","<h3>Sorting - part 2</h3>
<p>The following <a class=""SourceLink"" target=""_blank"" href=""examples/Sort.java"" onclick=""showCode('../../displayCode.html', 'examples/Sort.java'); return false;""><code>trivial program</code></a> prints out its arguments in lexicographic (alphabetical) order.</p> 
<p>Let's run the program.</p> 
<p>The following output is produced.</p> 
<p>The program was included only to show you that algorithms really are as easy to use as they appear to be.</p> 
<p>The second form of <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> takes a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> in addition to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and sorts the elements with the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. Suppose you want to print out the anagram groups from our earlier example in reverse order of size ? largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> method.</p>","Collections","java.util.Collections.sort","class",FALSE
,"Lesson: Algorithms","Sorting - part 2","<h3>Sorting - part 2</h3>
<p>The following <a class=""SourceLink"" target=""_blank"" href=""examples/Sort.java"" onclick=""showCode('../../displayCode.html', 'examples/Sort.java'); return false;""><code>trivial program</code></a> prints out its arguments in lexicographic (alphabetical) order.</p> 
<p>Let's run the program.</p> 
<p>The following output is produced.</p> 
<p>The program was included only to show you that algorithms really are as easy to use as they appear to be.</p> 
<p>The second form of <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> takes a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> in addition to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and sorts the elements with the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. Suppose you want to print out the anagram groups from our earlier example in reverse order of size ? largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> method.</p>","Comparator","java.util.Comparator","class",FALSE
,"Lesson: Algorithms","Sorting - part 2","<h3>Sorting - part 2</h3>
<p>The following <a class=""SourceLink"" target=""_blank"" href=""examples/Sort.java"" onclick=""showCode('../../displayCode.html', 'examples/Sort.java'); return false;""><code>trivial program</code></a> prints out its arguments in lexicographic (alphabetical) order.</p> 
<p>Let's run the program.</p> 
<p>The following output is produced.</p> 
<p>The program was included only to show you that algorithms really are as easy to use as they appear to be.</p> 
<p>The second form of <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> takes a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> in addition to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and sorts the elements with the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. Suppose you want to print out the anagram groups from our earlier example in reverse order of size ? largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> method.</p>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Sorting - part 3","<h3>Sorting - part 3</h3>
<p>Recall that the anagram groups are stored as values in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, in the form of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instances. The revised printing code iterates through the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s values view, putting every <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> that passes the minimum-size test into a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>s. Then the code sorts this <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, using a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that expects <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instances, and implements reverse size-ordering. Finally, the code iterates through the sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, printing its elements (the anagram groups). The following code replaces the printing code at the end of the <code>main</code> method in the <code>Anagrams</code> example.</p> 
<p>Running <a class=""SourceLink"" target=""_blank"" href=""examples/Anagrams2.java"" onclick=""showCode('../../displayCode.html', 'examples/Anagrams2.java'); return false;""><code>the program</code></a> on the <a class=""SourceLink"" target=""_blank"" href=""../interfaces/examples/dictionary.txt"" onclick=""showCode('../../displayCode.html', '../interfaces/examples/dictionary.txt'); return false;""><code>same dictionary</code></a> as in <a class=""TutorialLink"" target=""_top"" href=""../interfaces/map.html"">The Map Interface</a> section, with the same minimum anagram group size (eight), produces the following output.</p>","Map","java.util.Map","class",FALSE
,"Lesson: Algorithms","Sorting - part 3","<h3>Sorting - part 3</h3>
<p>Recall that the anagram groups are stored as values in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, in the form of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instances. The revised printing code iterates through the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s values view, putting every <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> that passes the minimum-size test into a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>s. Then the code sorts this <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, using a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that expects <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instances, and implements reverse size-ordering. Finally, the code iterates through the sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, printing its elements (the anagram groups). The following code replaces the printing code at the end of the <code>main</code> method in the <code>Anagrams</code> example.</p> 
<p>Running <a class=""SourceLink"" target=""_blank"" href=""examples/Anagrams2.java"" onclick=""showCode('../../displayCode.html', 'examples/Anagrams2.java'); return false;""><code>the program</code></a> on the <a class=""SourceLink"" target=""_blank"" href=""../interfaces/examples/dictionary.txt"" onclick=""showCode('../../displayCode.html', '../interfaces/examples/dictionary.txt'); return false;""><code>same dictionary</code></a> as in <a class=""TutorialLink"" target=""_top"" href=""../interfaces/map.html"">The Map Interface</a> section, with the same minimum anagram group size (eight), produces the following output.</p>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Sorting - part 3","<h3>Sorting - part 3</h3>
<p>Recall that the anagram groups are stored as values in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, in the form of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instances. The revised printing code iterates through the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s values view, putting every <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> that passes the minimum-size test into a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>s. Then the code sorts this <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, using a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that expects <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instances, and implements reverse size-ordering. Finally, the code iterates through the sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, printing its elements (the anagram groups). The following code replaces the printing code at the end of the <code>main</code> method in the <code>Anagrams</code> example.</p> 
<p>Running <a class=""SourceLink"" target=""_blank"" href=""examples/Anagrams2.java"" onclick=""showCode('../../displayCode.html', 'examples/Anagrams2.java'); return false;""><code>the program</code></a> on the <a class=""SourceLink"" target=""_blank"" href=""../interfaces/examples/dictionary.txt"" onclick=""showCode('../../displayCode.html', '../interfaces/examples/dictionary.txt'); return false;""><code>same dictionary</code></a> as in <a class=""TutorialLink"" target=""_top"" href=""../interfaces/map.html"">The Map Interface</a> section, with the same minimum anagram group size (eight), produces the following output.</p>","Comparator","java.util.Comparator","class",FALSE
,"Lesson: Algorithms","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","Collections","java.util.Collections.shuffle","class",FALSE
,"Lesson: Algorithms","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","Card","java.awt.CardLayout.Card","class",FALSE
,"Lesson: Algorithms","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","Random","java.util.Random","class",FALSE
,"Lesson: Algorithms","Routine Data Manipulation","<h2>Routine Data Manipulation</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class provides five algorithms for doing routine data manipulation on <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> objects, all of which are pretty straightforward:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> with the specified value. This operation is useful for reinitializing a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? takes two arguments, a destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> and a source <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>, and copies the elements of the source into the destination, overwriting its contents. The destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> must be at least as long as the source. If it is longer, the remaining elements in the destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> are unaffected.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at the specified positions in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.addAll"" api=""Collections"" kind=""method"">
    Collections.addAll
   </clt></code> ? adds all the specified elements to a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. The elements to be added may be specified individually or as an array.</li> 
</ul>","Collections","java.util.Collections","class",FALSE
,"Lesson: Algorithms","Routine Data Manipulation","<h2>Routine Data Manipulation</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class provides five algorithms for doing routine data manipulation on <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> objects, all of which are pretty straightforward:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> with the specified value. This operation is useful for reinitializing a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? takes two arguments, a destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> and a source <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>, and copies the elements of the source into the destination, overwriting its contents. The destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> must be at least as long as the source. If it is longer, the remaining elements in the destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> are unaffected.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at the specified positions in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.addAll"" api=""Collections"" kind=""method"">
    Collections.addAll
   </clt></code> ? adds all the specified elements to a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. The elements to be added may be specified individually or as an array.</li> 
</ul>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Routine Data Manipulation","<h2>Routine Data Manipulation</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class provides five algorithms for doing routine data manipulation on <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> objects, all of which are pretty straightforward:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> with the specified value. This operation is useful for reinitializing a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? takes two arguments, a destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> and a source <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>, and copies the elements of the source into the destination, overwriting its contents. The destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> must be at least as long as the source. If it is longer, the remaining elements in the destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> are unaffected.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at the specified positions in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.addAll"" api=""Collections"" kind=""method"">
    Collections.addAll
   </clt></code> ? adds all the specified elements to a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. The elements to be added may be specified individually or as an array.</li> 
</ul>","Collection","java.util.Collection","class",FALSE
,"Lesson: Algorithms","Searching","<h2>Searching</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> algorithm searches for a specified element in a sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This algorithm has two forms. The first takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and an element to search for (the &quot;search key&quot;). This form assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted in ascending order according to the natural ordering of its elements. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the search key, and assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted into ascending order according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm can be used to sort the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> prior to calling <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code>.</p>","Collections","java.util.Collections.binarySearch","class",FALSE
,"Lesson: Algorithms","Searching","<h2>Searching</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> algorithm searches for a specified element in a sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This algorithm has two forms. The first takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and an element to search for (the &quot;search key&quot;). This form assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted in ascending order according to the natural ordering of its elements. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the search key, and assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted into ascending order according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm can be used to sort the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> prior to calling <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code>.</p>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Searching","<h2>Searching</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> algorithm searches for a specified element in a sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This algorithm has two forms. The first takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and an element to search for (the &quot;search key&quot;). This form assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted in ascending order according to the natural ordering of its elements. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the search key, and assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted into ascending order according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm can be used to sort the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> prior to calling <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code>.</p>","Comparator","java.util.Comparator","class",FALSE
,"Lesson: Algorithms","Searching - part 2","<h3>Searching - part 2</h3>
<p>The return value is the same for both forms. If the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> contains the search key, its index is returned. If not, the return value is <code>(-(insertion point) - 1)</code>, where the insertion point is the point at which the value would be inserted into the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, or the index of the first element greater than the value or <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   List.size()
  </clt></code> if all elements in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> are less than the specified value. This admittedly ugly formula guarantees that the return value will be <code>&gt;= 0</code> if and only if the search key is found. It's basically a hack to combine a boolean <code>(found)</code> and an integer <code>(index)</code> into a single <code>int</code> return value.</p> 
<p>The following idiom, usable with both forms of the <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> operation, looks for the specified search key and inserts it at the appropriate position if it's not already present.</p>","List","java.util.List","class",FALSE
,"Lesson: Algorithms","Searching - part 2","<h3>Searching - part 2</h3>
<p>The return value is the same for both forms. If the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> contains the search key, its index is returned. If not, the return value is <code>(-(insertion point) - 1)</code>, where the insertion point is the point at which the value would be inserted into the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, or the index of the first element greater than the value or <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   List.size()
  </clt></code> if all elements in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> are less than the specified value. This admittedly ugly formula guarantees that the return value will be <code>&gt;= 0</code> if and only if the search key is found. It's basically a hack to combine a boolean <code>(found)</code> and an integer <code>(index)</code> into a single <code>int</code> return value.</p> 
<p>The following idiom, usable with both forms of the <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> operation, looks for the specified search key and inserts it at the appropriate position if it's not already present.</p>","Collections","java.util.Collections.binarySearch","class",FALSE
,"Lesson: Algorithms","Composition","<h2>Composition</h2> 
<p>The frequency and disjoint algorithms test some aspect of the composition of one or more <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code>:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.frequency"" api=""Collections"" kind=""method"">
    Collections.frequency
   </clt></code> ? counts the number of times the specified element occurs in the specified collection</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.disjoint"" api=""Collections"" kind=""method"">
    Collections.disjoint
   </clt></code> ? determines whether two <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> are disjoint; that is, whether they contain no elements in common</li> 
</ul>","Collections","java.util.Collections","class",FALSE
,"Lesson: Algorithms","Finding Extreme Values","<h2>Finding Extreme Values</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.min"" api=""Collections"" kind=""method"">
   Collections.min
  </clt></code> and the <code> 
  <clt fqn=""java.util.Collections.max"" api=""Collections"" kind=""method"">
   Collections.max
  </clt></code> algorithms return, respectively, the minimum and maximum element contained in a specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. Both of these operations come in two forms. The simple form takes only a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p>","Collections","java.util.Collections.min","class",FALSE
,"Lesson: Algorithms","Finding Extreme Values","<h2>Finding Extreme Values</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.min"" api=""Collections"" kind=""method"">
   Collections.min
  </clt></code> and the <code> 
  <clt fqn=""java.util.Collections.max"" api=""Collections"" kind=""method"">
   Collections.max
  </clt></code> algorithms return, respectively, the minimum and maximum element contained in a specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. Both of these operations come in two forms. The simple form takes only a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p>","Collection","java.util.Collection","class",FALSE
,"Lesson: Algorithms","Finding Extreme Values","<h2>Finding Extreme Values</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.min"" api=""Collections"" kind=""method"">
   Collections.min
  </clt></code> and the <code> 
  <clt fqn=""java.util.Collections.max"" api=""Collections"" kind=""method"">
   Collections.max
  </clt></code> algorithms return, respectively, the minimum and maximum element contained in a specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. Both of these operations come in two forms. The simple form takes only a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p>","Comparator","java.util.Comparator","class",FALSE
