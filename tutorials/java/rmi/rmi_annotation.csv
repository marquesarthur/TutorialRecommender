"","","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","Collections","java.util.Collections.shuffle","class","false"
"","","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","List","java.util.List","class","false"
"","","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","Card","java.awt.CardLayout.Card","class","false"
"","","Shuffling","<h2>Shuffling</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.shuffle"" api=""Collections"" kind=""method"">
   Collections.shuffle
  </clt></code> algorithm does the opposite of what <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> does, destroying any trace of order that may have been present in a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. That is, this algorithm reorders the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.awt.CardLayout.Card"" api=""Card"" kind=""class"">
    Card 
  </clt></code> objects representing a deck. Also, it's useful for generating test cases.</p> 
<p>This operation has two forms: one takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and uses a default source of randomness, and the other requires the caller to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Random.html""> 
  <clt fqn=""java.util.Random"" api=""Random"" kind=""class"">
    Random 
  </clt></a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html#shuffle""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> section</a>. </p>","Random","java.util.Random","class","false"
"","","Routine Data Manipulation","<h2>Routine Data Manipulation</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class provides five algorithms for doing routine data manipulation on <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> objects, all of which are pretty straightforward:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> with the specified value. This operation is useful for reinitializing a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? takes two arguments, a destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> and a source <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>, and copies the elements of the source into the destination, overwriting its contents. The destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> must be at least as long as the source. If it is longer, the remaining elements in the destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> are unaffected.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at the specified positions in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.addAll"" api=""Collections"" kind=""method"">
    Collections.addAll
   </clt></code> ? adds all the specified elements to a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. The elements to be added may be specified individually or as an array.</li> 
</ul>","Collections","java.util.Collections","class","false"
"","","Routine Data Manipulation","<h2>Routine Data Manipulation</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class provides five algorithms for doing routine data manipulation on <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> objects, all of which are pretty straightforward:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> with the specified value. This operation is useful for reinitializing a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? takes two arguments, a destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> and a source <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>, and copies the elements of the source into the destination, overwriting its contents. The destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> must be at least as long as the source. If it is longer, the remaining elements in the destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> are unaffected.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at the specified positions in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.addAll"" api=""Collections"" kind=""method"">
    Collections.addAll
   </clt></code> ? adds all the specified elements to a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. The elements to be added may be specified individually or as an array.</li> 
</ul>","List","java.util.List","class","false"
"","","Routine Data Manipulation","<h2>Routine Data Manipulation</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class provides five algorithms for doing routine data manipulation on <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> objects, all of which are pretty straightforward:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> with the specified value. This operation is useful for reinitializing a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? takes two arguments, a destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> and a source <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>, and copies the elements of the source into the destination, overwriting its contents. The destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> must be at least as long as the source. If it is longer, the remaining elements in the destination <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code> are unaffected.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at the specified positions in a <code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.addAll"" api=""Collections"" kind=""method"">
    Collections.addAll
   </clt></code> ? adds all the specified elements to a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. The elements to be added may be specified individually or as an array.</li> 
</ul>","Collection","java.util.Collection","class","false"
"","","Searching","<h2>Searching</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> algorithm searches for a specified element in a sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This algorithm has two forms. The first takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and an element to search for (the &quot;search key&quot;). This form assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted in ascending order according to the natural ordering of its elements. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the search key, and assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted into ascending order according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm can be used to sort the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> prior to calling <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code>.</p>","Collections","java.util.Collections.binarySearch","class","false"
"","","Searching","<h2>Searching</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> algorithm searches for a specified element in a sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This algorithm has two forms. The first takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and an element to search for (the &quot;search key&quot;). This form assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted in ascending order according to the natural ordering of its elements. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the search key, and assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted into ascending order according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm can be used to sort the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> prior to calling <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code>.</p>","List","java.util.List","class","false"
"","","Searching","<h2>Searching</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> algorithm searches for a specified element in a sorted <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This algorithm has two forms. The first takes a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and an element to search for (the &quot;search key&quot;). This form assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted in ascending order according to the natural ordering of its elements. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the search key, and assumes that the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is sorted into ascending order according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
   Collections.sort
  </clt></code> algorithm can be used to sort the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> prior to calling <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code>.</p>","Comparator","java.util.Comparator","class","false"
"","","Searching - part 2","<h3>Searching - part 2</h3>
<p>The return value is the same for both forms. If the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> contains the search key, its index is returned. If not, the return value is <code>(-(insertion point) - 1)</code>, where the insertion point is the point at which the value would be inserted into the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, or the index of the first element greater than the value or <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()
  </clt></code> if all elements in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> are less than the specified value. This admittedly ugly formula guarantees that the return value will be <code>&gt;= 0</code> if and only if the search key is found. It's basically a hack to combine a boolean <code>(found)</code> and an integer <code>(index)</code> into a single <code>int</code> return value.</p> 
<p>The following idiom, usable with both forms of the <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> operation, looks for the specified search key and inserts it at the appropriate position if it's not already present.</p>","List","java.util.List","class","false"
"","","Searching - part 2","<h3>Searching - part 2</h3>
<p>The return value is the same for both forms. If the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> contains the search key, its index is returned. If not, the return value is <code>(-(insertion point) - 1)</code>, where the insertion point is the point at which the value would be inserted into the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, or the index of the first element greater than the value or <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()
  </clt></code> if all elements in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> are less than the specified value. This admittedly ugly formula guarantees that the return value will be <code>&gt;= 0</code> if and only if the search key is found. It's basically a hack to combine a boolean <code>(found)</code> and an integer <code>(index)</code> into a single <code>int</code> return value.</p> 
<p>The following idiom, usable with both forms of the <code> 
  <clt fqn=""java.util.Collections.binarySearch"" api=""Collections"" kind=""method"">
   Collections.binarySearch
  </clt></code> operation, looks for the specified search key and inserts it at the appropriate position if it's not already present.</p>","Collections","java.util.Collections.binarySearch","class","false"
"","","Composition","<h2>Composition</h2> 
<p>The frequency and disjoint algorithms test some aspect of the composition of one or more <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code>:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Collections.frequency"" api=""Collections"" kind=""method"">
    Collections.frequency
   </clt></code> ? counts the number of times the specified element occurs in the specified collection</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.disjoint"" api=""Collections"" kind=""method"">
    Collections.disjoint
   </clt></code> ? determines whether two <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> are disjoint; that is, whether they contain no elements in common</li> 
</ul>","Collections","java.util.Collections","class","false"
"","","Finding Extreme Values","<h2>Finding Extreme Values</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.min"" api=""Collections"" kind=""method"">
   Collections.min
  </clt></code> and the <code> 
  <clt fqn=""java.util.Collections.max"" api=""Collections"" kind=""method"">
   Collections.max
  </clt></code> algorithms return, respectively, the minimum and maximum element contained in a specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. Both of these operations come in two forms. The simple form takes only a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p>","Collections","java.util.Collections.min","class","false"
"","","Finding Extreme Values","<h2>Finding Extreme Values</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.min"" api=""Collections"" kind=""method"">
   Collections.min
  </clt></code> and the <code> 
  <clt fqn=""java.util.Collections.max"" api=""Collections"" kind=""method"">
   Collections.max
  </clt></code> algorithms return, respectively, the minimum and maximum element contained in a specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. Both of these operations come in two forms. The simple form takes only a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p>","Collection","java.util.Collection","class","false"
"","","Finding Extreme Values","<h2>Finding Extreme Values</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections.min"" api=""Collections"" kind=""method"">
   Collections.min
  </clt></code> and the <code> 
  <clt fqn=""java.util.Collections.max"" api=""Collections"" kind=""method"">
   Collections.max
  </clt></code> algorithms return, respectively, the minimum and maximum element contained in a specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. Both of these operations come in two forms. The simple form takes only a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in addition to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns the minimum (or maximum) element according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p>","Comparator","java.util.Comparator","class","false"
"","","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Write a program that prints its arguments in random order. Do not make a copy of the argument array.</li> 
 <li>Take the <a class=""SourceLink"" target=""_blank"" href=""../examples/FindDups.java"" onclick=""showCode('../../../displayCode.html', '../examples/FindDups.java'); return false;""><code>FindDups example</code></a> and modify it to use a <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> instead of a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>. Specify a <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> so that case is ignored when sorting and identifying set elements.</li> 
 <li>Write a method that takes a <code>List&lt;String&gt;</code> and applies <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()""><code> 
    <clt fqn=""java.lang.String.trim"" api=""String"" kind=""method"">
     String.String.trim
    </clt></code></a> to each element. To do this, you'll need to pick one of the three iteration idioms that you described in Question 1. Two of these will not give the result you want, so be sure to write a program that demonstrates that the method actually works!</li> 
</ol> 
<p> <a class=""TutorialLink"" target=""_top"" href=""answers.html"">Check your answers.</a></p>","SortedSet","java.util.SortedSet","class","false"
"","","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Write a program that prints its arguments in random order. Do not make a copy of the argument array.</li> 
 <li>Take the <a class=""SourceLink"" target=""_blank"" href=""../examples/FindDups.java"" onclick=""showCode('../../../displayCode.html', '../examples/FindDups.java'); return false;""><code>FindDups example</code></a> and modify it to use a <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> instead of a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>. Specify a <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> so that case is ignored when sorting and identifying set elements.</li> 
 <li>Write a method that takes a <code>List&lt;String&gt;</code> and applies <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()""><code> 
    <clt fqn=""java.lang.String.trim"" api=""String"" kind=""method"">
     String.String.trim
    </clt></code></a> to each element. To do this, you'll need to pick one of the three iteration idioms that you described in Question 1. Two of these will not give the result you want, so be sure to write a program that demonstrates that the method actually works!</li> 
</ol> 
<p> <a class=""TutorialLink"" target=""_top"" href=""answers.html"">Check your answers.</a></p>","Set","java.util.Set","class","false"
"","","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Write a program that prints its arguments in random order. Do not make a copy of the argument array.</li> 
 <li>Take the <a class=""SourceLink"" target=""_blank"" href=""../examples/FindDups.java"" onclick=""showCode('../../../displayCode.html', '../examples/FindDups.java'); return false;""><code>FindDups example</code></a> and modify it to use a <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> instead of a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>. Specify a <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> so that case is ignored when sorting and identifying set elements.</li> 
 <li>Write a method that takes a <code>List&lt;String&gt;</code> and applies <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()""><code> 
    <clt fqn=""java.lang.String.trim"" api=""String"" kind=""method"">
     String.String.trim
    </clt></code></a> to each element. To do this, you'll need to pick one of the three iteration idioms that you described in Question 1. Two of these will not give the result you want, so be sure to write a program that demonstrates that the method actually works!</li> 
</ol> 
<p> <a class=""TutorialLink"" target=""_top"" href=""answers.html"">Check your answers.</a></p>","Comparator","java.util.Comparator","class","false"
"","","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Write a program that prints its arguments in random order. Do not make a copy of the argument array.</li> 
 <li>Take the <a class=""SourceLink"" target=""_blank"" href=""../examples/FindDups.java"" onclick=""showCode('../../../displayCode.html', '../examples/FindDups.java'); return false;""><code>FindDups example</code></a> and modify it to use a <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> instead of a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>. Specify a <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> so that case is ignored when sorting and identifying set elements.</li> 
 <li>Write a method that takes a <code>List&lt;String&gt;</code> and applies <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()""><code> 
    <clt fqn=""java.lang.String.trim"" api=""String"" kind=""method"">
     String.String.trim
    </clt></code></a> to each element. To do this, you'll need to pick one of the three iteration idioms that you described in Question 1. Two of these will not give the result you want, so be sure to write a program that demonstrates that the method actually works!</li> 
</ol> 
<p> <a class=""TutorialLink"" target=""_top"" href=""answers.html"">Check your answers.</a></p>","String","java.lang.String.trim","class","false"
"","","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Write a program that prints its arguments in random order. Do not make a copy of the argument array.</li> 
 <li>Take the <a class=""SourceLink"" target=""_blank"" href=""../examples/FindDups.java"" onclick=""showCode('../../../displayCode.html', '../examples/FindDups.java'); return false;""><code>FindDups example</code></a> and modify it to use a <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> instead of a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>. Specify a <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> so that case is ignored when sorting and identifying set elements.</li> 
 <li>Write a method that takes a <code>List&lt;String&gt;</code> and applies <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()""><code> 
    <clt fqn=""java.lang.String.trim"" api=""String"" kind=""method"">
     String.String.trim
    </clt></code></a> to each element. To do this, you'll need to pick one of the three iteration idioms that you described in Question 1. Two of these will not give the result you want, so be sure to write a program that demonstrates that the method actually works!</li> 
</ol> 
<p> <a class=""TutorialLink"" target=""_top"" href=""answers.html"">Check your answers.</a></p>","ListIterator","java.util.ListIterator","class","false"
"","","Return Values","<h2>Return Values</h2> 
<p>You can afford to be much more flexible with return values than with input parameters. It's fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces.</p> 
<p>For example, one could imagine an image-processing package, called <code>ImageList</code>, that returned objects of a new class that implements <code>List</code>. In addition to the <code>List</code> operations, <code>ImageList</code> could support any application-specific operations that seemed desirable. For example, it might provide an <code>indexImage</code> operation that returned an image containing thumbnail images of each graphic in the <code>ImageList</code>. It's critical to note that even if the API furnishes <code>ImageList</code> instances on output, it should accept arbitrary <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> (or perhaps <code>List</code>) instances on input.</p>","Collection","java.util.Collection","class","false"
"","","Return Values - part 2","<h3>Return Values - part 2</h3>
<p>In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, you should give the relevant method the return type of <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> rather than <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> instances are more time-consuming to build than ordinary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances and are also more powerful. Given that your module has already invested the time to build a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, as well as those that accept any <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","SortedMap","java.util.SortedMap","class","false"
"","","Return Values - part 2","<h3>Return Values - part 2</h3>
<p>In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, you should give the relevant method the return type of <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> rather than <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> instances are more time-consuming to build than ordinary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances and are also more powerful. Given that your module has already invested the time to build a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, as well as those that accept any <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","Map","java.util.Map","class","false"
"","","How to Write a Custom Implementation","<h2>How to Write a Custom Implementation</h2> 
<p>Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a>.</p> 
<p>Believe it or not, this is very close to the implementation that is contained in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. It's that simple! You provide a constructor and the <code>get</code>, <code>set</code>, and <code>size</code> methods, and <code> 
  <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
    AbstractList 
  </clt></code> does all the rest. You get the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, bulk operations, search operations, hash code computation, comparison, and string representation for free.</p> 
<p>Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the <code>toArray</code> method iterates over the <code>List</code>, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.</p>","Arrays","java.util.Arrays.asList","class","false"
"","","How to Write a Custom Implementation","<h2>How to Write a Custom Implementation</h2> 
<p>Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a>.</p> 
<p>Believe it or not, this is very close to the implementation that is contained in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. It's that simple! You provide a constructor and the <code>get</code>, <code>set</code>, and <code>size</code> methods, and <code> 
  <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
    AbstractList 
  </clt></code> does all the rest. You get the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, bulk operations, search operations, hash code computation, comparison, and string representation for free.</p> 
<p>Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the <code>toArray</code> method iterates over the <code>List</code>, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.</p>","AbstractList","java.util.AbstractList","class","false"
"","","How to Write a Custom Implementation","<h2>How to Write a Custom Implementation</h2> 
<p>Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.Arrays.asList
   </clt></code></a>.</p> 
<p>Believe it or not, this is very close to the implementation that is contained in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. It's that simple! You provide a constructor and the <code>get</code>, <code>set</code>, and <code>size</code> methods, and <code> 
  <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
    AbstractList 
  </clt></code> does all the rest. You get the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, bulk operations, search operations, hash code computation, comparison, and string representation for free.</p> 
<p>Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the <code>toArray</code> method iterates over the <code>List</code>, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array.</p>","ListIterator","java.util.ListIterator","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Arrays","java.util.Arrays","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractCollection","java.util.AbstractCollection","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Collection","java.util.Collection","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Set","java.util.Set","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractSet","java.util.AbstractSet","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractList","java.util.AbstractList","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractSequentialList","java.util.AbstractSequentialList","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractQueue","java.util.AbstractQueue","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","AbstractMap","java.util.AbstractMap","class","false"
"","","How to Write a Custom Implementation - part 2","<h3>How to Write a Custom Implementation - part 2</h3>
<p>With the addition of this override and a few more like it, this implementation is exactly the one found in <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    java.util.Arrays 
  </clt></code>. In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult.</p> 
<p>The following list summarizes the abstract implementations:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html""><code> 
    <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
      AbstractCollection 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that is neither a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> nor a <code>List</code>. At a minimum, you must provide the <code>iterator</code> and the <code>size</code> methods.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.html""><code> 
    <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
      AbstractSet 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>; use is identical to <code> 
   <clt fqn=""java.util.AbstractCollection"" api=""AbstractCollection"" kind=""class"">
     AbstractCollection 
   </clt></code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html""><code> 
    <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
      AbstractList 
    </clt></code></a> ? a <code>List</code> backed up by a random-access data store, such as an array. At a minimum, you must provide the <code>positional access</code> methods (<code>get</code> and, optionally, <code>set</code>, <code>remove</code>, and <code>add</code>) and the <code>size</code> method. The abstract class takes care of <code>listIterator</code> (and <code>iterator</code>).</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html""><code> 
    <clt fqn=""java.util.AbstractSequentialList"" api=""AbstractSequentialList"" kind=""class"">
      AbstractSequentialList 
    </clt></code></a> ? a <code>List</code> backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the <code>listIterator</code> and <code>size</code> methods. The abstract class takes care of the positional access methods. (This is the opposite of <code> 
   <clt fqn=""java.util.AbstractList"" api=""AbstractList"" kind=""class"">
     AbstractList 
   </clt></code>.)</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html""><code> 
    <clt fqn=""java.util.AbstractQueue"" api=""AbstractQueue"" kind=""class"">
      AbstractQueue 
    </clt></code></a> ? at a minimum, you must provide the <code>offer</code>, <code>peek</code>, <code>poll</code>, and <code>size</code> methods and an <code>iterator</code> supporting <code>remove</code>.</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html""><code> 
    <clt fqn=""java.util.AbstractMap"" api=""AbstractMap"" kind=""class"">
      AbstractMap 
    </clt></code></a> ? a <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. At a minimum you must provide the <code>entrySet</code> view. This is typically implemented with the <code> 
   <clt fqn=""java.util.AbstractSet"" api=""AbstractSet"" kind=""class"">
     AbstractSet 
   </clt></code> class. If the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> is modifiable, you must also provide the <code>put</code> method.</li> 
</ul>","Map","java.util.Map","class","false"
"","","Collection Interface Bulk Operations","<h2>Collection Interface Bulk Operations</h2> 
<p><i>Bulk operations</i> perform an operation on an entire <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. You could implement these shorthand operations using the basic operations, though in most cases such implementations would be less efficient. The following are the bulk operations:</p> 
<ul> 
 <li><code>containsAll</code> ? returns <code>true</code> if the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> contains all of the elements in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>addAll</code> ? adds all of the elements in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> to the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>removeAll</code> ? removes from the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> all of its elements that are also contained in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>retainAll</code> ? removes from the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> all its elements that are <i>not</i> also contained in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>. That is, it retains only those elements in the target <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> that are also contained in the specified <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
 <li><code>clear</code> ? removes all elements from the <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code>.</li> 
</ul> 
<p>The <code>addAll</code>, <code>removeAll</code>, and <code>retainAll</code> methods all return <code>true</code> if the target <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> was modified in the process of executing the operation.</p>","Collection","java.util.Collection","class","false"
"","","Collection Interface Bulk Operations - part 2","<h3>Collection Interface Bulk Operations - part 2</h3>
<p>As a simple example of the power of bulk operations, consider the following idiom to remove <i>all</i> instances of a specified element, <code>e</code>, from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>.</p> 
<p>More specifically, suppose you want to remove all of the <code>null</code> elements from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>This idiom uses <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, which is a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> containing only the specified element. </p>","Collection","java.util.Collection","class","false"
"","","Collection Interface Bulk Operations - part 2","<h3>Collection Interface Bulk Operations - part 2</h3>
<p>As a simple example of the power of bulk operations, consider the following idiom to remove <i>all</i> instances of a specified element, <code>e</code>, from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>.</p> 
<p>More specifically, suppose you want to remove all of the <code>null</code> elements from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>This idiom uses <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, which is a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> containing only the specified element. </p>","Collections","java.util.Collections.singleton","class","false"
"","","Collection Interface Bulk Operations - part 2","<h3>Collection Interface Bulk Operations - part 2</h3>
<p>As a simple example of the power of bulk operations, consider the following idiom to remove <i>all</i> instances of a specified element, <code>e</code>, from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, <code>c</code>.</p> 
<p>More specifically, suppose you want to remove all of the <code>null</code> elements from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>This idiom uses <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, which is a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> containing only the specified element. </p>","Set","java.util.Set","class","false"
"","","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","Array","java.sql.Array","class","false"
"","","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","Collection","java.util.Collection","class","false"
"","","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","Object","java.lang.Object","class","false"
"","","Collection Interface Array Operations","<h2>Collection Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The <code>toArray</code> methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> to be translated into an array. The simple form with no arguments creates a new array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p> 
<p>For example, suppose that <code>c</code> is a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p> 
<p>Suppose that <code>c</code> is known to contain only strings (perhaps because <code>c</code> is of type <code>Collection&lt;String&gt;</code>). The following snippet dumps the contents of <code>c</code> into a newly allocated array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> whose length is identical to the number of elements in <code>c</code>.</p>","String","java.lang.String","class","false"
"","","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Collection","java.util.Collection","class","false"
"","","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Object","java.lang.Object","class","false"
"","","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","String","java.lang.String","class","false"
"","","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Vector","java.util.Vector","class","false"
"","","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface contains a <code>toArray</code> method designed expressly for this situation.</p> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code>toArray</code> ? the one that takes an array on input.</p> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p>","Hashtable","java.util.Hashtable","class","false"
"","","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Enumeration","java.util.Enumeration","class","false"
"","","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Collections","java.util.Collections","class","false"
"","","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p>","Collection","java.util.Collection","class","false"
"","","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Write a program that prints its arguments in random order. Do not make a copy of the argument array.</li> 
 <li>Take the <a class=""SourceLink"" target=""_blank"" href=""../examples/FindDups.java"" onclick=""showCode('../../../displayCode.html', '../examples/FindDups.java'); return false;""><code>FindDups example</code></a> and modify it to use a <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> instead of a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>. Specify a <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> so that case is ignored when sorting and identifying set elements.</li> 
 <li>Write a method that takes a <code>List&lt;String&gt;</code> and applies <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()""><code> 
    <clt fqn=""java.lang.String.trim"" api=""String"" kind=""method"">
     String.String.trim
    </clt></code></a> to each element. To do this, you'll need to pick one of the three iteration idioms that you described in Question 1. Two of these will not give the result you want, so be sure to write a program that demonstrates that the method actually works!</li> 
</ol> 
<p> <a class=""TutorialLink"" target=""_top"" href=""answers.html"">Check your answers.</a></p>","File","java.io.File.length","class","false"
"","","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Write a program that prints its arguments in random order. Do not make a copy of the argument array.</li> 
 <li>Take the <a class=""SourceLink"" target=""_blank"" href=""../examples/FindDups.java"" onclick=""showCode('../../../displayCode.html', '../examples/FindDups.java'); return false;""><code>FindDups example</code></a> and modify it to use a <code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code> instead of a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>. Specify a <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> so that case is ignored when sorting and identifying set elements.</li> 
 <li>Write a method that takes a <code>List&lt;String&gt;</code> and applies <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#trim()""><code> 
    <clt fqn=""java.lang.String.trim"" api=""String"" kind=""method"">
     String.String.trim
    </clt></code></a> to each element. To do this, you'll need to pick one of the three iteration idioms that you described in Question 1. Two of these will not give the result you want, so be sure to write a program that demonstrates that the method actually works!</li> 
</ol> 
<p> <a class=""TutorialLink"" target=""_top"" href=""answers.html"">Check your answers.</a></p>","ArrayList","java.util.ArrayList","class","false"
"","","Immutable Multiple-Copy List","<h2>Immutable Multiple-Copy List</h2> 
<p>Occasionally you'll need an immutable <code>List</code> consisting of multiple copies of the same element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#nCopies(int,%20T)""><code> 
   <clt fqn=""java.util.Collections.nCopies"" api=""Collections"" kind=""method"">
    Collections.Collections.nCopies
   </clt></code></a> method returns such a list. This implementation has two main uses. The first is to initialize a newly created <code>List</code>; for example, suppose you want an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> initially consisting of 1,000 <code>null</code> elements. The following incantation does the trick.</p> 
<p>Of course, the initial value of each element need not be <code>null</code>. The second main use is to grow an existing <code>List</code>. For example, suppose you want to add 69 copies of the string <code>&quot;fruit bat&quot;</code> to the end of a <code>List&lt;String&gt;</code>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it.</p> 
<p>By using the form of <code>addAll</code> that takes both an index and a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, you can add the new elements to the middle of a <code>List</code> instead of to the end of it.</p>","Collections","java.util.Collections.nCopies","class","false"
"","","Immutable Multiple-Copy List","<h2>Immutable Multiple-Copy List</h2> 
<p>Occasionally you'll need an immutable <code>List</code> consisting of multiple copies of the same element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#nCopies(int,%20T)""><code> 
   <clt fqn=""java.util.Collections.nCopies"" api=""Collections"" kind=""method"">
    Collections.Collections.nCopies
   </clt></code></a> method returns such a list. This implementation has two main uses. The first is to initialize a newly created <code>List</code>; for example, suppose you want an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> initially consisting of 1,000 <code>null</code> elements. The following incantation does the trick.</p> 
<p>Of course, the initial value of each element need not be <code>null</code>. The second main use is to grow an existing <code>List</code>. For example, suppose you want to add 69 copies of the string <code>&quot;fruit bat&quot;</code> to the end of a <code>List&lt;String&gt;</code>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it.</p> 
<p>By using the form of <code>addAll</code> that takes both an index and a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, you can add the new elements to the middle of a <code>List</code> instead of to the end of it.</p>","ArrayList","java.util.ArrayList","class","false"
"","","Immutable Multiple-Copy List","<h2>Immutable Multiple-Copy List</h2> 
<p>Occasionally you'll need an immutable <code>List</code> consisting of multiple copies of the same element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#nCopies(int,%20T)""><code> 
   <clt fqn=""java.util.Collections.nCopies"" api=""Collections"" kind=""method"">
    Collections.Collections.nCopies
   </clt></code></a> method returns such a list. This implementation has two main uses. The first is to initialize a newly created <code>List</code>; for example, suppose you want an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> initially consisting of 1,000 <code>null</code> elements. The following incantation does the trick.</p> 
<p>Of course, the initial value of each element need not be <code>null</code>. The second main use is to grow an existing <code>List</code>. For example, suppose you want to add 69 copies of the string <code>&quot;fruit bat&quot;</code> to the end of a <code>List&lt;String&gt;</code>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it.</p> 
<p>By using the form of <code>addAll</code> that takes both an index and a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, you can add the new elements to the middle of a <code>List</code> instead of to the end of it.</p>","Collection","java.util.Collection","class","false"
"","","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Set","java.util.Set","class","false"
"","","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Collections","java.util.Collections.singleton","class","false"
"","","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Collection","java.util.Collection","class","false"
"","","Immutable Singleton Set","<h2>Immutable Singleton Set</h2> 
<p>Sometimes you'll need an immutable <i>singleton</i> <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, which consists of a single, specified element. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#singleton(T)""><code> 
   <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
    Collections.Collections.singleton
   </clt></code></a> method returns such a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. One use of this implementation is to remove all occurrences of a specified element from a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<p>A related idiom removes all elements that map to a specified value from a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <code>job</code> ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p> 
<p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p>","Map","java.util.Map","class","false"
"","","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Set","java.util.Set","class","false"
"","","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","List","java.util.List","class","false"
"","","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Map","java.util.Map","class","false"
"","","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Collections","java.util.Collections","class","false"
"","","Empty Set List and Map Constants","<h2>Empty 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt> 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt> and 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Constants</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class provides methods to return the empty <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, <code>List</code>, and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptySet()""><code> 
   <clt fqn=""java.util.Collections.emptySet"" api=""Collections"" kind=""method"">
    Collections.emptySet
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyList()""><code> 
   <clt fqn=""java.util.Collections.emptyList"" api=""Collections"" kind=""method"">
    Collections.emptyList
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#emptyMap()""><code> 
   <clt fqn=""java.util.Collections.emptyMap"" api=""Collections"" kind=""method"">
    Collections.emptyMap
   </clt></code></a>. The main use of these constants is as input to methods that take a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> of values when you don't want to provide any values at all, as in this example.</p>","Collection","java.util.Collection","class","false"
"","","Concurrent Deque Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingDeque.html""><code> 
   <clt fqn=""java.util.concurrent.LinkedBlockingDeque"" api=""LinkedBlockingDeque"" kind=""class"">
     LinkedBlockingDeque 
   </clt></code></a> class is the concurrent implementation of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. If the deque is empty then methods such as <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeFirst"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeFirst
  </clt></code> and <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeLast"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeLast
  </clt></code> wait until the element becomes available, and then retrieves and removes the same element. </p>","Deque","java.util.Deque","class","false"
"","","Concurrent Deque Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingDeque.html""><code> 
   <clt fqn=""java.util.concurrent.LinkedBlockingDeque"" api=""LinkedBlockingDeque"" kind=""class"">
     LinkedBlockingDeque 
   </clt></code></a> class is the concurrent implementation of the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. If the deque is empty then methods such as <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeFirst"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeFirst
  </clt></code> and <code> 
  <clt fqn=""java.util.concurrent.LinkedBlockingDeque.takeLast"" api=""LinkedBlockingDeque"" kind=""method"">
   LinkedBlockingDeque.takeLast
  </clt></code> wait until the element becomes available, and then retrieves and removes the same element. </p>","LinkedBlockingDeque","java.util.concurrent.LinkedBlockingDeque","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","List","java.util.List","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","CopyOnWriteArrayList","java.util.concurrent.CopyOnWriteArrayList","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","CopyOnWriteArraySet","java.util.concurrent.CopyOnWriteArraySet","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","ConcurrentModificationException","java.util.ConcurrentModificationException","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","Vector","java.util.Vector","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","ArrayList","java.util.ArrayList","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","Collections","java.util.Collections","class","false"
"","","Special-Purpose List Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Implementations</h2> 
<p> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArrayList"" api=""CopyOnWriteArrayList"" kind=""class"">
     CopyOnWriteArrayList 
   </clt></code></a> is a <code>List</code> implementation backed up by a copy-on-write array. This implementation is similar in nature to <code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code>. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw <code> 
  <clt fqn=""java.util.ConcurrentModificationException"" api=""ConcurrentModificationException"" kind=""class"">
    ConcurrentModificationException 
  </clt></code>. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p> 
<p>If you need synchronization, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> will be slightly faster than an <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> synchronized with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.synchronizedList 
  </clt></code>. But <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> has loads of legacy operations, so be careful to always manipulate the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> with the <code>List</code> interface or else you won't be able to replace the implementation at a later time.</p> 
<p>If your <code>List</code> is fixed in size ? that is, you'll never use <code>remove</code>, <code>add</code>, or any of the bulk operations other than <code>containsAll</code> ? you have a third option that's definitely worth considering. See <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> in the <a class=""TutorialLink"" target=""_top"" href=""convenience.html"">Convenience Implementations</a> section for more information.</p>","Arrays","java.util.Arrays.asList","class","false"
"","","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","Map","java.util.Map","class","false"
"","","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","EnumMap","java.util.EnumMap","class","false"
"","","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","WeakHashMap","java.util.WeakHashMap","class","false"
"","","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","IdentityHashMap","java.util.IdentityHashMap","class","false"
"","","Special-Purpose Map Implementations - part 2","<h3>Special-Purpose Map Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> is an identity-based <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based &quot;node table&quot; that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting &quot;spoof attacks&quot; that are a result of intentionally perverse <code>equals</code> methods because <code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> never invokes the <code>equals</code> method on its keys. An added benefit of this implementation is that it is fast.</p>","IdentityHashMap","java.util.IdentityHashMap","class","false"
"","","Special-Purpose Map Implementations - part 2","<h3>Special-Purpose Map Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> is an identity-based <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based &quot;node table&quot; that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting &quot;spoof attacks&quot; that are a result of intentionally perverse <code>equals</code> methods because <code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> never invokes the <code>equals</code> method on its keys. An added benefit of this implementation is that it is fast.</p>","Map","java.util.Map","class","false"
"","","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","Map","java.util.Map","class","false"
"","","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","ConcurrentMap","java.util.concurrent.ConcurrentMap","class","false"
"","","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","ConcurrentHashMap","java.util.concurrent.ConcurrentHashMap","class","false"
"","","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","Hashtable","java.util.Hashtable","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","Queue","java.awt.Queue","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","BlockingQueue","java.util.concurrent.BlockingQueue","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","LinkedBlockingQueue","java.util.concurrent.LinkedBlockingQueue","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","ArrayBlockingQueue","java.util.concurrent.ArrayBlockingQueue","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","PriorityBlockingQueue","java.util.concurrent.PriorityBlockingQueue","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","DelayQueue","java.util.concurrent.DelayQueue","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","SynchronousQueue","java.util.concurrent.SynchronousQueue","class","false"
"","","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
    BlockingQueue 
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
    TransferQueue 
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","TransferQueue","java.util.concurrent.SynchronousQueue.TransferQueue","class","false"
"","","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","Set","java.util.Set","class","false"
"","","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","EnumSet","java.util.EnumSet","class","false"
"","","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","CopyOnWriteArraySet","java.util.concurrent.CopyOnWriteArraySet","class","false"
"","","Unmodifiable Wrappers","<h2>Unmodifiable Wrappers</h2> 
<p>Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code>. Unmodifiable wrappers have two main uses, as follows:</p> 
<ul> 
 <li>To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.</li> 
 <li>To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.</li> 
</ul> 
<p>Like synchronization wrappers, each of the six core <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces has one static factory method.</p>","UnsupportedOperationException","java.lang.UnsupportedOperationException","class","false"
"","","Unmodifiable Wrappers","<h2>Unmodifiable Wrappers</h2> 
<p>Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code>. Unmodifiable wrappers have two main uses, as follows:</p> 
<ul> 
 <li>To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.</li> 
 <li>To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.</li> 
</ul> 
<p>Like synchronization wrappers, each of the six core <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces has one static factory method.</p>","Collection","java.util.Collection","class","false"
"","","Checked Interface Wrappers","<h2>Checked Interface Wrappers</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.checked 
  </clt></code> <em>interface</em> wrappers are provided for use with generic collections. These implementations return a <em>dynamically</em> type-safe view of the specified collection, which throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.</p>","Collections","java.util.Collections","class","false"
"","","Checked Interface Wrappers","<h2>Checked Interface Wrappers</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.checked 
  </clt></code> <em>interface</em> wrappers are provided for use with generic collections. These implementations return a <em>dynamically</em> type-safe view of the specified collection, which throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.</p>","ClassCastException","java.lang.ClassCastException","class","false"
"","","Benefits of the Java Collections Framework","<h2>Benefits of the Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Framework</h2> 
<p>The Java Collections Framework provides the following benefits:</p> 
<ul> 
 <li><b>Reduces programming effort:</b> By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level &quot;plumbing&quot; required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs.</li> 
 <li><b>Increases program speed and quality:</b> This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you're freed from the drudgery of writing your own data structures, you'll have more time to devote to improving programs' quality and performance.</li> 
 <li><b>Allows interoperability among unrelated APIs:</b> The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently.</li> 
 <li><b>Reduces effort to learn and to use new APIs:</b> Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away.</li> 
 <li><b>Reduces effort to design new APIs:</b> This is the flip side of the previous advantage. Designers and implementers don't have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces.</li> 
 <li><b>Fosters software reuse:</b> New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.</li> 
</ul>","Collections","java.util.Collections","class","false"
"","","Collection Operations","<h2>Collection Operations</h2> 
<p>The operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> all do about what you'd expect them to do, assuming you're already familiar with them. If you're not familiar with them from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, now would be a good time to read <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section. The <code>remove</code> operation always removes <i>the first</i> occurrence of the specified element from the list. The <code>add</code> and <code>addAll</code> operations always append the new element(s) to the <i>end</i> of the list. Thus, the following idiom concatenates one list to another.</p> 
<p>Here's a nondestructive form of this idiom, which produces a third <code>List</code> consisting of the second list appended to the first.</p> 
<p>Note that the idiom, in its nondestructive form, takes advantage of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s standard conversion constructor.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> interface, <code>List</code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code>List</code> objects can be compared for logical equality without regard to their implementation classes. Two <code>List</code> objects are equal if they contain the same elements in the same order.</p>","Collection","java.util.Collection","class","false"
"","","Collection Operations","<h2>Collection Operations</h2> 
<p>The operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> all do about what you'd expect them to do, assuming you're already familiar with them. If you're not familiar with them from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, now would be a good time to read <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section. The <code>remove</code> operation always removes <i>the first</i> occurrence of the specified element from the list. The <code>add</code> and <code>addAll</code> operations always append the new element(s) to the <i>end</i> of the list. Thus, the following idiom concatenates one list to another.</p> 
<p>Here's a nondestructive form of this idiom, which produces a third <code>List</code> consisting of the second list appended to the first.</p> 
<p>Note that the idiom, in its nondestructive form, takes advantage of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s standard conversion constructor.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> interface, <code>List</code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code>List</code> objects can be compared for logical equality without regard to their implementation classes. Two <code>List</code> objects are equal if they contain the same elements in the same order.</p>","ArrayList","java.util.ArrayList","class","false"
"","","Collection Operations","<h2>Collection Operations</h2> 
<p>The operations inherited from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> all do about what you'd expect them to do, assuming you're already familiar with them. If you're not familiar with them from <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, now would be a good time to read <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section. The <code>remove</code> operation always removes <i>the first</i> occurrence of the specified element from the list. The <code>add</code> and <code>addAll</code> operations always append the new element(s) to the <i>end</i> of the list. Thus, the following idiom concatenates one list to another.</p> 
<p>Here's a nondestructive form of this idiom, which produces a third <code>List</code> consisting of the second list appended to the first.</p> 
<p>Note that the idiom, in its nondestructive form, takes advantage of <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s standard conversion constructor.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> interface, <code>List</code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code>List</code> objects can be compared for logical equality without regard to their implementation classes. Two <code>List</code> objects are equal if they contain the same elements in the same order.</p>","Set","java.util.Set","class","false"
"","","Positional Access and Search Operations","<h2>Positional Access and Search Operations</h2> 
<p>The basic <code>positional access</code> operations (<code> 
  <clt fqn=""java.util.Vector.get"" api=""Vector"" kind=""method"">
   Vector.get
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code>, <code>add</code> and <code>remove</code>) behave just like their longer-named counterparts in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> (<code> 
  <clt fqn=""java.util.Vector.elementAt"" api=""Vector"" kind=""method"">
   Vector.elementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.insertElementAt"" api=""Vector"" kind=""method"">
   Vector.insertElementAt
  </clt></code>, and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) with one noteworthy exception: The <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code> and <code>remove</code> operations return the old value that is being overwritten or removed; the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> counterparts (<code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code> and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) return nothing (<code>void</code>). The <code> 
  <clt fqn=""java.util.Stack.search"" api=""Stack"" kind=""method"">
   Stack.search
  </clt></code> operations <code>indexOf</code> and <code>lastIndexOf</code> behave exactly like the identically named operations in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>.</p> 
<p>The <code>addAll</code> operation inserts all the elements of the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> starting at the specified position. The elements are inserted in the order they are returned by the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s iterator. This call is the positional access analog of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s <code>addAll</code> operation.</p> 
<p>Here's a little method to swap two indexed values in a <code>List</code>. It should look familiar from Programming 101.</p>","Vector","java.util.Vector.get","class","false"
"","","Positional Access and Search Operations","<h2>Positional Access and Search Operations</h2> 
<p>The basic <code>positional access</code> operations (<code> 
  <clt fqn=""java.util.Vector.get"" api=""Vector"" kind=""method"">
   Vector.get
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code>, <code>add</code> and <code>remove</code>) behave just like their longer-named counterparts in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> (<code> 
  <clt fqn=""java.util.Vector.elementAt"" api=""Vector"" kind=""method"">
   Vector.elementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.insertElementAt"" api=""Vector"" kind=""method"">
   Vector.insertElementAt
  </clt></code>, and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) with one noteworthy exception: The <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code> and <code>remove</code> operations return the old value that is being overwritten or removed; the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> counterparts (<code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code> and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) return nothing (<code>void</code>). The <code> 
  <clt fqn=""java.util.Stack.search"" api=""Stack"" kind=""method"">
   Stack.search
  </clt></code> operations <code>indexOf</code> and <code>lastIndexOf</code> behave exactly like the identically named operations in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>.</p> 
<p>The <code>addAll</code> operation inserts all the elements of the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> starting at the specified position. The elements are inserted in the order they are returned by the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s iterator. This call is the positional access analog of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s <code>addAll</code> operation.</p> 
<p>Here's a little method to swap two indexed values in a <code>List</code>. It should look familiar from Programming 101.</p>","Stack","java.util.Stack.search","class","false"
"","","Positional Access and Search Operations","<h2>Positional Access and Search Operations</h2> 
<p>The basic <code>positional access</code> operations (<code> 
  <clt fqn=""java.util.Vector.get"" api=""Vector"" kind=""method"">
   Vector.get
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code>, <code>add</code> and <code>remove</code>) behave just like their longer-named counterparts in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> (<code> 
  <clt fqn=""java.util.Vector.elementAt"" api=""Vector"" kind=""method"">
   Vector.elementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code>, <code> 
  <clt fqn=""java.util.Vector.insertElementAt"" api=""Vector"" kind=""method"">
   Vector.insertElementAt
  </clt></code>, and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) with one noteworthy exception: The <code> 
  <clt fqn=""java.util.Vector.set"" api=""Vector"" kind=""method"">
   Vector.set
  </clt></code> and <code>remove</code> operations return the old value that is being overwritten or removed; the <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> counterparts (<code> 
  <clt fqn=""java.util.Vector.setElementAt"" api=""Vector"" kind=""method"">
   Vector.setElementAt
  </clt></code> and <code> 
  <clt fqn=""java.util.Vector.removeElementAt"" api=""Vector"" kind=""method"">
   Vector.removeElementAt
  </clt></code>) return nothing (<code>void</code>). The <code> 
  <clt fqn=""java.util.Stack.search"" api=""Stack"" kind=""method"">
   Stack.search
  </clt></code> operations <code>indexOf</code> and <code>lastIndexOf</code> behave exactly like the identically named operations in <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>.</p> 
<p>The <code>addAll</code> operation inserts all the elements of the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> starting at the specified position. The elements are inserted in the order they are returned by the specified <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s iterator. This call is the positional access analog of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s <code>addAll</code> operation.</p> 
<p>Here's a little method to swap two indexed values in a <code>List</code>. It should look familiar from Programming 101.</p>","Collection","java.util.Collection","class","false"
"","","Positional Access and Search Operations - part 2","<h3>Positional Access and Search Operations - part 2</h3>
<p><a name=""shuffle"" id=""shuffle"">Of course, there's one big difference.</a> This is a polymorphic algorithm: It swaps two elements in any <code>List</code>, regardless of its implementation type. Here's another polymorphic algorithm that uses the preceding <code> 
  <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
   Collections.swap
  </clt></code> method.</p> 
<p>This algorithm, which is included in the Java platform's <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, randomly permutes the specified list using the specified source of randomness. It's a bit subtle: It runs up the list from the bottom, repeatedly swapping a randomly selected element into the current position. Unlike most naive attempts at shuffling, it's <i>fair</i> (all permutations occur with equal likelihood, assuming an unbiased source of randomness) and <i>fast</i> (requiring exactly <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()-1
  </clt></code> swaps). The following program uses this algorithm to print the words in its argument list in random order.</p>","Collections","java.util.Collections.swap","class","false"
"","","Positional Access and Search Operations - part 2","<h3>Positional Access and Search Operations - part 2</h3>
<p><a name=""shuffle"" id=""shuffle"">Of course, there's one big difference.</a> This is a polymorphic algorithm: It swaps two elements in any <code>List</code>, regardless of its implementation type. Here's another polymorphic algorithm that uses the preceding <code> 
  <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
   Collections.swap
  </clt></code> method.</p> 
<p>This algorithm, which is included in the Java platform's <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, randomly permutes the specified list using the specified source of randomness. It's a bit subtle: It runs up the list from the bottom, repeatedly swapping a randomly selected element into the current position. Unlike most naive attempts at shuffling, it's <i>fair</i> (all permutations occur with equal likelihood, assuming an unbiased source of randomness) and <i>fast</i> (requiring exactly <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()-1
  </clt></code> swaps). The following program uses this algorithm to print the words in its argument list in random order.</p>","List","java.util.List.size","class","false"
"","","Positional Access and Search Operations - part 3","<h3>Positional Access and Search Operations - part 3</h3>
<p>In fact, this program can be made even shorter and faster. The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html""><code> 
   <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
     Arrays 
   </clt></code></a> class has a static factory method called <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.asList
  </clt></code>, which allows an array to be viewed as a <code>List</code>. This method does not copy the array. Changes in the <code>List</code> write through to the array and vice versa. The resulting List is not a general-purpose <code>List</code> implementation, because it doesn't implement the (optional) <code>add</code> and <code>remove</code> operations: Arrays are not resizable. Taking advantage of <code> 
  <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
   Arrays.Arrays.asList
  </clt></code> and calling the library version of <code>shuffle</code>, which uses a default source of randomness, you get the following <a class=""SourceLink"" target=""_blank"" href=""examples/Shuffle.java"" onclick=""showCode('../../displayCode.html', 'examples/Shuffle.java'); return false;""><code>tiny program</code></a> whose behavior is identical to the previous program.</p>","Arrays","java.util.Arrays","class","false"
"","","Iterators","<h2><a name=""Iterator"" id=""Iterator"">Iterators</a></h2> 
<p>As you'd expect, the <code>Iterator</code> returned by <code>List</code>'s <code>iterator</code> operation returns the elements of the list in proper sequence. <code>List</code> also provides a richer iterator, called a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, which allows you to traverse the list in either direction, modify the list during iteration, and obtain the current position of the iterator. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface follows.</p> 
<p>The three methods that <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> inherits from <code>Iterator</code> (<code> 
  <clt fqn=""java.util.ListIterator.hasNext"" api=""ListIterator"" kind=""method"">
   ListIterator.hasNext
  </clt></code>, <code>next</code>, and <code>remove</code>) do exactly the same thing in both interfaces. The <code> 
  <clt fqn=""java.util.ListIterator.hasPrevious"" api=""ListIterator"" kind=""method"">
   ListIterator.hasPrevious
  </clt></code> and the <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> operations are exact analogues of <code> 
  <clt fqn=""java.util.ListIterator.hasNext"" api=""ListIterator"" kind=""method"">
   ListIterator.hasNext
  </clt></code> and <code>next</code>. The former operations refer to the element before the (implicit) cursor, whereas the latter refer to the element after the cursor. The <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> operation moves the cursor backward, whereas <code>next</code> moves it forward.</p> 
<p>Here's the standard idiom for iterating backward through a list.</p>","ListIterator","java.util.ListIterator","class","false"
"","","Iterators - part 2","<h3>Iterators - part 2</h3>
<p>Note the argument to <code>listIterator</code> in the preceding idiom. The <code>List</code> interface has two forms of the <code>listIterator</code> method. The form with no arguments returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the beginning of the list; the form with an <code>int</code> argument returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the specified index. The index refers to the element that would be returned by an initial call to <code>next</code>. An initial call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> would return the element whose index was <code>index-1</code>. In a list of length <code>n</code>, there are <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid values for <code>index</code>, from <code>0</code> to <code>n</code>, inclusive.</p> 
<p>Intuitively speaking, the cursor is always between two elements ? the one that would be returned by a call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> and the one that would be returned by a call to <code>next</code>. The <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid <code>index</code> values correspond to the <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> gaps between elements, from the gap before the first element to the gap after the last one. <span id=""figure:colls-fivePossibleCursor.gif"">The following figure</span> shows the five possible cursor positions in a list containing four elements.</p>","ListIterator","java.util.ListIterator","class","false"
"","","Iterators - part 2","<h3>Iterators - part 2</h3>
<p>Note the argument to <code>listIterator</code> in the preceding idiom. The <code>List</code> interface has two forms of the <code>listIterator</code> method. The form with no arguments returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the beginning of the list; the form with an <code>int</code> argument returns a <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> positioned at the specified index. The index refers to the element that would be returned by an initial call to <code>next</code>. An initial call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> would return the element whose index was <code>index-1</code>. In a list of length <code>n</code>, there are <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid values for <code>index</code>, from <code>0</code> to <code>n</code>, inclusive.</p> 
<p>Intuitively speaking, the cursor is always between two elements ? the one that would be returned by a call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> and the one that would be returned by a call to <code>next</code>. The <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> valid <code>index</code> values correspond to the <code> 
  <clt fqn=""java.util.Collections.CopiesList.n"" api=""CopiesList"" kind=""field"">
   CopiesList.n+1
  </clt></code> gaps between elements, from the gap before the first element to the gap after the last one. <span id=""figure:colls-fivePossibleCursor.gif"">The following figure</span> shows the five possible cursor positions in a list containing four elements.</p>","CopiesList","java.util.Collections.CopiesList.n","class","false"
"","","Iterators - part 3","<h3>Iterators - part 3</h3>
<center> 
 <p class=""FigureCaption"">The five possible cursor positions.</p> 
</center> 
<p>Calls to <code>next</code> and <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> can be intermixed, but you have to be a bit careful. The first call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> returns the same element as the last call to <code>next</code>. Similarly, the first call to <code>next</code> after a sequence of calls to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> returns the same element as the last call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>.</p> 
<p>It should come as no surprise that the <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> method returns the index of the element that would be returned by a subsequent call to <code>next</code>, and <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code> returns the index of the element that would be returned by a subsequent call to <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. These calls are typically used either to report the position where something was found or to record the position of the <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> so that another <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> with identical position can be created.</p>","ListIterator","java.util.ListIterator.previous","class","false"
"","","Iterators - part 4","<h3>Iterators - part 4</h3>
<p>It should also come as no surprise that the number returned by <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> is always one greater than the number returned by <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code>. This implies the behavior of the two boundary cases: (1) a call to <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code> when the cursor is before the initial element returns <code>-1</code> and (2) a call to <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> when the cursor is after the final element returns <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()
  </clt></code>. To make all this concrete, the following is a possible implementation of <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.List.indexOf
  </clt></code>.</p> 
<p>Note that the <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.indexOf
  </clt></code> method returns <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.previousIndex()
  </clt></code> even though it is traversing the list in the forward direction. The reason is that <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.nextIndex()
  </clt></code> would return the index of the element we are about to examine, and we want to return the index of the element we just examined.</p>","ListIterator","java.util.ListIterator.nextIndex","class","false"
"","","Iterators - part 4","<h3>Iterators - part 4</h3>
<p>It should also come as no surprise that the number returned by <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> is always one greater than the number returned by <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code>. This implies the behavior of the two boundary cases: (1) a call to <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.previousIndex
  </clt></code> when the cursor is before the initial element returns <code>-1</code> and (2) a call to <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   ListIterator.nextIndex
  </clt></code> when the cursor is after the final element returns <code> 
  <clt fqn=""java.util.List.size"" api=""List"" kind=""method"">
   list.List.size()
  </clt></code>. To make all this concrete, the following is a possible implementation of <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.List.indexOf
  </clt></code>.</p> 
<p>Note that the <code> 
  <clt fqn=""java.util.List.indexOf"" api=""List"" kind=""method"">
   List.indexOf
  </clt></code> method returns <code> 
  <clt fqn=""java.util.ListIterator.previousIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.previousIndex()
  </clt></code> even though it is traversing the list in the forward direction. The reason is that <code> 
  <clt fqn=""java.util.ListIterator.nextIndex"" api=""ListIterator"" kind=""method"">
   it.ListIterator.nextIndex()
  </clt></code> would return the index of the element we are about to examine, and we want to return the index of the element we just examined.</p>","List","java.util.List.size","class","false"
"","","Iterators - part 5","<h3>Iterators - part 5</h3>
<p>The <code>Iterator</code> interface provides the <code>remove</code> operation to remove the last element returned by <code>next</code> from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. For <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, this operation removes the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface provides two additional operations to modify the list ? <code>set</code> and <code>add</code>. The <code>set</code> method overwrites the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> with the specified element. The following polymorphic algorithm uses <code>set</code> to replace all occurrences of one specified value with another.</p> 
<p>The only bit of trickiness in this example is the equality test between <code>val</code> and <code>it.next</code>. You need to special-case a <code>val</code> value of <code>null</code> to prevent a <code> 
  <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
    NullPointerException 
  </clt></code>.</p> 
<p>The <code>add</code> method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list.</p>","Collection","java.util.Collection","class","false"
"","","Iterators - part 5","<h3>Iterators - part 5</h3>
<p>The <code>Iterator</code> interface provides the <code>remove</code> operation to remove the last element returned by <code>next</code> from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. For <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, this operation removes the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface provides two additional operations to modify the list ? <code>set</code> and <code>add</code>. The <code>set</code> method overwrites the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> with the specified element. The following polymorphic algorithm uses <code>set</code> to replace all occurrences of one specified value with another.</p> 
<p>The only bit of trickiness in this example is the equality test between <code>val</code> and <code>it.next</code>. You need to special-case a <code>val</code> value of <code>null</code> to prevent a <code> 
  <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
    NullPointerException 
  </clt></code>.</p> 
<p>The <code>add</code> method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list.</p>","ListIterator","java.util.ListIterator","class","false"
"","","Iterators - part 5","<h3>Iterators - part 5</h3>
<p>The <code>Iterator</code> interface provides the <code>remove</code> operation to remove the last element returned by <code>next</code> from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. For <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code>, this operation removes the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code>. The <code> 
  <clt fqn=""java.util.ListIterator"" api=""ListIterator"" kind=""class"">
    ListIterator 
  </clt></code> interface provides two additional operations to modify the list ? <code>set</code> and <code>add</code>. The <code>set</code> method overwrites the last element returned by <code>next</code> or <code> 
  <clt fqn=""java.util.ListIterator.previous"" api=""ListIterator"" kind=""method"">
   ListIterator.previous
  </clt></code> with the specified element. The following polymorphic algorithm uses <code>set</code> to replace all occurrences of one specified value with another.</p> 
<p>The only bit of trickiness in this example is the equality test between <code>val</code> and <code>it.next</code>. You need to special-case a <code>val</code> value of <code>null</code> to prevent a <code> 
  <clt fqn=""java.lang.NullPointerException"" api=""NullPointerException"" kind=""class"">
    NullPointerException 
  </clt></code>.</p> 
<p>The <code>add</code> method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list.</p>","NullPointerException","java.lang.NullPointerException","class","false"
"","","Range-View Operation - part 2","<h3>Range-View Operation - part 2</h3>
<p>Any polymorphic algorithm that operates on a <code>List</code>, such as the <code>replace</code> and <code>shuffle</code> examples, works with the <code>List</code> returned by <code>subList</code>.</p> 
<p>Here's a polymorphic algorithm whose implementation uses <code>subList</code> to deal a hand from a deck. That is, it returns a new <code>List</code> (the &quot;hand&quot;) containing the specified number of elements taken from the end of the specified <code>List</code> (the &quot;deck&quot;). The elements returned in the hand are removed from the deck.</p> 
<p>Note that this algorithm removes the hand from the <i>end</i> of the deck. For many common <code>List</code> implementations, such as <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, the performance of removing elements from the end of the list is substantially better than that of removing elements from the beginning.</p> 
<p>The following is <a class=""SourceLink"" target=""_blank"" href=""examples/Deal.java"" onclick=""showCode('../../displayCode.html', 'examples/Deal.java'); return false;""><code>a program</code></a> that uses the <code>dealHand</code> method in combination with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.shuffle 
  </clt></code> to generate hands from a normal 52-card deck. The program takes two command-line arguments: (1) the number of hands to deal and (2) the number of cards in each hand.</p>","ArrayList","java.util.ArrayList","class","false"
"","","Range-View Operation - part 2","<h3>Range-View Operation - part 2</h3>
<p>Any polymorphic algorithm that operates on a <code>List</code>, such as the <code>replace</code> and <code>shuffle</code> examples, works with the <code>List</code> returned by <code>subList</code>.</p> 
<p>Here's a polymorphic algorithm whose implementation uses <code>subList</code> to deal a hand from a deck. That is, it returns a new <code>List</code> (the &quot;hand&quot;) containing the specified number of elements taken from the end of the specified <code>List</code> (the &quot;deck&quot;). The elements returned in the hand are removed from the deck.</p> 
<p>Note that this algorithm removes the hand from the <i>end</i> of the deck. For many common <code>List</code> implementations, such as <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>, the performance of removing elements from the end of the list is substantially better than that of removing elements from the beginning.</p> 
<p>The following is <a class=""SourceLink"" target=""_blank"" href=""examples/Deal.java"" onclick=""showCode('../../displayCode.html', 'examples/Deal.java'); return false;""><code>a program</code></a> that uses the <code>dealHand</code> method in combination with <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.shuffle 
  </clt></code> to generate hands from a normal 52-card deck. The program takes two command-line arguments: (1) the number of hands to deal and (2) the number of cards in each hand.</p>","Collections","java.util.Collections","class","false"
"","","List Algorithms","<h2>List Algorithms</h2> 
<p>Most polymorphic algorithms in the <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class apply specifically to <code>List</code>. Having all these algorithms at your disposal makes it very easy to manipulate lists. Here's a summary of these algorithms, which are described in more detail in the <a class=""TutorialLink"" target=""_top"" href=""../algorithms/index.html"">Algorithms</a> section.</p> 
<ul> 
 <li><code>sort</code> ? sorts a <code>List</code> using a merge sort algorithm, which provides a fast, stable sort. (A <i>stable sort</i> is one that does not reorder equal elements.)</li> 
 <li><code>shuffle</code> ? randomly permutes the elements in a <code>List</code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.reverse"" api=""Collections"" kind=""method"">
    Collections.reverse
   </clt></code> ? reverses the order of the elements in a <code>List</code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.rotate"" api=""Collections"" kind=""method"">
    Collections.rotate
   </clt></code> ? rotates all the elements in a <code>List</code> by a specified distance.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.swap"" api=""Collections"" kind=""method"">
    Collections.swap
   </clt></code> ? swaps the elements at specified positions in a <code>List</code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.replaceAll"" api=""Collections"" kind=""method"">
    Collections.replaceAll
   </clt></code> ? replaces all occurrences of one specified value with another.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.fill"" api=""Collections"" kind=""method"">
    Collections.fill
   </clt></code> ? overwrites every element in a <code>List</code> with the specified value.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.copy"" api=""Collections"" kind=""method"">
    Collections.copy
   </clt></code> ? copies the source <code>List</code> into the destination <code>List</code>.</li> 
 <li><code>binarySearch</code> ? searches for an element in an ordered <code>List</code> using the binary search algorithm.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.indexOfSubList"" api=""Collections"" kind=""method"">
    Collections.indexOfSubList
   </clt></code> ? returns the index of the first sublist of one <code>List</code> that is equal to another.</li> 
 <li><code> 
   <clt fqn=""java.util.Collections.lastIndexOfSubList"" api=""Collections"" kind=""method"">
    Collections.lastIndexOfSubList
   </clt></code> ? returns the index of the last sublist of one <code>List</code> that is equal to another.</li> 
</ul>","Collections","java.util.Collections","class","false"
"","","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","Map","java.util.Map","class","false"
"","","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","Hashtable","java.util.Hashtable","class","false"
"","","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","HashMap","java.util.HashMap","class","false"
"","","Map Interface Basic Operations","<h2>Map Interface Basic Operations</h2> 
<p>The basic operations of <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> (<code>put</code>, <code>get</code>, <code>containsKey</code>, <code>containsValue</code>, <code>size</code>, and <code>isEmpty</code>) behave exactly like their counterparts in <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. The <a class=""SourceLink"" target=""_blank"" href=""examples/Freq.java"" onclick=""showCode('../../displayCode.html', 'examples/Freq.java'); return false;""><code>following program</code></a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p> 
<p>The only tricky thing about this program is the second argument of the <code>put</code> statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p> 
<p>The program yields the following output.</p> 
<p>Suppose you'd prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> from <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> to <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. Making this four-character change causes the program to generate the following output from the same command line.</p>","TreeMap","java.util.TreeMap","class","false"
"","","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","LinkedHashMap","java.util.LinkedHashMap","class","false"
"","","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","Set","java.util.Set","class","false"
"","","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","Map","java.util.Map","class","false"
"","","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","Collection","java.util.Collection","class","false"
"","","Map Interface Basic Operations - part 2","<h3>Map Interface Basic Operations - part 2</h3>
<p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. Doing so results in the following output.</p> 
<p>This flexibility provides a potent illustration of the power of an interface-based framework.</p> 
<p>Like the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>interfaces, <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> strengthens the requirements on the <code>equals</code> and <code>hashCode</code> methods so that two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects can be compared for logical equality without regard to their implementation types. Two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances are equal if they represent the same key-value mappings.</p> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide constructors that take a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> object and initialize the new <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to contain all the key-value mappings in the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This standard <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor is entirely analogous to the standard <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> constructor: It allows the caller to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> of a desired implementation type that initially contains all of the mappings in another <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, regardless of the other <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s implementation type. For example, suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, named <code>m</code>. The following one-liner creates a new <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> initially containing all of the same key-value mappings as <code>m</code>.</p>","HashMap","java.util.HashMap","class","false"
"","","Map Interface Bulk Operations","<h2>Map Interface Bulk Operations</h2> 
<p>The <code>clear</code> operation does exactly what you would think it could do: It removes all the mappings from the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analogue of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface's <code> 
  <clt fqn=""java.util.Collection.addAll"" api=""Collection"" kind=""method"">
   Collection.addAll
  </clt></code> operation. In addition to its obvious use of dumping one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> into another, it has a second, more subtle use. Suppose a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is used to represent a collection of attribute-value pairs; the <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation, in combination with the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique.</p>","Map","java.util.Map","class","false"
"","","Map Interface Bulk Operations","<h2>Map Interface Bulk Operations</h2> 
<p>The <code>clear</code> operation does exactly what you would think it could do: It removes all the mappings from the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. The <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation is the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analogue of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface's <code> 
  <clt fqn=""java.util.Collection.addAll"" api=""Collection"" kind=""method"">
   Collection.addAll
  </clt></code> operation. In addition to its obvious use of dumping one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> into another, it has a second, more subtle use. Suppose a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is used to represent a collection of attribute-value pairs; the <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> operation, in combination with the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique.</p>","Collection","java.util.Collection","class","false"
"","","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Collection","java.util.Collection","class","false"
"","","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Map","java.util.Map","class","false"
"","","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Set","java.util.Set","class","false"
"","","Collection Views","<h2>Collection Views</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view methods allow a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> to be viewed as a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> in these three ways:</p> 
<ul> 
 <li><code> 
   <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
    Map.keySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of keys contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
    Map.values
   </clt></code> ? The <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> of values contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. This <code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code> is not a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, because multiple keys can map to the same value.</li> 
 <li><code> 
   <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
    Map.entrySet
   </clt></code> ? the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> of key-value pairs contained in the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. The <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface provides a small nested interface called <code> 
   <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
     Map.Entry 
   </clt></code>, the type of the elements in this <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>.</li> 
</ul> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views provide the <i>only</i> means to iterate over a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. This example illustrates the standard idiom for iterating over the keys in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with a <code>for-each</code> construct:</p> 
<p>and with an <code>iterator</code>:</p> 
<p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p> 
<p>At first, many people worry that these idioms may be slow because the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has to create a new <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> instance each time a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view operation is called. Rest easy: There's no reason that a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> cannot always return the same object each time it is asked for a given <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view. This is precisely what all the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in <code>java.util</code> do.</p>","Entry","java.io.ExpiringCache.Entry","class","false"
"","","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Collection","java.util.Collection","class","false"
"","","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Map","java.util.Map","class","false"
"","","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Entry","java.io.ExpiringCache.Entry","class","false"
"","","Collection Views - part 2","<h3>Collection Views - part 2</h3>
<p>With all three <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, calling an <code>Iterator</code>'s <code>remove</code> operation removes the associated entry from the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, assuming that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p> 
<p>With the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, it is also possible to change the value associated with a key by calling a <code> 
  <clt fqn=""java.io.ExpiringCache.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code>'s <code>setValue</code> method during iteration (again, assuming the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports value modification to begin with). Note that these are the <i>only</i> safe ways to modify a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> during iteration; the behavior is unspecified if the underlying <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is modified in any other way while the iteration is in progress.</p> 
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views support element removal in all its many forms ? <code>remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations, as well as the <code> 
  <clt fqn=""java.util.Iterator.remove"" api=""Iterator"" kind=""method"">
   Iterator.Iterator.remove
  </clt></code> operation. (Yet again, this assumes that the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> supports element removal.)</p>","Iterator","java.util.Iterator.remove","class","false"
"","","Collection Views - part 3","<h3>Collection Views - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views <i>do not</i> support element addition under any circumstances. It would make no sense for the <code> 
  <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
   Map.keySet
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
   Map.values
  </clt></code> views, and it's unnecessary for the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, because the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Map.put"" api=""Map"" kind=""method"">
   Map.put
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> methods provide the same functionality.</p>","Collection","java.util.Collection","class","false"
"","","Collection Views - part 3","<h3>Collection Views - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views <i>do not</i> support element addition under any circumstances. It would make no sense for the <code> 
  <clt fqn=""java.util.Map.keySet"" api=""Map"" kind=""method"">
   Map.keySet
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.values"" api=""Map"" kind=""method"">
   Map.values
  </clt></code> views, and it's unnecessary for the <code> 
  <clt fqn=""java.util.Map.entrySet"" api=""Map"" kind=""method"">
   Map.entrySet
  </clt></code> view, because the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Map.put"" api=""Map"" kind=""method"">
   Map.put
  </clt></code> and <code> 
  <clt fqn=""java.util.Map.putAll"" api=""Map"" kind=""method"">
   Map.putAll
  </clt></code> methods provide the same functionality.</p>","Map","java.util.Map.keySet","class","false"
"","","Fancy Uses of Collection Views: Map Algebra","<h2>Fancy Uses of 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Views: 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Algebra</h2> 
<p>When applied to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, bulk operations (<code>containsAll</code>, <code>removeAll</code>, and <code>retainAll</code>) are surprisingly potent tools. For starters, suppose you want to know whether one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is a submap of another ? that is, whether the first <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> contains all the key-value mappings in the second. The following idiom does the trick.</p> 
<p>Along similar lines, suppose you want to know whether two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects contain mappings for all of the same keys.</p> 
<p>Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that represents a collection of attribute-value pairs, and two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.</p> 
<p>Suppose you want to know all the keys common to two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects.</p>","Collection","java.util.Collection","class","false"
"","","Fancy Uses of Collection Views: Map Algebra","<h2>Fancy Uses of 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Views: 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Algebra</h2> 
<p>When applied to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, bulk operations (<code>containsAll</code>, <code>removeAll</code>, and <code>retainAll</code>) are surprisingly potent tools. For starters, suppose you want to know whether one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is a submap of another ? that is, whether the first <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> contains all the key-value mappings in the second. The following idiom does the trick.</p> 
<p>Along similar lines, suppose you want to know whether two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects contain mappings for all of the same keys.</p> 
<p>Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that represents a collection of attribute-value pairs, and two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.</p> 
<p>Suppose you want to know all the keys common to two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects.</p>","Map","java.util.Map","class","false"
"","","Fancy Uses of Collection Views: Map Algebra","<h2>Fancy Uses of 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Views: 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Algebra</h2> 
<p>When applied to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views, bulk operations (<code>containsAll</code>, <code>removeAll</code>, and <code>retainAll</code>) are surprisingly potent tools. For starters, suppose you want to know whether one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is a submap of another ? that is, whether the first <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> contains all the key-value mappings in the second. The following idiom does the trick.</p> 
<p>Along similar lines, suppose you want to know whether two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects contain mappings for all of the same keys.</p> 
<p>Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that represents a collection of attribute-value pairs, and two <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn't.</p> 
<p>Suppose you want to know all the keys common to two <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> objects.</p>","Set","java.util.Set","class","false"
"","","Fancy Uses of Collection Views: Map Algebra - part 2","<h3>Fancy Uses of Collection Views: Map Algebra - part 2</h3>
<p>A similar idiom gets you the common values.</p> 
<p>All the idioms presented thus far have been nondestructive; that is, they don't modify the backing <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Here are a few that do. Suppose you want to remove all of the key-value pairs that one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has in common with another.</p> 
<p>Suppose you want to remove from one <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> all of the keys that have mappings in another.</p> 
<p>What happens when you start mixing keys and values in the same bulk operation? Suppose you have a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, <code>managers</code>, that maps each employee in a company to the employee's manager. We'll be deliberately vague about the types of the key and the value objects. It doesn't matter, as long as they're the same. Now suppose you want to know who all the &quot;individual contributors&quot; (or nonmanagers) are. The following snippet tells you exactly what you want to know.</p>","Map","java.util.Map","class","false"
"","","Fancy Uses of Collection Views: Map Algebra - part 3","<h3>Fancy Uses of Collection Views: Map Algebra - part 3</h3>
<p>Suppose you want to fire all the employees who report directly to some manager, Simon.</p> 
<p>Note that this idiom makes use of <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> with the single, specified element.</p> 
<p>Once you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.</p> 
<p>This example is a bit tricky. First, it makes a temporary copy of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and it removes from the temporary copy all entries whose (manager) value is a key in the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Remember that the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has an entry for each employee. Thus, the remaining entries in the temporary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> comprise all the entries from the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.</p>","Collections","java.util.Collections.singleton","class","false"
"","","Fancy Uses of Collection Views: Map Algebra - part 3","<h3>Fancy Uses of Collection Views: Map Algebra - part 3</h3>
<p>Suppose you want to fire all the employees who report directly to some manager, Simon.</p> 
<p>Note that this idiom makes use of <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> with the single, specified element.</p> 
<p>Once you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.</p> 
<p>This example is a bit tricky. First, it makes a temporary copy of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and it removes from the temporary copy all entries whose (manager) value is a key in the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Remember that the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has an entry for each employee. Thus, the remaining entries in the temporary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> comprise all the entries from the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.</p>","Set","java.util.Set","class","false"
"","","Fancy Uses of Collection Views: Map Algebra - part 3","<h3>Fancy Uses of Collection Views: Map Algebra - part 3</h3>
<p>Suppose you want to fire all the employees who report directly to some manager, Simon.</p> 
<p>Note that this idiom makes use of <code> 
  <clt fqn=""java.util.Collections.singleton"" api=""Collections"" kind=""method"">
   Collections.Collections.singleton
  </clt></code>, a static factory method that returns an immutable <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> with the single, specified element.</p> 
<p>Once you've done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon's direct-reports were themselves managers). The following code will tell you which employees have managers who no longer works for the company.</p> 
<p>This example is a bit tricky. First, it makes a temporary copy of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and it removes from the temporary copy all entries whose (manager) value is a key in the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Remember that the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> has an entry for each employee. Thus, the remaining entries in the temporary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> comprise all the entries from the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we're looking for.</p>","Map","java.util.Map","class","false"
"","","Multimaps","<h2>Multimaps</h2> 
<p>A <i>multimap</i> is like a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> but it can map each key to multiple values. The Java Collections Framework doesn't include an interface for multimaps because they aren't used all that commonly. It's a fairly simple matter to use a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> whose values are <code>List</code> instances as a multimap. This technique is demonstrated in the next code example, which reads a word list containing one word per line (all lowercase) and prints out all the anagram groups that meet a size criterion. An <i>anagram group</i> is a bunch of words, all of which contain exactly the same letters but in a different order. The program takes two arguments on the command line: (1) the name of the dictionary file and (2) the minimum size of anagram group to print out. Anagram groups containing fewer words than the specified minimum are not printed.</p>","Map","java.util.Map","class","false"
"","","Comparators","<h2>Comparators</h2> 
<p>What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>? To do either of these things, you'll need to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> ? an object that encapsulates an ordering. Like the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface, the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface consists of a single method.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>, the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>Much of what was said about <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> applies to <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> as well. Writing a <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method is nearly identical to writing a <code>compareTo</code> method, except that the former gets both objects passed in as arguments. The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method has to obey the same four technical restrictions as <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>'s <code>compareTo</code> method for the same reason ? a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> must induce a total order on the objects it compares.</p>","Comparable","java.lang.Comparable","class","false"
"","","Comparators","<h2>Comparators</h2> 
<p>What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>? To do either of these things, you'll need to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> ? an object that encapsulates an ordering. Like the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface, the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface consists of a single method.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>, the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>Much of what was said about <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> applies to <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> as well. Writing a <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method is nearly identical to writing a <code>compareTo</code> method, except that the former gets both objects passed in as arguments. The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method has to obey the same four technical restrictions as <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>'s <code>compareTo</code> method for the same reason ? a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> must induce a total order on the objects it compares.</p>","Comparator","java.util.Comparator","class","false"
"","","Comparators","<h2>Comparators</h2> 
<p>What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don't implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>? To do either of these things, you'll need to provide a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html""><code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code></a> ? an object that encapsulates an ordering. Like the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface, the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface consists of a single method.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>, the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code>.</p> 
<p>Much of what was said about <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> applies to <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> as well. Writing a <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method is nearly identical to writing a <code>compareTo</code> method, except that the former gets both objects passed in as arguments. The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> method has to obey the same four technical restrictions as <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>'s <code>compareTo</code> method for the same reason ? a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> must induce a total order on the objects it compares.</p>","ClassCastException","java.lang.ClassCastException","class","false"
"","","Comparators - part 2","<h3>Comparators - part 2</h3>
<p>Suppose you have a class called <code>Employee</code>, as follows.</p> 
<p>Let's assume that the natural ordering of <code>Employee</code> instances is <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code> ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the program is reasonably straightforward. It relies on the natural ordering of <code>Date</code> applied to the values returned by the <code>hireDate</code> accessor method. Note that the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison.</p>","Name","java.util.jar.Attributes.Name","class","false"
"","","Comparators - part 2","<h3>Comparators - part 2</h3>
<p>Suppose you have a class called <code>Employee</code>, as follows.</p> 
<p>Let's assume that the natural ordering of <code>Employee</code> instances is <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code> ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the program is reasonably straightforward. It relies on the natural ordering of <code>Date</code> applied to the values returned by the <code>hireDate</code> accessor method. Note that the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison.</p>","Comparator","java.util.Comparator","class","false"
"","","Comparators - part 3","<h3>Comparators - part 3</h3>
<p>You should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the <code>compareTo</code> method can return any negative <code>int</code> if its argument is less than the object on which it is invoked. There is one negative <code>int</code> that remains negative when negated, strange as it may seem.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the preceding program works fine for sorting a <code>List</code>, but it does have one deficiency: It cannot be used to order a sorted collection, such as <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, because it generates an ordering that is <i>not compatible with</i> equals. This means that this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> equates objects that the <code>equals</code> method does not. In particular, any two employees who were hired on the same date will compare as equal. When you're sorting a <code>List</code>, this doesn't matter; but when you're using the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to order a sorted collection, it's fatal. If you use this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to insert multiple employees hired on the same date into a <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.</p>","Comparator","java.util.Comparator","class","false"
"","","Comparators - part 3","<h3>Comparators - part 3</h3>
<p>You should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the <code>compareTo</code> method can return any negative <code>int</code> if its argument is less than the object on which it is invoked. There is one negative <code>int</code> that remains negative when negated, strange as it may seem.</p> 
<p>The <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> in the preceding program works fine for sorting a <code>List</code>, but it does have one deficiency: It cannot be used to order a sorted collection, such as <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, because it generates an ordering that is <i>not compatible with</i> equals. This means that this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> equates objects that the <code>equals</code> method does not. In particular, any two employees who were hired on the same date will compare as equal. When you're sorting a <code>List</code>, this doesn't matter; but when you're using the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to order a sorted collection, it's fatal. If you use this <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> to insert multiple employees hired on the same date into a <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.</p>","TreeSet","java.util.TreeSet","class","false"
"","","Comparators - part 4","<h3>Comparators - part 4</h3>
<p>To fix this problem, simply tweak the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> so that it produces an ordering that <i>is compatible with</i> <code>equals</code>. In other words, tweak it so that the only elements seen as equal when using <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> are those that are also seen as equal when compared using <code>equals</code>. The way to do this is to perform a two-part comparison (as for <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code>), where the first part is the one we're interested in ? in this case, the hire date ? and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that results.</p> 
<p>One last note: You might be tempted to replace the final <code>return</code> statement in the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> with the simpler:</p>","Comparator","java.util.Comparator","class","false"
"","","Comparators - part 4","<h3>Comparators - part 4</h3>
<p>To fix this problem, simply tweak the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> so that it produces an ordering that <i>is compatible with</i> <code>equals</code>. In other words, tweak it so that the only elements seen as equal when using <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
   Comparator.compare
  </clt></code> are those that are also seen as equal when compared using <code>equals</code>. The way to do this is to perform a two-part comparison (as for <code> 
  <clt fqn=""java.util.jar.Attributes.Name"" api=""Name"" kind=""class"">
    Name 
  </clt></code>), where the first part is the one we're interested in ? in this case, the hire date ? and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that results.</p> 
<p>One last note: You might be tempted to replace the final <code>return</code> statement in the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> with the simpler:</p>","Name","java.util.jar.Attributes.Name","class","false"
"","","Comparators - part 5","<h3>Comparators - part 5</h3>
<p>Don't do it unless you're <i>absolutely sure</i> no one will ever have a negative employee number! This trick does not work in general because the signed integer type is not big enough to represent the difference of two arbitrary signed integers. If <code>i</code> is a large positive integer and <code>j</code> is a large negative integer, <code>i - j</code> will overflow and will return a negative integer. The resulting <code> 
  <clt fqn=""java.util.TreeSet.comparator"" api=""TreeSet"" kind=""method"">
   TreeSet.comparator
  </clt></code> violates one of the four technical restrictions we keep talking about (transitivity) and produces horrible, subtle bugs. This is not a purely theoretical concern; people get burned by it.</p>","TreeSet","java.util.TreeSet.comparator","class","false"
"","","Set Interface Bulk Operations","<h2>Set Interface Bulk Operations</h2> 
<p>Bulk operations are particularly well suited to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s; when applied, they perform standard set-algebraic operations. Suppose <code>s1</code> and <code>s2</code> are sets. Here's what bulk operations do:</p> 
<ul> 
 <li><code>s1.containsAll(s2)</code> ? returns <code>true</code> if <code>s2</code> is a <b>subset</b> of <code>s1</code>. (<code>s2</code> is a subset of <code>s1</code> if set <code>s1</code> contains all of the elements in <code>s2</code>.)</li> 
 <li><code>s1.addAll(s2)</code> ? transforms <code>s1</code> into the <b>union</b> of <code>s1</code> and <code>s2</code>. (The union of two sets is the set containing all of the elements contained in either set.)</li> 
 <li><code>s1.retainAll(s2)</code> ? transforms <code>s1</code> into the intersection of <code>s1</code> and <code>s2</code>. (The intersection of two sets is the set containing only the elements common to both sets.)</li> 
 <li><code>s1.removeAll(s2)</code> ? transforms <code>s1</code> into the (asymmetric) set difference of <code>s1</code> and <code>s2</code>. (For example, the set difference of <code>s1</code> minus <code>s2</code> is the set containing all of the elements found in <code>s1</code> but not in <code>s2</code>.)</li> 
</ul>","Set","java.util.Set","class","false"
"","","Set Interface Bulk Operations - part 2","<h3>Set Interface Bulk Operations - part 2</h3>
<p>To calculate the union, intersection, or set difference of two sets <i>nondestructively</i> (without modifying either set), the caller must copy one set before calling the appropriate bulk operation. The following are the resulting idioms.</p> 
<p>The implementation type of the result <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> in the preceding idioms is <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, which is, as already mentioned, the best all-around <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation in the Java platform. However, any general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation could be substituted.</p> 
<p>Let's revisit the <code>FindDups</code> program. Suppose you want to know which words in the argument list occur only once and which occur more than once, but you do not want any duplicates printed out repeatedly. This effect can be achieved by generating two sets ? one containing every word in the argument list and the other containing only the duplicates. The words that occur only once are the set difference of these two sets, which we know how to compute. Here's how <a class=""SourceLink"" target=""_blank"" href=""examples/FindDups2.java"" onclick=""showCode('../../displayCode.html', 'examples/FindDups2.java'); return false;""><code>the resulting program</code></a> looks.</p>","Set","java.util.Set","class","false"
"","","Set Interface Bulk Operations - part 2","<h3>Set Interface Bulk Operations - part 2</h3>
<p>To calculate the union, intersection, or set difference of two sets <i>nondestructively</i> (without modifying either set), the caller must copy one set before calling the appropriate bulk operation. The following are the resulting idioms.</p> 
<p>The implementation type of the result <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> in the preceding idioms is <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, which is, as already mentioned, the best all-around <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation in the Java platform. However, any general-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation could be substituted.</p> 
<p>Let's revisit the <code>FindDups</code> program. Suppose you want to know which words in the argument list occur only once and which occur more than once, but you do not want any duplicates printed out repeatedly. This effect can be achieved by generating two sets ? one containing every word in the argument list and the other containing only the duplicates. The words that occur only once are the set difference of these two sets, which we know how to compute. Here's how <a class=""SourceLink"" target=""_blank"" href=""examples/FindDups2.java"" onclick=""showCode('../../displayCode.html', 'examples/FindDups2.java'); return false;""><code>the resulting program</code></a> looks.</p>","HashSet","java.util.HashSet","class","false"
"","","Set Interface Array Operations","<h2>Set Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The array operations don't do anything special for <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s beyond what they do for any other <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. These operations are described in <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p>","Array","java.sql.Array","class","false"
"","","Set Interface Array Operations","<h2>Set Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The array operations don't do anything special for <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s beyond what they do for any other <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. These operations are described in <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p>","Set","java.util.Set","class","false"
"","","Set Interface Array Operations","<h2>Set Interface 
 <clt fqn=""java.sql.Array"" api=""Array"" kind=""class"">
   Array 
 </clt>Operations</h2> 
<p>The array operations don't do anything special for <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>s beyond what they do for any other <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. These operations are described in <a class=""TutorialLink"" target=""_top"" href=""collection.html"">The Collection Interface</a> section.</p>","Collection","java.util.Collection","class","false"
"","","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","Map","java.util.Map","class","false"
"","","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","SortedMap","java.util.SortedMap","class","false"
"","","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","TreeMap","java.util.TreeMap","class","false"
"","","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","Attributes","java.util.jar.Attributes.map","class","false"
"","","Standard Constructors","<h2>Standard Constructors</h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>, this constructor creates an instance that orders its entries according to their keys' natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance was a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> took the approach it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> containing the same mappings as the given <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> constructor is invoked in preference to the ordinary <code> 
  <clt fqn=""java.util.jar.Attributes.map"" api=""Attributes"" kind=""field"">
   Attributes.map
  </clt></code> constructor.</p> 
<p><code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty map sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> that sorts its mappings according to their keys' natural ordering.</p>","Comparator","java.util.Comparator","class","false"
"","","Comparison to SortedSet","<h2>Comparison to SortedSet</h2> 
<p>Because this interface is a precise <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, all the idioms and code examples in <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section apply to <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> with only trivial modifications.</p>","Map","java.util.Map","class","false"
"","","Comparison to SortedSet","<h2>Comparison to SortedSet</h2> 
<p>Because this interface is a precise <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, all the idioms and code examples in <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section apply to <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> with only trivial modifications.</p>","SortedSet","java.util.SortedSet","class","false"
"","","Comparison to SortedSet","<h2>Comparison to SortedSet</h2> 
<p>Because this interface is a precise <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> analog of <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, all the idioms and code examples in <a class=""TutorialLink"" target=""_top"" href=""sorted-set.html"">The SortedSet Interface</a> section apply to <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> with only trivial modifications.</p>","SortedMap","java.util.SortedMap","class","false"
"","","Standard Constructors","<h2><a name=""constructor"" id=""constructor"">Standard Constructors</a></h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> instance and, if so, to sort the new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> took the approach that it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).</p> 
<p><code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty set sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.</p>","Collection","java.util.Collection","class","false"
"","","Standard Constructors","<h2><a name=""constructor"" id=""constructor"">Standard Constructors</a></h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> instance and, if so, to sort the new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> took the approach that it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).</p> 
<p><code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty set sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.</p>","SortedSet","java.util.SortedSet","class","false"
"","","Standard Constructors","<h2><a name=""constructor"" id=""constructor"">Standard Constructors</a></h2> 
<p>By convention, all general-purpose <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> implementations provide a standard conversion constructor that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>; <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations are no exception. In <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>, this constructor creates an instance that sorts its elements according to their natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> instance and, if so, to sort the new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> according to the same criterion (comparator or natural ordering). Because <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> took the approach that it did, it also provides a constructor that takes a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> and returns a new <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> containing the same elements sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).</p> 
<p><code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> implementations also provide, by convention, a constructor that takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> and returns an empty set sorted according to the specified <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>. If <code>null</code> is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.</p>","TreeSet","java.util.TreeSet","class","false"
"","","Range-view Operations - part 2","<h3>Range-view Operations - part 2</h3>
<p>Sorted sets provide three <code>range-view</code> operations. The first, <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code>, takes two endpoints, like <code>subList</code>. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> or the natural ordering of its elements, whichever the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> uses to order itself. Like <code>subList</code>, the range is half open, including its low endpoint but excluding the high one.</p> 
<p>Thus, the following line of code tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including <code>&quot;doorbell&quot;</code> but excluding <code>&quot;pickle&quot;</code>, are contained in a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> of strings called <code>dictionary</code>:</p> 
<p>In like manner, the following one-liner removes all the elements beginning with the letter <code>f</code>.</p> 
<p>A similar trick can be used to print a table telling you how many words begin with each letter.</p>","SortedSet","java.util.SortedSet.subSet","class","false"
"","","Range-view Operations - part 2","<h3>Range-view Operations - part 2</h3>
<p>Sorted sets provide three <code>range-view</code> operations. The first, <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code>, takes two endpoints, like <code>subList</code>. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> or the natural ordering of its elements, whichever the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> uses to order itself. Like <code>subList</code>, the range is half open, including its low endpoint but excluding the high one.</p> 
<p>Thus, the following line of code tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including <code>&quot;doorbell&quot;</code> but excluding <code>&quot;pickle&quot;</code>, are contained in a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> of strings called <code>dictionary</code>:</p> 
<p>In like manner, the following one-liner removes all the elements beginning with the letter <code>f</code>.</p> 
<p>A similar trick can be used to print a table telling you how many words begin with each letter.</p>","Set","java.util.Set","class","false"
"","","Range-view Operations - part 2","<h3>Range-view Operations - part 2</h3>
<p>Sorted sets provide three <code>range-view</code> operations. The first, <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code>, takes two endpoints, like <code>subList</code>. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>'s <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> or the natural ordering of its elements, whichever the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> uses to order itself. Like <code>subList</code>, the range is half open, including its low endpoint but excluding the high one.</p> 
<p>Thus, the following line of code tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including <code>&quot;doorbell&quot;</code> but excluding <code>&quot;pickle&quot;</code>, are contained in a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> of strings called <code>dictionary</code>:</p> 
<p>In like manner, the following one-liner removes all the elements beginning with the letter <code>f</code>.</p> 
<p>A similar trick can be used to print a table telling you how many words begin with each letter.</p>","Comparator","java.util.Comparator","class","false"
"","","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","SortedSet","java.util.SortedSet.subSet","class","false"
"","","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","TreeMap","java.util.TreeMap.successor","class","false"
"","","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","String","java.lang.String","class","false"
"","","Range-view Operations - part 3","<h3>Range-view Operations - part 3</h3>
<p>Suppose you want to view a <i>closed interval</i>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the <code> 
  <clt fqn=""java.util.SortedSet.subSet"" api=""SortedSet"" kind=""method"">
   SortedSet.subSet
  </clt></code> from <code>lowEndpoint</code> to <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(highEndpoint)
  </clt></code>. Although it isn't entirely obvious, the successor of a string <code>s</code> in <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>'s natural ordering is <code> 
  <clt fqn=""java.util.Collections.CheckedMap.CheckedEntrySet.s"" api=""CheckedEntrySet"" kind=""field"">
   CheckedEntrySet.s + &quot;\0&quot;
  </clt></code> ? that is, <code>s</code> with a <code>null</code> character appended.</p> 
<p>Thus, the following one-liner tells you how many words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, including doorbell <i>and</i> pickle, are contained in the dictionary.</p> 
<p>A similar technique can be used to view an <i>open interval</i>, which contains neither endpoint. The open-interval view from <code>lowEndpoint</code> to <code>highEndpoint</code> is the half-open interval from <code> 
  <clt fqn=""java.util.TreeMap.successor"" api=""TreeMap"" kind=""method"">
   TreeMap.successor(lowEndpoint)
  </clt></code> to <code>highEndpoint</code>. Use the following to calculate the number of words between <code>&quot;doorbell&quot;</code> and <code>&quot;pickle&quot;</code>, excluding both.</p>","CheckedEntrySet","java.util.Collections.CheckedMap.CheckedEntrySet.s","class","false"
"","","Range-view Operations - part 4","<h3>Range-view Operations - part 4</h3>
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains two more <code>range-view</code> operations ? <code> 
  <clt fqn=""java.util.SortedSet.headSet"" api=""SortedSet"" kind=""method"">
   SortedSet.headSet
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code>, both of which take a single <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> argument. The former returns a view of the initial portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, up to but not including the specified object. The latter returns a view of the final portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, beginning with the specified object and continuing to the end of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. Thus, the following code allows you to view the dictionary as two disjoint <code>volumes</code> (<code>a-m</code> and <code>n-z</code>).</p>","SortedSet","java.util.SortedSet","class","false"
"","","Range-view Operations - part 4","<h3>Range-view Operations - part 4</h3>
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains two more <code>range-view</code> operations ? <code> 
  <clt fqn=""java.util.SortedSet.headSet"" api=""SortedSet"" kind=""method"">
   SortedSet.headSet
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code>, both of which take a single <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> argument. The former returns a view of the initial portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, up to but not including the specified object. The latter returns a view of the final portion of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>, beginning with the specified object and continuing to the end of the backing <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. Thus, the following code allows you to view the dictionary as two disjoint <code>volumes</code> (<code>a-m</code> and <code>n-z</code>).</p>","Object","java.lang.Object","class","false"
"","","Endpoint Operations","<h2>Endpoint Operations</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains operations to return the first and last elements in the sorted set, not surprisingly called <code> 
  <clt fqn=""java.util.SortedSet.first"" api=""SortedSet"" kind=""method"">
   SortedSet.first
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code>. In addition to their obvious uses, <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code> allows a workaround for a deficiency in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface. One thing you'd like to do with a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is to go into the interior of the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and iterate forward or backward. It's easy enough to go forward from the interior: Just get a <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code> and iterate over it. Unfortunately, there's no easy way to go backward.</p> 
<p>The following idiom obtains the first element that is less than a specified object <code>o</code> in the element space.</p> 
<p>This is a fine way to go one element backward from a point in the interior of a sorted set. It could be applied repeatedly to iterate backward, but this is very inefficient, requiring a lookup for each element returned.</p>","SortedSet","java.util.SortedSet","class","false"
"","","Endpoint Operations","<h2>Endpoint Operations</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains operations to return the first and last elements in the sorted set, not surprisingly called <code> 
  <clt fqn=""java.util.SortedSet.first"" api=""SortedSet"" kind=""method"">
   SortedSet.first
  </clt></code> and <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code>. In addition to their obvious uses, <code> 
  <clt fqn=""java.util.SortedSet.last"" api=""SortedSet"" kind=""method"">
   SortedSet.last
  </clt></code> allows a workaround for a deficiency in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface. One thing you'd like to do with a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> is to go into the interior of the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> and iterate forward or backward. It's easy enough to go forward from the interior: Just get a <code> 
  <clt fqn=""java.util.SortedSet.tailSet"" api=""SortedSet"" kind=""method"">
   SortedSet.tailSet
  </clt></code> and iterate over it. Unfortunately, there's no easy way to go backward.</p> 
<p>The following idiom obtains the first element that is less than a specified object <code>o</code> in the element space.</p> 
<p>This is a fine way to go one element backward from a point in the interior of a sorted set. It could be applied repeatedly to iterate backward, but this is very inefficient, requiring a lookup for each element returned.</p>","Set","java.util.Set","class","false"
"","","Comparator Accessor","<h2>Comparator Accessor</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains an accessor method called <code> 
  <clt fqn=""java.util.SortedSet.comparator"" api=""SortedSet"" kind=""method"">
   SortedSet.comparator
  </clt></code> that returns the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> used to sort the set, or <code>null</code> if the set is sorted according to the <i>natural ordering</i> of its elements. This method is provided so that sorted sets can be copied into new sorted sets with the same ordering. It is used by the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> constructor described <a href=""#constructor"">previously</a>.</p>","SortedSet","java.util.SortedSet","class","false"
"","","Comparator Accessor","<h2>Comparator Accessor</h2> 
<p>The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface contains an accessor method called <code> 
  <clt fqn=""java.util.SortedSet.comparator"" api=""SortedSet"" kind=""method"">
   SortedSet.comparator
  </clt></code> that returns the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> used to sort the set, or <code>null</code> if the set is sorted according to the <i>natural ordering</i> of its elements. This method is provided so that sorted sets can be copied into new sorted sets with the same ordering. It is used by the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> constructor described <a href=""#constructor"">previously</a>.</p>","Comparator","java.util.Comparator","class","false"
