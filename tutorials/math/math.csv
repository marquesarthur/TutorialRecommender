,0.4 How interface contracts are specified in commons-math javadoc,"<h3>0.4 How interface contracts are specified in commons-math javadoc</h3> 
<p> You should always read the javadoc class and method comments carefully when using Commons Math components in your programs. The javadoc provides references to the algorithms that are used, usage notes about limitations, performance, etc. as well as interface contracts. Interface contracts are specified in terms of preconditions (what has to be true in order for the method to return valid results), special values returned (e.g. Double.NaN) or exceptions that may be thrown if the preconditions are not met, and definitions for returned values/objects or state changes.</p> 
<p> When the actual parameters provided to a method or the internal state of an object make a computation meaningless, a <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> IllegalArgumentException</a> or <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> 
  <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
    MathIllegalStateException 
  </clt></a> may be thrown. Exact conditions under which runtime exceptions (and any other exceptions) are thrown are specified in the javadoc method comments. In some cases, to be consistent with the <a class=""externalLink"" href=""http://grouper.ieee.org/groups/754/""> IEEE 754 standard</a> for floating point arithmetic and with java.lang.Math, Commons Math methods return <tt>Double.NaN</tt> values. Conditions under which <tt>Double.NaN</tt> or other special values are returned are fully specified in the javadoc method comments. </p> 
<p> As of version 2.2, the policy for dealing with null references is as follows: When an argument is unexpectedly null, a <a href=""../apidocs/org/apache/commons/math3/exception/NullArgumentException.html""> 
  <clt fqn=""org.apache.commons.math3.exception.NullArgumentException"" api=""NullArgumentException"" kind=""class"">
    NullArgumentException 
  </clt></a> is raised for signalling the illegal argument. Note that this class does not inherit from the standard <tt>NullPointerException</tt> but is a subclass of <tt> 
  <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
    MathIllegalArgumentException 
  </clt></tt>. No <tt>NullPointerException</tt> should be propagated from within Commons Math. </p>",MathIllegalStateException,class
,0.4 How interface contracts are specified in commons-math javadoc,"<h3>0.4 How interface contracts are specified in commons-math javadoc</h3> 
<p> You should always read the javadoc class and method comments carefully when using Commons Math components in your programs. The javadoc provides references to the algorithms that are used, usage notes about limitations, performance, etc. as well as interface contracts. Interface contracts are specified in terms of preconditions (what has to be true in order for the method to return valid results), special values returned (e.g. Double.NaN) or exceptions that may be thrown if the preconditions are not met, and definitions for returned values/objects or state changes.</p> 
<p> When the actual parameters provided to a method or the internal state of an object make a computation meaningless, a <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> IllegalArgumentException</a> or <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> 
  <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
    MathIllegalStateException 
  </clt></a> may be thrown. Exact conditions under which runtime exceptions (and any other exceptions) are thrown are specified in the javadoc method comments. In some cases, to be consistent with the <a class=""externalLink"" href=""http://grouper.ieee.org/groups/754/""> IEEE 754 standard</a> for floating point arithmetic and with java.lang.Math, Commons Math methods return <tt>Double.NaN</tt> values. Conditions under which <tt>Double.NaN</tt> or other special values are returned are fully specified in the javadoc method comments. </p> 
<p> As of version 2.2, the policy for dealing with null references is as follows: When an argument is unexpectedly null, a <a href=""../apidocs/org/apache/commons/math3/exception/NullArgumentException.html""> 
  <clt fqn=""org.apache.commons.math3.exception.NullArgumentException"" api=""NullArgumentException"" kind=""class"">
    NullArgumentException 
  </clt></a> is raised for signalling the illegal argument. Note that this class does not inherit from the standard <tt>NullPointerException</tt> but is a subclass of <tt> 
  <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
    MathIllegalArgumentException 
  </clt></tt>. No <tt>NullPointerException</tt> should be propagated from within Commons Math. </p>",NullArgumentException,class
,0.4 How interface contracts are specified in commons-math javadoc,"<h3>0.4 How interface contracts are specified in commons-math javadoc</h3> 
<p> You should always read the javadoc class and method comments carefully when using Commons Math components in your programs. The javadoc provides references to the algorithms that are used, usage notes about limitations, performance, etc. as well as interface contracts. Interface contracts are specified in terms of preconditions (what has to be true in order for the method to return valid results), special values returned (e.g. Double.NaN) or exceptions that may be thrown if the preconditions are not met, and definitions for returned values/objects or state changes.</p> 
<p> When the actual parameters provided to a method or the internal state of an object make a computation meaningless, a <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> IllegalArgumentException</a> or <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> 
  <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
    MathIllegalStateException 
  </clt></a> may be thrown. Exact conditions under which runtime exceptions (and any other exceptions) are thrown are specified in the javadoc method comments. In some cases, to be consistent with the <a class=""externalLink"" href=""http://grouper.ieee.org/groups/754/""> IEEE 754 standard</a> for floating point arithmetic and with java.lang.Math, Commons Math methods return <tt>Double.NaN</tt> values. Conditions under which <tt>Double.NaN</tt> or other special values are returned are fully specified in the javadoc method comments. </p> 
<p> As of version 2.2, the policy for dealing with null references is as follows: When an argument is unexpectedly null, a <a href=""../apidocs/org/apache/commons/math3/exception/NullArgumentException.html""> 
  <clt fqn=""org.apache.commons.math3.exception.NullArgumentException"" api=""NullArgumentException"" kind=""class"">
    NullArgumentException 
  </clt></a> is raised for signalling the illegal argument. Note that this class does not inherit from the standard <tt>NullPointerException</tt> but is a subclass of <tt> 
  <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
    MathIllegalArgumentException 
  </clt></tt>. No <tt>NullPointerException</tt> should be propagated from within Commons Math. </p>",MathIllegalArgumentException,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",UnivariateStatistic,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",evaluate,method
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",StorelessUnivariateStatistic,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",increment,method
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",getResult,method
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",AbstractUnivariateStatistic,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",AbstractStorelessUnivariateStatistic,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",DescriptiveStatistics,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",SummaryStatistics,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",AggregateSummaryStatistics,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",MultivariateSummaryStatistics,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",SynchronizedDescriptiveStatistics,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",SynchronizedSummaryStatistics,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",SynchronizedMultivariateSummaryStatistics,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",StatUtils,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",createContributingStatistics,method
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",addValue,class
,1.2 Descriptive statistics,"<h3>1.2 Descriptive statistics</h3> 
<p> The stat package includes a framework and default implementations for the following Descriptive statistics: </p> 
<ul> 
 <li>arithmetic and geometric means</li> 
 <li>variance and standard deviation</li> 
 <li>sum, product, log sum, sum of squared values</li> 
 <li>minimum, maximum, median, and percentiles</li> 
 <li>skewness and kurtosis</li> 
 <li>first, second, third and fourth moments</li> 
</ul> 
<p> With the exception of percentiles and the median, all of these statistics can be computed without maintaining the full list of input data values in memory. The stat package provides interfaces and implementations that do not require value storage as well as implementations that operate on arrays of stored values. </p> 
<p> The top level interface is <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.UnivariateStatistic"" api=""UnivariateStatistic"" kind=""class"">
    UnivariateStatistic 
  </clt></a>. This interface, implemented by all statistics, consists of <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic.evaluate"" api=""evaluate"" kind=""method"">
    evaluate() 
  </clt></tt> methods that take double[] arrays as arguments and return the value of the statistic. This interface is extended by <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"" api=""StorelessUnivariateStatistic"" kind=""class"">
    StorelessUnivariateStatistic 
  </clt></a>, which adds <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment(), 
  </clt></tt> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"" api=""getResult"" kind=""method"">
    getResult() 
  </clt></tt> and associated methods to support &quot;storageless&quot; implementations that maintain counters, sums or other state information as values are added using the <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"" api=""increment"" kind=""method"">
    increment() 
  </clt></tt> method. </p> 
<p> Abstract implementations of the top level interfaces are provided in <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"" api=""AbstractUnivariateStatistic"" kind=""class"">
    AbstractUnivariateStatistic 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"" api=""AbstractStorelessUnivariateStatistic"" kind=""class"">
    AbstractStorelessUnivariateStatistic 
  </clt></a> respectively. </p> 
<p> Each statistic is implemented as a separate class, in one of the subpackages (moment, rank, summary) and each extends one of the abstract classes above (depending on whether or not value storage is required to compute the statistic). There are several ways to instantiate and use statistics. Statistics can be instantiated and used directly, but it is generally more convenient (and efficient) to access them using the provided aggregates, <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics. 
  </clt></a> </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> maintains the input data in memory and has the capability of producing &quot;rolling&quot; statistics computed from a &quot;window&quot; consisting of the most recently added values. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Aggregate</th> 
   <th>Statistics Included</th> 
   <th>Values stored?</th> 
   <th>&quot;Rolling&quot; capability?</th> 
  </tr> 
  <tr class=""b""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
       DescriptiveStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance, percentiles, skewness, kurtosis, median</td> 
   <td>Yes</td> 
   <td>Yes</td> 
  </tr> 
  <tr class=""a""> 
   <td> <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html""> 
     <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
       SummaryStatistics 
     </clt></a></td> 
   <td>min, max, mean, geometric mean, n, sum, sum of squares, standard deviation, variance</td> 
   <td>No</td> 
   <td>No</td> 
  </tr> 
 </tbody> 
</table> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> can be aggregated using <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
    AggregateSummaryStatistics. 
  </clt></a> This class can be used to concurrently gather statistics for multiple datasets as well as for a combined sample including all of the data. </p> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics 
  </clt></tt> is similar to <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> but handles n-tuple values instead of scalar values. It can also compute the full covariance matrix for the input data. </p> 
<p> Neither <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
    DescriptiveStatistics 
  </clt></tt> nor <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
    SummaryStatistics 
  </clt></tt> is thread-safe. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
    SynchronizedDescriptiveStatistics 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"" api=""SynchronizedSummaryStatistics"" kind=""class"">
    SynchronizedSummaryStatistics 
  </clt></a>, respectively, provide thread-safe versions for applications that require concurrent access to statistical aggregates by multiple threads. <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/SynchronizedMultiVariateSummaryStatistics.html""> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"" api=""SynchronizedMultivariateSummaryStatistics"" kind=""class"">
    SynchronizedMultivariateSummaryStatistics 
  </clt></a> provides thread-safe <tt> 
  <clt fqn=""org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"" api=""MultivariateSummaryStatistics"" kind=""class"">
    MultivariateSummaryStatistics. 
  </clt></tt> </p> 
<p> There is also a utility class, <a href=""../apidocs/org/apache/commons/math3/stat/StatUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
    StatUtils 
  </clt></a>, that provides static methods for computing statistics directly from double[] arrays. </p> 
<p> Here are some examples showing how to compute Descriptive statistics. </p> 
<dl> 
 <dt>
   Compute summary statistics for a list of double values 
 </dt> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> aggregate (values are stored in memory): 
  <div class=""source""> 
   <pre>
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i &lt; inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> aggregate (values are 
  <b>not</b> stored in memory): 
  <div class=""source""> 
   <pre>
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); &lt;-- NOT AVAILABLE
        </pre> 
  </div> 
 </dd> 
 <dd>
   Using the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils"" api=""StatUtils"" kind=""class"">
     StatUtils 
   </clt></tt> utility class: 
  <div class=""source""> 
   <pre>
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);
        </pre> 
  </div> 
 </dd> 
 <dt>
   Maintain a &quot;rolling mean&quot; of the most recent 100 values from an input stream 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
     DescriptiveStatistics 
   </clt></tt> instance with window size set to 100 
  <div class=""source""> 
   <pre>
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics in a thread-safe manner 
 </dt> 
 <dd>
   Use a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"" api=""SynchronizedDescriptiveStatistics"" kind=""class"">
     SynchronizedDescriptiveStatistics 
   </clt></tt> instance 
  <div class=""source""> 
   <pre>
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();
        </pre> 
  </div> 
 </dd> 
 <dt>
   Compute statistics for multiple samples and overall statistics concurrently 
 </dt> 
 <dd>
   There are two ways to do this using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics. 
   </clt></tt> The first is to use an 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"" api=""AggregateSummaryStatistics"" kind=""class"">
     AggregateSummaryStatistics 
   </clt></tt> instance to accumulate overall statistics contributed by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instances created using 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#createContributingStatistics""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"" api=""createContributingStatistics"" kind=""method"">
     AggregateSummaryStatistics.createContributingStatistics() 
   </clt></a>: 
  <div class=""source""> 
   <pre>
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        </pre> 
  </div> The above approach has the disadvantages that the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics.addValue"" api=""addValue"" kind=""class"">
     addValue 
   </clt></tt> calls must be synchronized on the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
     SummaryStatistics 
   </clt></tt> instance maintained by the aggregate and each value addition updates the aggregate as well as the subsample. For applications that can wait to do the aggregation until all values have been added, a static 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.html#aggregatejava.util.Collection""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"" api=""aggregate"" kind=""unknown"">
     aggregate 
   </clt></a> method is available, as shown in the following example. This method should be used when aggregation needs to be done across threads. 
  <div class=""source""> 
   <pre>
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection&lt;SummaryStatistics&gt; aggregate = new ArrayList&lt;SummaryStatistics&gt;();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();
        </pre> 
  </div> 
 </dd> 
</dl>",aggregate,unknown
,1.3 Frequency distributions,"<clt fqn=""org.apache.commons.math3.stat.Frequency"" api=""Frequency"" kind=""unknown"">
  1.3 Frequency distributions Frequency provides a simple interface for maintaining counts and percentages of discrete values. Strings, integers, longs and chars are all supported as value types, as well as instances of any class that implements Comparable. The ordering of values used in computing cumulative frequencies is by default the natural ordering, but this can be overriden by supplying a Comparator to the constructor. Adding values that are not comparable to those that have already been added results in an IllegalArgumentException. Here are some examples. Compute a frequency distribution based on integer values Mixing integers, longs, Integers and Longs: Frequency f = new Frequency(); f.addValue(1); f.addValue(new Integer(1)); f.addValue(new Long(1)); f.addValue(2); f.addValue(new Integer(-1)); System.out.prinltn(f.getCount(1)); // displays 3 System.out.println(f.getCumPct(0)); // displays 0.2 System.out.println(f.getPct(new Integer(1))); // displays 0.6 System.out.println(f.getCumPct(-2)); // displays 0 System.out.println(f.getCumPct(10)); // displays 1 Count string frequencies Using case-sensitive comparison, alpha sort order (natural comparator): Frequency f = new Frequency(); f.addValue(&quot;one&quot;); f.addValue(&quot;One&quot;); f.addValue(&quot;oNe&quot;); f.addValue(&quot;Z&quot;); System.out.println(f.getCount(&quot;one&quot;)); // displays 1 System.out.println(f.getCumPct(&quot;Z&quot;)); // displays 0.5 System.out.println(f.getCumPct(&quot;Ot&quot;)); // displays 0.25 Using case-insensitive comparator: Frequency f = new Frequency(String.CASE_INSENSITIVE_ORDER); f.addValue(&quot;one&quot;); f.addValue(&quot;One&quot;); f.addValue(&quot;oNe&quot;); f.addValue(&quot;Z&quot;); System.out.println(f.getCount(&quot;one&quot;)); // displays 3 System.out.println(f.getCumPct(&quot;z&quot;)); // displays 1 
</clt>",Frequency,unknown
,1.4 Simple regression,"<h3>1.4 Simple regression</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/stat/regression/SimpleRegression.html""> 
  <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression"" api=""SimpleRegression"" kind=""class"">
    SimpleRegression 
  </clt></a> provides ordinary least squares regression with one independent variable estimating the linear model: </p> 
<p> <tt> y = intercept + slope * x </tt> </p> 
<p> or </p> 
<p> <tt> y = slope * x </tt> </p> 
<p> Standard errors for <tt>intercept</tt> and <tt>slope</tt> are available as well as ANOVA, r-square and Pearson's r statistics. </p> 
<p> Observations (x,y pairs) can be added to the model one at a time or they can be provided in a 2-dimensional array. The observations are not stored in memory, so there is no limit to the number of observations that can be added to the model. </p> 
<p> <b>Usage Notes</b>: </p> 
<ul> 
 <li> When there are fewer than two observations in the model, or when there is no variation in the x values (i.e. all x values are the same) all statistics return <tt>NaN</tt>. At least two observations with different x coordinates are requred to estimate a bivariate regression model.</li> 
 <li> getters for the statistics always compute values based on the current set of observations -- i.e., you can get statistics, then add more data and get updated statistics without using a new instance. There is no &quot;compute&quot; method that updates all statistics. Each of the getters performs the necessary computations to return the requested statistic.</li> 
 <li> The intercept term may be suppressed by passing <tt>false</tt> to the <a href=""../apidocs/org/apache/commons/math3/stat/regression/SimpleRegression.html#SimpleRegressionboolean""> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.SimpleRegression"" api=""SimpleRegression"" kind=""method"">
     SimpleRegression(boolean) 
   </clt></a> constructor. When the <tt> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.hasIntercept"" api=""hasIntercept"" kind=""class"">
     hasIntercept 
   </clt></tt> property is false, the model is estimated without a constant term and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.getIntercept"" api=""getIntercept"" kind=""method"">
     getIntercept() 
   </clt></tt> returns <tt>0</tt>.</li> 
</ul> 
<p> <b>Implementation Notes</b>: </p> 
<ul> 
 <li> As observations are added to the model, the sum of x values, y values, cross products (x times y), and squared deviations of x and y from their respective means are updated using updating formulas defined in &quot;Algorithms for Computing the Sample Variance: Analysis and Recommendations&quot;, Chan, T.F., Golub, G.H., and LeVeque, R.J. 1983, American Statistician, vol. 37, pp. 242-247, referenced in Weisberg, S. &quot;Applied Linear Regression&quot;. 2nd Ed. 1985. All regression statistics are computed from these sums.</li> 
 <li> Inference statistics (confidence intervals, parameter significance levels) are based on on the assumption that the observations included in the model are drawn from a <a class=""externalLink"" href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a></li> 
</ul> 
<p> Here are some examples. </p> 
<dl> 
 <dt>
   Estimate a model based on observations added one at a time 
 </dt> 
 <dd>
   Instantiate a regression instance and add data points 
  <div class=""source""> 
   <pre>
regression = new SimpleRegression();
regression.addData(1d, 2d);
// At this point, with only one observation,
// all regression statistics will return NaN

regression.addData(3d, 3d);
// With only two observations,
// slope and intercept can be computed
// but inference statistics will return NaN

regression.addData(3d, 3d);
// Now all statistics are defined.
         </pre> 
  </div> 
 </dd> 
 <dd>
   Compute some statistics based on observations added so far 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error
         </pre> 
  </div> 
 </dd> 
 <dd>
   Use the regression model to predict the y value for a new x value 
  <div class=""source""> 
   <pre>
System.out.println(regression.predict(1.5d)
// displays predicted y value for x = 1.5
         </pre> 
  </div> More data points can be added and subsequent getXxx calls will incorporate additional data in statistics. 
 </dd> 
 <dt>
   Estimate a model from a double[][] array of data points 
 </dt> 
 <dd>
   Instantiate a regression object and load dataset 
  <div class=""source""> 
   <pre>
double[][] data = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};
SimpleRegression regression = new SimpleRegression();
regression.addData(data);
          </pre> 
  </div> 
 </dd> 
 <dd>
   Estimate regression model based on data 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error
         </pre> 
  </div> More data points -- even another double[][] array -- can be added and subsequent getXxx calls will incorporate additional data in statistics. 
 </dd> 
 <dt>
   Estimate a model from a double[][] array of data points, 
  <i>excluding</i> the intercept 
 </dt> 
 <dd>
   Instantiate a regression object and load dataset 
  <div class=""source""> 
   <pre>
double[][] data = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};
SimpleRegression regression = new SimpleRegression(false);
//the argument, false, tells the class not to include a constant
regression.addData(data);
          </pre> 
  </div> 
 </dd> 
 <dd>
   Estimate regression model based on data 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line, since we have constrained the constant, 0.0 is returned

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error

System.out.println(regression.getInterceptStdErr() );
// will return Double.NaN, since we constrained the parameter to zero
         </pre> 
  </div> Caution must be exercised when interpreting the slope when no constant is being estimated. The slope may be biased. 
 </dd> 
</dl>",SimpleRegression,class
,1.4 Simple regression,"<h3>1.4 Simple regression</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/stat/regression/SimpleRegression.html""> 
  <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression"" api=""SimpleRegression"" kind=""class"">
    SimpleRegression 
  </clt></a> provides ordinary least squares regression with one independent variable estimating the linear model: </p> 
<p> <tt> y = intercept + slope * x </tt> </p> 
<p> or </p> 
<p> <tt> y = slope * x </tt> </p> 
<p> Standard errors for <tt>intercept</tt> and <tt>slope</tt> are available as well as ANOVA, r-square and Pearson's r statistics. </p> 
<p> Observations (x,y pairs) can be added to the model one at a time or they can be provided in a 2-dimensional array. The observations are not stored in memory, so there is no limit to the number of observations that can be added to the model. </p> 
<p> <b>Usage Notes</b>: </p> 
<ul> 
 <li> When there are fewer than two observations in the model, or when there is no variation in the x values (i.e. all x values are the same) all statistics return <tt>NaN</tt>. At least two observations with different x coordinates are requred to estimate a bivariate regression model.</li> 
 <li> getters for the statistics always compute values based on the current set of observations -- i.e., you can get statistics, then add more data and get updated statistics without using a new instance. There is no &quot;compute&quot; method that updates all statistics. Each of the getters performs the necessary computations to return the requested statistic.</li> 
 <li> The intercept term may be suppressed by passing <tt>false</tt> to the <a href=""../apidocs/org/apache/commons/math3/stat/regression/SimpleRegression.html#SimpleRegressionboolean""> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.SimpleRegression"" api=""SimpleRegression"" kind=""method"">
     SimpleRegression(boolean) 
   </clt></a> constructor. When the <tt> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.hasIntercept"" api=""hasIntercept"" kind=""class"">
     hasIntercept 
   </clt></tt> property is false, the model is estimated without a constant term and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.getIntercept"" api=""getIntercept"" kind=""method"">
     getIntercept() 
   </clt></tt> returns <tt>0</tt>.</li> 
</ul> 
<p> <b>Implementation Notes</b>: </p> 
<ul> 
 <li> As observations are added to the model, the sum of x values, y values, cross products (x times y), and squared deviations of x and y from their respective means are updated using updating formulas defined in &quot;Algorithms for Computing the Sample Variance: Analysis and Recommendations&quot;, Chan, T.F., Golub, G.H., and LeVeque, R.J. 1983, American Statistician, vol. 37, pp. 242-247, referenced in Weisberg, S. &quot;Applied Linear Regression&quot;. 2nd Ed. 1985. All regression statistics are computed from these sums.</li> 
 <li> Inference statistics (confidence intervals, parameter significance levels) are based on on the assumption that the observations included in the model are drawn from a <a class=""externalLink"" href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a></li> 
</ul> 
<p> Here are some examples. </p> 
<dl> 
 <dt>
   Estimate a model based on observations added one at a time 
 </dt> 
 <dd>
   Instantiate a regression instance and add data points 
  <div class=""source""> 
   <pre>
regression = new SimpleRegression();
regression.addData(1d, 2d);
// At this point, with only one observation,
// all regression statistics will return NaN

regression.addData(3d, 3d);
// With only two observations,
// slope and intercept can be computed
// but inference statistics will return NaN

regression.addData(3d, 3d);
// Now all statistics are defined.
         </pre> 
  </div> 
 </dd> 
 <dd>
   Compute some statistics based on observations added so far 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error
         </pre> 
  </div> 
 </dd> 
 <dd>
   Use the regression model to predict the y value for a new x value 
  <div class=""source""> 
   <pre>
System.out.println(regression.predict(1.5d)
// displays predicted y value for x = 1.5
         </pre> 
  </div> More data points can be added and subsequent getXxx calls will incorporate additional data in statistics. 
 </dd> 
 <dt>
   Estimate a model from a double[][] array of data points 
 </dt> 
 <dd>
   Instantiate a regression object and load dataset 
  <div class=""source""> 
   <pre>
double[][] data = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};
SimpleRegression regression = new SimpleRegression();
regression.addData(data);
          </pre> 
  </div> 
 </dd> 
 <dd>
   Estimate regression model based on data 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error
         </pre> 
  </div> More data points -- even another double[][] array -- can be added and subsequent getXxx calls will incorporate additional data in statistics. 
 </dd> 
 <dt>
   Estimate a model from a double[][] array of data points, 
  <i>excluding</i> the intercept 
 </dt> 
 <dd>
   Instantiate a regression object and load dataset 
  <div class=""source""> 
   <pre>
double[][] data = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};
SimpleRegression regression = new SimpleRegression(false);
//the argument, false, tells the class not to include a constant
regression.addData(data);
          </pre> 
  </div> 
 </dd> 
 <dd>
   Estimate regression model based on data 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line, since we have constrained the constant, 0.0 is returned

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error

System.out.println(regression.getInterceptStdErr() );
// will return Double.NaN, since we constrained the parameter to zero
         </pre> 
  </div> Caution must be exercised when interpreting the slope when no constant is being estimated. The slope may be biased. 
 </dd> 
</dl>",hasIntercept,class
,1.4 Simple regression,"<h3>1.4 Simple regression</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/stat/regression/SimpleRegression.html""> 
  <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression"" api=""SimpleRegression"" kind=""class"">
    SimpleRegression 
  </clt></a> provides ordinary least squares regression with one independent variable estimating the linear model: </p> 
<p> <tt> y = intercept + slope * x </tt> </p> 
<p> or </p> 
<p> <tt> y = slope * x </tt> </p> 
<p> Standard errors for <tt>intercept</tt> and <tt>slope</tt> are available as well as ANOVA, r-square and Pearson's r statistics. </p> 
<p> Observations (x,y pairs) can be added to the model one at a time or they can be provided in a 2-dimensional array. The observations are not stored in memory, so there is no limit to the number of observations that can be added to the model. </p> 
<p> <b>Usage Notes</b>: </p> 
<ul> 
 <li> When there are fewer than two observations in the model, or when there is no variation in the x values (i.e. all x values are the same) all statistics return <tt>NaN</tt>. At least two observations with different x coordinates are requred to estimate a bivariate regression model.</li> 
 <li> getters for the statistics always compute values based on the current set of observations -- i.e., you can get statistics, then add more data and get updated statistics without using a new instance. There is no &quot;compute&quot; method that updates all statistics. Each of the getters performs the necessary computations to return the requested statistic.</li> 
 <li> The intercept term may be suppressed by passing <tt>false</tt> to the <a href=""../apidocs/org/apache/commons/math3/stat/regression/SimpleRegression.html#SimpleRegressionboolean""> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.SimpleRegression"" api=""SimpleRegression"" kind=""method"">
     SimpleRegression(boolean) 
   </clt></a> constructor. When the <tt> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.hasIntercept"" api=""hasIntercept"" kind=""class"">
     hasIntercept 
   </clt></tt> property is false, the model is estimated without a constant term and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.regression.SimpleRegression.getIntercept"" api=""getIntercept"" kind=""method"">
     getIntercept() 
   </clt></tt> returns <tt>0</tt>.</li> 
</ul> 
<p> <b>Implementation Notes</b>: </p> 
<ul> 
 <li> As observations are added to the model, the sum of x values, y values, cross products (x times y), and squared deviations of x and y from their respective means are updated using updating formulas defined in &quot;Algorithms for Computing the Sample Variance: Analysis and Recommendations&quot;, Chan, T.F., Golub, G.H., and LeVeque, R.J. 1983, American Statistician, vol. 37, pp. 242-247, referenced in Weisberg, S. &quot;Applied Linear Regression&quot;. 2nd Ed. 1985. All regression statistics are computed from these sums.</li> 
 <li> Inference statistics (confidence intervals, parameter significance levels) are based on on the assumption that the observations included in the model are drawn from a <a class=""externalLink"" href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a></li> 
</ul> 
<p> Here are some examples. </p> 
<dl> 
 <dt>
   Estimate a model based on observations added one at a time 
 </dt> 
 <dd>
   Instantiate a regression instance and add data points 
  <div class=""source""> 
   <pre>
regression = new SimpleRegression();
regression.addData(1d, 2d);
// At this point, with only one observation,
// all regression statistics will return NaN

regression.addData(3d, 3d);
// With only two observations,
// slope and intercept can be computed
// but inference statistics will return NaN

regression.addData(3d, 3d);
// Now all statistics are defined.
         </pre> 
  </div> 
 </dd> 
 <dd>
   Compute some statistics based on observations added so far 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error
         </pre> 
  </div> 
 </dd> 
 <dd>
   Use the regression model to predict the y value for a new x value 
  <div class=""source""> 
   <pre>
System.out.println(regression.predict(1.5d)
// displays predicted y value for x = 1.5
         </pre> 
  </div> More data points can be added and subsequent getXxx calls will incorporate additional data in statistics. 
 </dd> 
 <dt>
   Estimate a model from a double[][] array of data points 
 </dt> 
 <dd>
   Instantiate a regression object and load dataset 
  <div class=""source""> 
   <pre>
double[][] data = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};
SimpleRegression regression = new SimpleRegression();
regression.addData(data);
          </pre> 
  </div> 
 </dd> 
 <dd>
   Estimate regression model based on data 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error
         </pre> 
  </div> More data points -- even another double[][] array -- can be added and subsequent getXxx calls will incorporate additional data in statistics. 
 </dd> 
 <dt>
   Estimate a model from a double[][] array of data points, 
  <i>excluding</i> the intercept 
 </dt> 
 <dd>
   Instantiate a regression object and load dataset 
  <div class=""source""> 
   <pre>
double[][] data = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};
SimpleRegression regression = new SimpleRegression(false);
//the argument, false, tells the class not to include a constant
regression.addData(data);
          </pre> 
  </div> 
 </dd> 
 <dd>
   Estimate regression model based on data 
  <div class=""source""> 
   <pre>
System.out.println(regression.getIntercept());
// displays intercept of regression line, since we have constrained the constant, 0.0 is returned

System.out.println(regression.getSlope());
// displays slope of regression line

System.out.println(regression.getSlopeStdErr());
// displays slope standard error

System.out.println(regression.getInterceptStdErr() );
// will return Double.NaN, since we constrained the parameter to zero
         </pre> 
  </div> Caution must be exercised when interpreting the slope when no constant is being estimated. The slope may be biased. 
 </dd> 
</dl>",getIntercept,method
,1.6 Rank transformations,"<h3>1.6 Rank transformations</h3> 
<p> Some statistical algorithms require that input data be replaced by ranks. The <a href=""../apidocs/org/apache/commons/math3/stat/ranking/package-summary.html""> org.apache.commons.math3.stat.ranking</a> package provides rank transformation. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/RankingAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.RankingAlgorithm"" api=""RankingAlgorithm"" kind=""class"">
    RankingAlgorithm 
  </clt></a> defines the interface for ranking. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> provides an implementation that has two configuration options. </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> Ties strategy</a> deterimines how ties in the source data are handled by the ranking</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> NaN strategy</a> determines how NaN values in the source data are handled.</li> 
</ul> 
<p> Examples: </p> 
<div class=""source""> 
 <pre>
NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,
TiesStrategy.MAXIMUM);
double[] data = { 20, 17, 30, 42.3, 17, 50,
                  Double.NaN, Double.NEGATIVE_INFINITY, 17 };
double[] ranks = ranking.rank(exampleData);
         </pre> 
</div> results in 
<tt>ranks</tt> containing 
<tt>{6, 5, 7, 8, 5, 9, 2, 2, 5}.</tt> 
<div class=""source""> 
 <pre>
new NaturalRanking(NaNStrategy.REMOVED,TiesStrategy.SEQUENTIAL).rank(exampleData);   
         </pre> 
</div> returns 
<tt>{5, 2, 6, 7, 3, 8, 1, 4}.</tt> 
<p> The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></tt> is NaNStrategy.MAXIMAL. This makes <tt>NaN</tt> values larger than any other value (including <tt>Double.POSITIVE_INFINITY</tt>). The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></tt> is <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy.AVERAGE"" api=""AVERAGE"" kind=""field"">
    TiesStrategy.AVERAGE, 
  </clt></tt> which assigns tied values the average of the ranks applicable to the sequence of ties. See the <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> for more examples and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></a> for details on these configuration options. </p>",RankingAlgorithm,class
,1.6 Rank transformations,"<h3>1.6 Rank transformations</h3> 
<p> Some statistical algorithms require that input data be replaced by ranks. The <a href=""../apidocs/org/apache/commons/math3/stat/ranking/package-summary.html""> org.apache.commons.math3.stat.ranking</a> package provides rank transformation. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/RankingAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.RankingAlgorithm"" api=""RankingAlgorithm"" kind=""class"">
    RankingAlgorithm 
  </clt></a> defines the interface for ranking. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> provides an implementation that has two configuration options. </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> Ties strategy</a> deterimines how ties in the source data are handled by the ranking</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> NaN strategy</a> determines how NaN values in the source data are handled.</li> 
</ul> 
<p> Examples: </p> 
<div class=""source""> 
 <pre>
NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,
TiesStrategy.MAXIMUM);
double[] data = { 20, 17, 30, 42.3, 17, 50,
                  Double.NaN, Double.NEGATIVE_INFINITY, 17 };
double[] ranks = ranking.rank(exampleData);
         </pre> 
</div> results in 
<tt>ranks</tt> containing 
<tt>{6, 5, 7, 8, 5, 9, 2, 2, 5}.</tt> 
<div class=""source""> 
 <pre>
new NaturalRanking(NaNStrategy.REMOVED,TiesStrategy.SEQUENTIAL).rank(exampleData);   
         </pre> 
</div> returns 
<tt>{5, 2, 6, 7, 3, 8, 1, 4}.</tt> 
<p> The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></tt> is NaNStrategy.MAXIMAL. This makes <tt>NaN</tt> values larger than any other value (including <tt>Double.POSITIVE_INFINITY</tt>). The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></tt> is <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy.AVERAGE"" api=""AVERAGE"" kind=""field"">
    TiesStrategy.AVERAGE, 
  </clt></tt> which assigns tied values the average of the ranks applicable to the sequence of ties. See the <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> for more examples and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></a> for details on these configuration options. </p>",NaturalRanking,class
,1.6 Rank transformations,"<h3>1.6 Rank transformations</h3> 
<p> Some statistical algorithms require that input data be replaced by ranks. The <a href=""../apidocs/org/apache/commons/math3/stat/ranking/package-summary.html""> org.apache.commons.math3.stat.ranking</a> package provides rank transformation. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/RankingAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.RankingAlgorithm"" api=""RankingAlgorithm"" kind=""class"">
    RankingAlgorithm 
  </clt></a> defines the interface for ranking. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> provides an implementation that has two configuration options. </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> Ties strategy</a> deterimines how ties in the source data are handled by the ranking</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> NaN strategy</a> determines how NaN values in the source data are handled.</li> 
</ul> 
<p> Examples: </p> 
<div class=""source""> 
 <pre>
NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,
TiesStrategy.MAXIMUM);
double[] data = { 20, 17, 30, 42.3, 17, 50,
                  Double.NaN, Double.NEGATIVE_INFINITY, 17 };
double[] ranks = ranking.rank(exampleData);
         </pre> 
</div> results in 
<tt>ranks</tt> containing 
<tt>{6, 5, 7, 8, 5, 9, 2, 2, 5}.</tt> 
<div class=""source""> 
 <pre>
new NaturalRanking(NaNStrategy.REMOVED,TiesStrategy.SEQUENTIAL).rank(exampleData);   
         </pre> 
</div> returns 
<tt>{5, 2, 6, 7, 3, 8, 1, 4}.</tt> 
<p> The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></tt> is NaNStrategy.MAXIMAL. This makes <tt>NaN</tt> values larger than any other value (including <tt>Double.POSITIVE_INFINITY</tt>). The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></tt> is <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy.AVERAGE"" api=""AVERAGE"" kind=""field"">
    TiesStrategy.AVERAGE, 
  </clt></tt> which assigns tied values the average of the ranks applicable to the sequence of ties. See the <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> for more examples and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></a> for details on these configuration options. </p>",NaNStrategy,class
,1.6 Rank transformations,"<h3>1.6 Rank transformations</h3> 
<p> Some statistical algorithms require that input data be replaced by ranks. The <a href=""../apidocs/org/apache/commons/math3/stat/ranking/package-summary.html""> org.apache.commons.math3.stat.ranking</a> package provides rank transformation. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/RankingAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.RankingAlgorithm"" api=""RankingAlgorithm"" kind=""class"">
    RankingAlgorithm 
  </clt></a> defines the interface for ranking. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> provides an implementation that has two configuration options. </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> Ties strategy</a> deterimines how ties in the source data are handled by the ranking</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> NaN strategy</a> determines how NaN values in the source data are handled.</li> 
</ul> 
<p> Examples: </p> 
<div class=""source""> 
 <pre>
NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,
TiesStrategy.MAXIMUM);
double[] data = { 20, 17, 30, 42.3, 17, 50,
                  Double.NaN, Double.NEGATIVE_INFINITY, 17 };
double[] ranks = ranking.rank(exampleData);
         </pre> 
</div> results in 
<tt>ranks</tt> containing 
<tt>{6, 5, 7, 8, 5, 9, 2, 2, 5}.</tt> 
<div class=""source""> 
 <pre>
new NaturalRanking(NaNStrategy.REMOVED,TiesStrategy.SEQUENTIAL).rank(exampleData);   
         </pre> 
</div> returns 
<tt>{5, 2, 6, 7, 3, 8, 1, 4}.</tt> 
<p> The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></tt> is NaNStrategy.MAXIMAL. This makes <tt>NaN</tt> values larger than any other value (including <tt>Double.POSITIVE_INFINITY</tt>). The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></tt> is <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy.AVERAGE"" api=""AVERAGE"" kind=""field"">
    TiesStrategy.AVERAGE, 
  </clt></tt> which assigns tied values the average of the ranks applicable to the sequence of ties. See the <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> for more examples and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></a> for details on these configuration options. </p>",TiesStrategy,class
,1.6 Rank transformations,"<h3>1.6 Rank transformations</h3> 
<p> Some statistical algorithms require that input data be replaced by ranks. The <a href=""../apidocs/org/apache/commons/math3/stat/ranking/package-summary.html""> org.apache.commons.math3.stat.ranking</a> package provides rank transformation. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/RankingAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.RankingAlgorithm"" api=""RankingAlgorithm"" kind=""class"">
    RankingAlgorithm 
  </clt></a> defines the interface for ranking. <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> provides an implementation that has two configuration options. </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> Ties strategy</a> deterimines how ties in the source data are handled by the ranking</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> NaN strategy</a> determines how NaN values in the source data are handled.</li> 
</ul> 
<p> Examples: </p> 
<div class=""source""> 
 <pre>
NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,
TiesStrategy.MAXIMUM);
double[] data = { 20, 17, 30, 42.3, 17, 50,
                  Double.NaN, Double.NEGATIVE_INFINITY, 17 };
double[] ranks = ranking.rank(exampleData);
         </pre> 
</div> results in 
<tt>ranks</tt> containing 
<tt>{6, 5, 7, 8, 5, 9, 2, 2, 5}.</tt> 
<div class=""source""> 
 <pre>
new NaturalRanking(NaNStrategy.REMOVED,TiesStrategy.SEQUENTIAL).rank(exampleData);   
         </pre> 
</div> returns 
<tt>{5, 2, 6, 7, 3, 8, 1, 4}.</tt> 
<p> The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></tt> is NaNStrategy.MAXIMAL. This makes <tt>NaN</tt> values larger than any other value (including <tt>Double.POSITIVE_INFINITY</tt>). The default <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></tt> is <tt> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy.AVERAGE"" api=""AVERAGE"" kind=""field"">
    TiesStrategy.AVERAGE, 
  </clt></tt> which assigns tied values the average of the ranks applicable to the sequence of ties. See the <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaturalRanking.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
    NaturalRanking 
  </clt></a> for more examples and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/TiesStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.TiesStrategy"" api=""TiesStrategy"" kind=""class"">
    TiesStrategy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/stat/ranking/NaNStrategy.html""> 
  <clt fqn=""org.apache.commons.math3.stat.ranking.NaNStrategy"" api=""NaNStrategy"" kind=""class"">
    NaNStrategy 
  </clt></a> for details on these configuration options. </p>",AVERAGE,field
,1.7 Covariance and correlation,"<clt fqn=""org.apache.commons.math3.stat.ranking.NaturalRanking"" api=""NaturalRanking"" kind=""class"">
  1.7 Covariance and correlation The org.apache.commons.math3.stat.correlation package computes covariances and correlations for pairs of arrays or columns of a matrix. Covariance computes covariances, PearsonsCorrelation provides Pearson's Product-Moment correlation coefficients and SpearmansCorrelation computes Spearman's rank correlation. Implementation Notes Unbiased covariances are given by the formula cov(X, Y) = sum [(xi - E(X))(yi - E(Y))] / (n - 1) where E(X) is the mean of X and E(Y) is the mean of the Y values. Non-bias-corrected estimates use n in place of n - 1. Whether or not covariances are bias-corrected is determined by the optional parameter, &quot;biasCorrected,&quot; which defaults to true. PearsonsCorrelation computes correlations defined by the formula cor(X, Y) = sum[(xi - E(X))(yi - E(Y))] / [(n - 1)s(X)s(Y)] where E(X) and E(Y) are means of X and Y and s(X), s(Y) are standard deviations. SpearmansCorrelation applies a rank transformation to the input data and computes Pearson's correlation on the ranked data. The ranking algorithm is configurable. By default, NaturalRanking with default strategies for handling ties and NaN values is used. Examples: Covariance of 2 arrays To compute the unbiased covariance between 2 double arrays, x and y, use: new Covariance().covariance(x, y) For non-bias-corrected covariances, use covariance(x, y, false) Covariance matrix A covariance matrix over the columns of a source matrix data can be computed using new Covariance().computeCovarianceMatrix(data) The i-jth entry of the returned matrix is the unbiased covariance of the ith and jth columns of data. As above, to get non-bias-corrected covariances, use computeCovarianceMatrix(data, false) Pearson's correlation of 2 arrays To compute the Pearson's product-moment correlation between two double arrays x and y, use: new PearsonsCorrelation().correlation(x, y) Pearson's correlation matrix A (Pearson's) correlation matrix over the columns of a source matrix data can be computed using new PearsonsCorrelation().computeCorrelationMatrix(data) The i-jth entry of the returned matrix is the Pearson's product-moment correlation between the ith and jth columns of data. Pearson's correlation significance and standard errors To compute standard errors and/or significances of correlation coefficients associated with Pearson's correlation coefficients, start by creating a PearsonsCorrelation instance PearsonsCorrelation correlation = new PearsonsCorrelation(data); where data is either a rectangular array or a RealMatrix. Then the matrix of standard errors is correlation.getCorrelationStandardErrors(); The formula used to compute the standard error is SEr = ((1 - r2) / (n - 2))1/2 where r is the estimated correlation coefficient and n is the number of observations in the source dataset. p-values for the (2-sided) null hypotheses that elements of a correlation matrix are zero populate the RealMatrix returned by correlation.getCorrelationPValues() getCorrelationPValues().getEntry(i,j) is the probability that a random variable distributed as tn-2 takes a value with absolute value greater than or equal to |rij|((n - 2) / (1 - rij2))1/2, where rij is the estimated correlation between the ith and jth columns of the source array or RealMatrix. This is sometimes referred to as the significance of the coefficient. For example, if data is a RealMatrix with 2 columns and 10 rows, then new PearsonsCorrelation(data).getCorrelationPValues().getEntry(0,1) is the significance of the Pearson's correlation coefficient between the two columns of data. If this value is less than .01, we can say that the correlation between the two columns of data is significant at the 99% level. Spearman's rank correlation coefficient To compute the Spearman's rank-moment correlation between two double arrays x and y: new SpearmansCorrelation().correlation(x, y) This is equivalent to RankingAlgorithm ranking = new NaturalRanking(); new PearsonsCorrelation().correlation(ranking.rank(x), ranking.rank(y)) 
</clt>",NaturalRanking,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",TTest,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",ChiSquareTest,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",GTest,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",OneWayAnova,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",MannWhitneyUTest,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",WilcoxonSignedRankTest,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",TestUtils,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",gTest,method
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",g,method
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",gTestIntrinsic,method
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",StatisticalSummary,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",pairedTTest,method
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",DescriptiveStatistics,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",SummaryStatistics,class
,1.8 Statistical Tests,"<h3>1.8 Statistical tests</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/stat/inference/""> org.apache.commons.math3.stat.inference</a> package provides implementations for <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm""> Student's t</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm""> Chi-Square</a>, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/G-test"">G Test</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc43.htm""> One-Way ANOVA</a>, <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc35.htm""> Mann-Whitney U</a> and <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test""> Wilcoxon signed rank</a> test statistics as well as <a class=""externalLink"" href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue""> p-values</a> associated with <tt>t-</tt>, <tt>Chi-Square</tt>, <tt>G</tt>, <tt>One-Way ANOVA</tt>, <tt>Mann-Whitney U</tt> and <tt>Wilcoxon signed rank</tt> tests. The respective test classes are <a href=""../apidocs/org/apache/commons/math3/stat/inference/TTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""class"">
    TTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/ChiSquareTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.ChiSquareTest"" api=""ChiSquareTest"" kind=""class"">
    ChiSquareTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/GTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
    GTest 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/OneWayAnova.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/stat/inference/MannWhitneyUTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.MannWhitneyUTest"" api=""MannWhitneyUTest"" kind=""class"">
    MannWhitneyUTest 
  </clt></a>, and <a href=""../apidocs/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"" api=""WilcoxonSignedRankTest"" kind=""class"">
    WilcoxonSignedRankTest 
  </clt></a>. The <a href=""../apidocs/org/apache/commons/math3/stat/inference/TestUtils.html""> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></a> class provides static methods to get test instances or to compute test statistics directly. The examples below all use the static methods in <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> to execute tests. To get test object instances, either use e.g., <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils.getTTest() 
  </clt></tt> or use the implementation constructors directly, e.g. <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TTest"" api=""TTest"" kind=""method"">
    new TTest() 
  </clt></tt>. </p> 
<p> <b>Implementation Notes</b> </p> 
<ul> 
 <li>Both one- and two-sample t-tests are supported. Two sample tests can be either paired or unpaired and the unpaired two-sample tests can be conducted under the assumption of equal subpopulation variances or without this assumption. When equal variances is assumed, a pooled variance estimate is used to compute the t-statistic and the degrees of freedom used in the t-test equals the sum of the sample sizes minus 2. When equal variances is not assumed, the t-statistic uses both sample variances and the <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section3/gifs/nu3.gif""> Welch-Satterwaite approximation</a> is used to compute the degrees of freedom. Methods to return t-statistics and p-values are provided in each case, as well as boolean-valued methods to perform fixed significance level tests. The names of methods or methods that assume equal subpopulation variances always start with &quot;homoscedastic.&quot; Test or test-statistic methods that just start with &quot;t&quot; do not assume equal variances. See the examples below and the API documentation for more details.</li> 
 <li>The validity of the p-values returned by the t-test depends on the assumptions of the parametric t-test procedure, as discussed <a class=""externalLink"" href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a></li> 
 <li>p-values returned by t-, chi-square and Anova tests are exact, based on numerical approximations to the t-, chi-square and F distributions in the <tt>distributions</tt> package. </li> 
 <li>The G test implementation provides two p-values: <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTest"" api=""gTest"" kind=""method"">
     gTest(expected, observed) 
   </clt></tt>, which is the tail probability beyond <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.g"" api=""g"" kind=""method"">
     g(expected, observed) 
   </clt></tt> in the ChiSquare distribution with degrees of freedom one less than the common length of input arrays and <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest.gTestIntrinsic"" api=""gTestIntrinsic"" kind=""method"">
     gTestIntrinsic(expected, observed) 
   </clt></tt> which is the same tail probability computed using a ChiSquare distribution with one less degeree of freedom. </li> 
 <li>p-values returned by t-tests are for two-sided tests and the boolean-valued methods supporting fixed significance level tests assume that the hypotheses are two-sided. One sided tests can be performed by dividing returned p-values (resp. critical values) by 2.</li> 
 <li>Degrees of freedom for G- and chi-square tests are integral values, based on the number of observed or expected counts (number of observed counts - 1).</li> 
</ul> 
<p> <b>Examples:</b> </p> 
<dl> 
 <dt> 
  <b>One-sample <tt>t</tt> tests</b> 
 </dt> 
 <dd>
   To compare the mean of a double[] array to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          </pre> 
  </div> The code above will display the t-statisitic associated with a one-sample t-test comparing the mean of the 
  <tt>observed</tt> values against 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To compare the mean of a dataset described by a 
  <a href=""../apidocs/org/apache/commons/math3/stat/descriptive/StatisticalSummary.html""> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></a> to a fixed value: 
  <div class=""source""> 
   <pre>
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i &lt; observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));
</pre> 
  </div> 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the mean of a set of values equals a point estimate, against the two-sided alternative that the mean is different from the target value: 
  <div class=""source""> 
   <pre>
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           </pre> 
  </div> The snippet above will display the p-value associated with the null hypothesis that the mean of the population from which the 
  <tt>observed</tt> values are drawn equals 
  <tt>mu.</tt> 
 </dd> 
 <dd>
   To perform the test using a fixed significance level, use: 
  <div class=""source""> 
   <pre>
TestUtils.tTest(mu, observed, alpha);
          </pre> 
  </div> where 
  <tt>0 &lt; alpha &lt; 0.5</tt> is the significance level of the test. The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. To test, for example at the 95% level of confidence, use 
  <tt>alpha = 0.05</tt> 
 </dd> 
 <dt> 
  <b>Two-Sample t-tests</b> 
 </dt> 
 <dd> 
  <b>Example 1:</b> Paired test evaluating the null hypothesis that the mean difference between corresponding (paired) elements of the 
  <tt>double[]</tt> arrays 
  <tt>sample1</tt> and 
  <tt>sample2</tt> is zero. 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedT(sample1, sample2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.pairedTTest(sample1, sample2, .05);
           </pre> 
  </div> The last example will return 
  <tt>true</tt> iff the p-value returned by 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"" api=""pairedTTest"" kind=""method"">
     TestUtils.pairedTTest(sample1, sample2) 
   </clt></tt> is less than 
  <tt>.05</tt> 
 </dd> 
 <dd> 
  <b>Example 2: </b> unpaired, two-sided, two-sample t-test using 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
     StatisticalSummary 
   </clt></tt> instances, without assuming that subpopulation variances are equal. 
  <p> First create the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.StatisticalSummary"" api=""StatisticalSummary"" kind=""class"">
      StatisticalSummary 
    </clt></tt> instances. Both <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"" api=""DescriptiveStatistics"" kind=""class"">
      DescriptiveStatistics 
    </clt></tt> and <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> implement this interface. Assume that <tt>summary1</tt> and <tt>summary2</tt> are <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> instances, each of which has had at least 2 values added to the (virtual) dataset that it describes. The sample sizes do not have to be the same -- all that is required is that both samples have at least 2 elements. </p> 
  <p><b>Note:</b> The <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class does not store the dataset that it describes in memory, but it does compute all statistics necessary to perform t-tests, so this method can be used to conduct t-tests with very large samples. One-sample tests can also be performed this way. (See <a href=""#a1.2_Descriptive_statistics"">Descriptive statistics</a> for details on the <tt> 
    <clt fqn=""org.apache.commons.math3.stat.descriptive.SummaryStatistics"" api=""SummaryStatistics"" kind=""class"">
      SummaryStatistics 
    </clt></tt> class.) </p> 
  <p> To compute the t-statistic: </p> 
  <div class=""source""> 
   <pre>
TestUtils.t(summary1, summary2);
          </pre> 
  </div> 
  <p> To compute the p-value: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2);
           </pre> 
  </div> 
  <p> To perform a fixed significance level test with alpha = .05: </p> 
  <div class=""source""> 
   <pre>
TestUtils.tTest(sample1, sample2, .05);
           </pre> 
  </div> 
  <p> In each case above, the test does not assume that the subpopulation variances are equal. To perform the tests under this assumption, replace &quot;t&quot; at the beginning of the method name with &quot;homoscedasticT&quot; </p> 
 </dd> 
 <dt> 
  <b>Chi-square tests</b> 
 </dt> 
 <dd>
   To compute a chi-square statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((expected[i] - observed[i])^2 / expected[i]) 
   </clt></tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To compute a chi-square statistic statistic associated with a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm""> chi-square test of independence</a> based on a two-dimensional (long[][]) 
  <tt>counts</tt> array viewed as a two-way table, use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts);
          </pre> 
  </div> The rows of the 2-way table are 
  <tt>count[0], ... , count[count.length - 1]. </tt> The chi-square statistic returned is 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.StatUtils.sum"" api=""sum"" kind=""unknown"">
     sum((counts[i][j] - expected[i][j])^2/expected[i][j]) 
   </clt></tt> where the sum is taken over all table entries and 
  <tt>expected[i][j]</tt> is the product of the row and column sums at row 
  <tt>i</tt>, column 
  <tt>j</tt> divided by the total count. 
 </dd> 
 <dd>
   To compute the p-value associated with the null hypothesis that the classifications represented by the counts in the columns of the input 2-way table are independent of the rows, use: 
  <div class=""source""> 
   <pre>
 TestUtils.chiSquareTest(counts);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To perform a chi-square test of independence with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt>0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.chiSquareTest(counts, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dt> 
  <b>G tests</b> 
 </dt> 
 <dd>
   G tests are an alternative to chi-square tests that are recommended when observed counts are small and / or incidence probabillities for some cells are small. See Ted Dunning's paper, 
  <a class=""externalLink"" href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.5962""> Accurate Methods for the Statistics of Surprise and Coincidence</a> for background and an empirical analysis showing now chi-square statistics can be misldeading in the presence of low incidence probabilities. This paper also derives the formulas used in computing G statistics and the root log likelihood ratio provided by the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.stat.inference.GTest"" api=""GTest"" kind=""class"">
     GTest 
   </clt></tt> class. 
 </dd> 
 <dd>
   To compute a G-test statistic measuring the agreement between a 
  <tt>long[]</tt> array of observed counts and a 
  <tt>double[]</tt> array of expected counts, use: 
  <div class=""source""> 
   <pre>
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          </pre> 
  </div> the value displayed will be 
  <tt>2 * sum(observed[i]) * log(observed[i]/expected[i])</tt> 
 </dd> 
 <dd>
   To get the p-value associated with the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed);
          </pre> 
  </div> 
 </dd> 
 <dd>
   To test the null hypothesis that 
  <tt>observed</tt> conforms to 
  <tt>expected</tt> with 
  <tt>alpha</tt> siginficance level (equiv. 
  <tt>100 * (1-alpha)%</tt> confidence) where 
  <tt> 0 &lt; alpha &lt; 1 </tt> use: 
  <div class=""source""> 
   <pre>
TestUtils.gTest(expected, observed, alpha);
          </pre> 
  </div> The boolean value returned will be 
  <tt>true</tt> iff the null hypothesis can be rejected with confidence 
  <tt>1 - alpha</tt>. 
 </dd> 
 <dd>
   To evaluate the hypothesis that two sets of counts come from the same underlying distribution, use long[] arrays for the counts and 
  <tt>gDataSetsComparison</tt> for the test statistic 
  <div class=""source""> 
   <pre>
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          </pre> 
  </div> 
 </dd> 
 <dd>
   For 2 x 2 designs, the 
  <tt>rootLogLikelihoodRaio</tt> method computes the 
  <a class=""externalLink"" href=""http://tdunning.blogspot.com/2008/03/surprise-and-coincidence.html""> signed root log likelihood ratio.</a> For example, suppose that for two events A and B, the observed count of AB (both occurring) is 5, not A and B (B without A) is 1995, A not B is 0; and neither A nor B is 10000. Then 
  <div class=""source""> 
   <pre>
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          </pre> 
  </div> returns the root log likelihood associated with the null hypothesis that A and B are independent. 
 </dd> 
 <dt> 
  <b>One-Way Anova tests</b> 
 </dt> 
 <div class=""source""> 
  <pre>
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          </pre> 
 </div> Then you can compute ANOVA F- or p-values associated with the null hypothesis that the class means are all the same using a 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.OneWayAnova"" api=""OneWayAnova"" kind=""class"">
    OneWayAnova 
  </clt></tt> instance or 
 <tt> 
  <clt fqn=""org.apache.commons.math3.stat.inference.TestUtils"" api=""TestUtils"" kind=""class"">
    TestUtils 
  </clt></tt> methods: 
 <div class=""source""> 
  <pre>
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          </pre> 
 </div> To test perform a One-Way Anova test with signficance level set at 0.01 (so the test will, assuming assumptions are met, reject the null hypothesis incorrectly only about one in 100 times), use 
 <div class=""source""> 
  <pre>
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis
          </pre> 
 </div> 
</dl>",sum,unknown
,2.1 Overview,"<h3>2.1 Overview</h3> 
<p> The Commons Math random package includes utilities for </p> 
<ul> 
 <li>generating random numbers</li> 
 <li>generating random vectors</li> 
 <li>generating random strings</li> 
 <li>generating cryptographically secure sequences of random numbers or strings</li> 
 <li>generating random samples and permutations</li> 
 <li>analyzing distributions of values in an input file and generating values &quot;like&quot; the values in the file</li> 
 <li>generating data for grouped frequency distributions or histograms</li> 
</ul> 
<p> The source of random data used by the data generation utilities is pluggable. By default, the JDK-supplied PseudoRandom Number Generator (PRNG) is used, but alternative generators can be &quot;plugged in&quot; using an adaptor framework, which provides a generic facility for replacing <tt>java.util.Random</tt> with an alternative PRNG. Other very good PRNG suitable for Monte-Carlo analysis (but <b>not</b> for cryptography) provided by the library are the Mersenne twister from Makoto Matsumoto and Takuji Nishimura and the more recent WELL generators (Well Equidistributed Long-period Linear) from Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto. </p> 
<p> Sections 2.2-2.6 below show how to use the commons math API to generate different kinds of random data. The examples all use the default JDK-supplied PRNG. PRNG pluggability is covered in 2.7. The only modification required to the examples to use alternative PRNGs is to replace the argumentless constructor calls with invocations including a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance as a parameter. </p>",RandomGenerator,class
,2.2 Random numbers,"<h3>2.2 Random numbers</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/random/RandomData.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></a> interface defines methods for generating random sequences of numbers. The API contracts of these methods use the following concepts: </p> 
<dl> 
 <dt>
   Random sequence of numbers from a probability distribution 
 </dt> 
 <dd>
   There is no such thing as a single &quot;random number.&quot; What can be generated are 
  <i>sequences</i> of numbers that appear to be random. When using the built-in JDK function 
  <tt>Math.random(),</tt> sequences of values generated follow the 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm""> Uniform Distribution</a>, which means that the values are evenly spread over the interval between 0 and 1, with no sub-interval having a greater probability of containing generated values than any other interval of the same length. The mathematical concept of a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda36.htm""> probability distribution</a> basically amounts to asserting that different ranges in the set of possible values of a random variable have different probabilities of containing the value. Commons Math supports generating random sequences from each of the distributions in the 
  <a href=""../apidocs/org/apache/commons/math3/distribution/package-summary.html""> distributions</a> package. The javadoc for the 
  <tt>nextXxx</tt> methods in 
  <a href=""../apidocs/org/apache/commons/math3/random/RandomDataImpl.html""> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></a> describes the algorithms used to generate random deviates. 
 </dd> 
 <dt>
   Cryptographically secure random sequences 
 </dt> 
 <dd>
   It is possible for a sequence of numbers to appear random, but nonetheless to be predictable based on the algorithm used to generate the sequence. If in addition to randomness, strong unpredictability is required, it is best to use a 
  <a class=""externalLink"" href=""http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator""> secure random number generator</a> to generate values (or strings). The nextSecureXxx methods in the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> implementation of the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> interface use the JDK 
  <tt>SecureRandom</tt> PRNG to generate cryptographically secure sequences. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.setSecureAlgorithm"" api=""setSecureAlgorithm"" kind=""class"">
     setSecureAlgorithm 
   </clt></tt> method allows you to change the underlying PRNG. These methods are 
  <b>much slower</b> than the corresponding &quot;non-secure&quot; versions, so they should only be used when cryptographic security is required. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ISAACRandom"" api=""ISAACRandom"" kind=""class"">
     ISAACRandom 
   </clt></tt> class implements a fast cryptographically secure pseudorandom numbers generator. 
 </dd> 
 <dt>
   Seeding pseudo-random number generators 
 </dt> 
 <dd>
   By default, the implementation provided in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> uses the JDK-provided PRNG. Like most other PRNGs, the JDK generator generates sequences of random numbers based on an initial &quot;seed value&quot;. For the non-secure methods, starting with the same seed always produces the same sequence of values. Secure sequences started with the same seeds will diverge. When a new 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> is created, the underlying random number generators are 
  <b>not</b> initialized. The first call to a data generation method, or to a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.reSeed"" api=""reSeed"" kind=""method"">
     reSeed() 
   </clt></tt> method initializes the appropriate generator. If you do not explicitly seed the generator, it is by default seeded with the current time in milliseconds. Therefore, to generate sequences of random data values, you should always instantiate 
  <b>one</b> 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> and use it repeatedly instead of creating new instances for subsequent values in the sequence. For example, the following will generate a random sequence of 50 long integers between 1 and 1,000,000, using the current time in milliseconds as the seed for the JDK PRNG: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will not in general produce a good random sequence, since the PRNG is reseeded each time through the loop with the current time in milliseconds: 
  <div class=""source""> 
   <pre>
for (int i = 0; i &lt; 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce the same random sequence each time it is executed: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce a different random sequence each time it is executed. 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}
    </pre> 
  </div> 
 </dd> 
</dl>",RandomData,class
,2.2 Random numbers,"<h3>2.2 Random numbers</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/random/RandomData.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></a> interface defines methods for generating random sequences of numbers. The API contracts of these methods use the following concepts: </p> 
<dl> 
 <dt>
   Random sequence of numbers from a probability distribution 
 </dt> 
 <dd>
   There is no such thing as a single &quot;random number.&quot; What can be generated are 
  <i>sequences</i> of numbers that appear to be random. When using the built-in JDK function 
  <tt>Math.random(),</tt> sequences of values generated follow the 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm""> Uniform Distribution</a>, which means that the values are evenly spread over the interval between 0 and 1, with no sub-interval having a greater probability of containing generated values than any other interval of the same length. The mathematical concept of a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda36.htm""> probability distribution</a> basically amounts to asserting that different ranges in the set of possible values of a random variable have different probabilities of containing the value. Commons Math supports generating random sequences from each of the distributions in the 
  <a href=""../apidocs/org/apache/commons/math3/distribution/package-summary.html""> distributions</a> package. The javadoc for the 
  <tt>nextXxx</tt> methods in 
  <a href=""../apidocs/org/apache/commons/math3/random/RandomDataImpl.html""> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></a> describes the algorithms used to generate random deviates. 
 </dd> 
 <dt>
   Cryptographically secure random sequences 
 </dt> 
 <dd>
   It is possible for a sequence of numbers to appear random, but nonetheless to be predictable based on the algorithm used to generate the sequence. If in addition to randomness, strong unpredictability is required, it is best to use a 
  <a class=""externalLink"" href=""http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator""> secure random number generator</a> to generate values (or strings). The nextSecureXxx methods in the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> implementation of the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> interface use the JDK 
  <tt>SecureRandom</tt> PRNG to generate cryptographically secure sequences. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.setSecureAlgorithm"" api=""setSecureAlgorithm"" kind=""class"">
     setSecureAlgorithm 
   </clt></tt> method allows you to change the underlying PRNG. These methods are 
  <b>much slower</b> than the corresponding &quot;non-secure&quot; versions, so they should only be used when cryptographic security is required. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ISAACRandom"" api=""ISAACRandom"" kind=""class"">
     ISAACRandom 
   </clt></tt> class implements a fast cryptographically secure pseudorandom numbers generator. 
 </dd> 
 <dt>
   Seeding pseudo-random number generators 
 </dt> 
 <dd>
   By default, the implementation provided in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> uses the JDK-provided PRNG. Like most other PRNGs, the JDK generator generates sequences of random numbers based on an initial &quot;seed value&quot;. For the non-secure methods, starting with the same seed always produces the same sequence of values. Secure sequences started with the same seeds will diverge. When a new 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> is created, the underlying random number generators are 
  <b>not</b> initialized. The first call to a data generation method, or to a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.reSeed"" api=""reSeed"" kind=""method"">
     reSeed() 
   </clt></tt> method initializes the appropriate generator. If you do not explicitly seed the generator, it is by default seeded with the current time in milliseconds. Therefore, to generate sequences of random data values, you should always instantiate 
  <b>one</b> 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> and use it repeatedly instead of creating new instances for subsequent values in the sequence. For example, the following will generate a random sequence of 50 long integers between 1 and 1,000,000, using the current time in milliseconds as the seed for the JDK PRNG: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will not in general produce a good random sequence, since the PRNG is reseeded each time through the loop with the current time in milliseconds: 
  <div class=""source""> 
   <pre>
for (int i = 0; i &lt; 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce the same random sequence each time it is executed: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce a different random sequence each time it is executed. 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}
    </pre> 
  </div> 
 </dd> 
</dl>",RandomDataImpl,class
,2.2 Random numbers,"<h3>2.2 Random numbers</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/random/RandomData.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></a> interface defines methods for generating random sequences of numbers. The API contracts of these methods use the following concepts: </p> 
<dl> 
 <dt>
   Random sequence of numbers from a probability distribution 
 </dt> 
 <dd>
   There is no such thing as a single &quot;random number.&quot; What can be generated are 
  <i>sequences</i> of numbers that appear to be random. When using the built-in JDK function 
  <tt>Math.random(),</tt> sequences of values generated follow the 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm""> Uniform Distribution</a>, which means that the values are evenly spread over the interval between 0 and 1, with no sub-interval having a greater probability of containing generated values than any other interval of the same length. The mathematical concept of a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda36.htm""> probability distribution</a> basically amounts to asserting that different ranges in the set of possible values of a random variable have different probabilities of containing the value. Commons Math supports generating random sequences from each of the distributions in the 
  <a href=""../apidocs/org/apache/commons/math3/distribution/package-summary.html""> distributions</a> package. The javadoc for the 
  <tt>nextXxx</tt> methods in 
  <a href=""../apidocs/org/apache/commons/math3/random/RandomDataImpl.html""> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></a> describes the algorithms used to generate random deviates. 
 </dd> 
 <dt>
   Cryptographically secure random sequences 
 </dt> 
 <dd>
   It is possible for a sequence of numbers to appear random, but nonetheless to be predictable based on the algorithm used to generate the sequence. If in addition to randomness, strong unpredictability is required, it is best to use a 
  <a class=""externalLink"" href=""http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator""> secure random number generator</a> to generate values (or strings). The nextSecureXxx methods in the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> implementation of the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> interface use the JDK 
  <tt>SecureRandom</tt> PRNG to generate cryptographically secure sequences. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.setSecureAlgorithm"" api=""setSecureAlgorithm"" kind=""class"">
     setSecureAlgorithm 
   </clt></tt> method allows you to change the underlying PRNG. These methods are 
  <b>much slower</b> than the corresponding &quot;non-secure&quot; versions, so they should only be used when cryptographic security is required. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ISAACRandom"" api=""ISAACRandom"" kind=""class"">
     ISAACRandom 
   </clt></tt> class implements a fast cryptographically secure pseudorandom numbers generator. 
 </dd> 
 <dt>
   Seeding pseudo-random number generators 
 </dt> 
 <dd>
   By default, the implementation provided in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> uses the JDK-provided PRNG. Like most other PRNGs, the JDK generator generates sequences of random numbers based on an initial &quot;seed value&quot;. For the non-secure methods, starting with the same seed always produces the same sequence of values. Secure sequences started with the same seeds will diverge. When a new 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> is created, the underlying random number generators are 
  <b>not</b> initialized. The first call to a data generation method, or to a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.reSeed"" api=""reSeed"" kind=""method"">
     reSeed() 
   </clt></tt> method initializes the appropriate generator. If you do not explicitly seed the generator, it is by default seeded with the current time in milliseconds. Therefore, to generate sequences of random data values, you should always instantiate 
  <b>one</b> 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> and use it repeatedly instead of creating new instances for subsequent values in the sequence. For example, the following will generate a random sequence of 50 long integers between 1 and 1,000,000, using the current time in milliseconds as the seed for the JDK PRNG: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will not in general produce a good random sequence, since the PRNG is reseeded each time through the loop with the current time in milliseconds: 
  <div class=""source""> 
   <pre>
for (int i = 0; i &lt; 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce the same random sequence each time it is executed: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce a different random sequence each time it is executed. 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}
    </pre> 
  </div> 
 </dd> 
</dl>",setSecureAlgorithm,class
,2.2 Random numbers,"<h3>2.2 Random numbers</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/random/RandomData.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></a> interface defines methods for generating random sequences of numbers. The API contracts of these methods use the following concepts: </p> 
<dl> 
 <dt>
   Random sequence of numbers from a probability distribution 
 </dt> 
 <dd>
   There is no such thing as a single &quot;random number.&quot; What can be generated are 
  <i>sequences</i> of numbers that appear to be random. When using the built-in JDK function 
  <tt>Math.random(),</tt> sequences of values generated follow the 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm""> Uniform Distribution</a>, which means that the values are evenly spread over the interval between 0 and 1, with no sub-interval having a greater probability of containing generated values than any other interval of the same length. The mathematical concept of a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda36.htm""> probability distribution</a> basically amounts to asserting that different ranges in the set of possible values of a random variable have different probabilities of containing the value. Commons Math supports generating random sequences from each of the distributions in the 
  <a href=""../apidocs/org/apache/commons/math3/distribution/package-summary.html""> distributions</a> package. The javadoc for the 
  <tt>nextXxx</tt> methods in 
  <a href=""../apidocs/org/apache/commons/math3/random/RandomDataImpl.html""> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></a> describes the algorithms used to generate random deviates. 
 </dd> 
 <dt>
   Cryptographically secure random sequences 
 </dt> 
 <dd>
   It is possible for a sequence of numbers to appear random, but nonetheless to be predictable based on the algorithm used to generate the sequence. If in addition to randomness, strong unpredictability is required, it is best to use a 
  <a class=""externalLink"" href=""http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator""> secure random number generator</a> to generate values (or strings). The nextSecureXxx methods in the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> implementation of the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> interface use the JDK 
  <tt>SecureRandom</tt> PRNG to generate cryptographically secure sequences. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.setSecureAlgorithm"" api=""setSecureAlgorithm"" kind=""class"">
     setSecureAlgorithm 
   </clt></tt> method allows you to change the underlying PRNG. These methods are 
  <b>much slower</b> than the corresponding &quot;non-secure&quot; versions, so they should only be used when cryptographic security is required. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ISAACRandom"" api=""ISAACRandom"" kind=""class"">
     ISAACRandom 
   </clt></tt> class implements a fast cryptographically secure pseudorandom numbers generator. 
 </dd> 
 <dt>
   Seeding pseudo-random number generators 
 </dt> 
 <dd>
   By default, the implementation provided in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> uses the JDK-provided PRNG. Like most other PRNGs, the JDK generator generates sequences of random numbers based on an initial &quot;seed value&quot;. For the non-secure methods, starting with the same seed always produces the same sequence of values. Secure sequences started with the same seeds will diverge. When a new 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> is created, the underlying random number generators are 
  <b>not</b> initialized. The first call to a data generation method, or to a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.reSeed"" api=""reSeed"" kind=""method"">
     reSeed() 
   </clt></tt> method initializes the appropriate generator. If you do not explicitly seed the generator, it is by default seeded with the current time in milliseconds. Therefore, to generate sequences of random data values, you should always instantiate 
  <b>one</b> 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> and use it repeatedly instead of creating new instances for subsequent values in the sequence. For example, the following will generate a random sequence of 50 long integers between 1 and 1,000,000, using the current time in milliseconds as the seed for the JDK PRNG: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will not in general produce a good random sequence, since the PRNG is reseeded each time through the loop with the current time in milliseconds: 
  <div class=""source""> 
   <pre>
for (int i = 0; i &lt; 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce the same random sequence each time it is executed: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce a different random sequence each time it is executed. 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}
    </pre> 
  </div> 
 </dd> 
</dl>",ISAACRandom,class
,2.2 Random numbers,"<h3>2.2 Random numbers</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/random/RandomData.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></a> interface defines methods for generating random sequences of numbers. The API contracts of these methods use the following concepts: </p> 
<dl> 
 <dt>
   Random sequence of numbers from a probability distribution 
 </dt> 
 <dd>
   There is no such thing as a single &quot;random number.&quot; What can be generated are 
  <i>sequences</i> of numbers that appear to be random. When using the built-in JDK function 
  <tt>Math.random(),</tt> sequences of values generated follow the 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm""> Uniform Distribution</a>, which means that the values are evenly spread over the interval between 0 and 1, with no sub-interval having a greater probability of containing generated values than any other interval of the same length. The mathematical concept of a 
  <a class=""externalLink"" href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda36.htm""> probability distribution</a> basically amounts to asserting that different ranges in the set of possible values of a random variable have different probabilities of containing the value. Commons Math supports generating random sequences from each of the distributions in the 
  <a href=""../apidocs/org/apache/commons/math3/distribution/package-summary.html""> distributions</a> package. The javadoc for the 
  <tt>nextXxx</tt> methods in 
  <a href=""../apidocs/org/apache/commons/math3/random/RandomDataImpl.html""> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></a> describes the algorithms used to generate random deviates. 
 </dd> 
 <dt>
   Cryptographically secure random sequences 
 </dt> 
 <dd>
   It is possible for a sequence of numbers to appear random, but nonetheless to be predictable based on the algorithm used to generate the sequence. If in addition to randomness, strong unpredictability is required, it is best to use a 
  <a class=""externalLink"" href=""http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator""> secure random number generator</a> to generate values (or strings). The nextSecureXxx methods in the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> implementation of the 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> interface use the JDK 
  <tt>SecureRandom</tt> PRNG to generate cryptographically secure sequences. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.setSecureAlgorithm"" api=""setSecureAlgorithm"" kind=""class"">
     setSecureAlgorithm 
   </clt></tt> method allows you to change the underlying PRNG. These methods are 
  <b>much slower</b> than the corresponding &quot;non-secure&quot; versions, so they should only be used when cryptographic security is required. The 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ISAACRandom"" api=""ISAACRandom"" kind=""class"">
     ISAACRandom 
   </clt></tt> class implements a fast cryptographically secure pseudorandom numbers generator. 
 </dd> 
 <dt>
   Seeding pseudo-random number generators 
 </dt> 
 <dd>
   By default, the implementation provided in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> uses the JDK-provided PRNG. Like most other PRNGs, the JDK generator generates sequences of random numbers based on an initial &quot;seed value&quot;. For the non-secure methods, starting with the same seed always produces the same sequence of values. Secure sequences started with the same seeds will diverge. When a new 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> is created, the underlying random number generators are 
  <b>not</b> initialized. The first call to a data generation method, or to a 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.reSeed"" api=""reSeed"" kind=""method"">
     reSeed() 
   </clt></tt> method initializes the appropriate generator. If you do not explicitly seed the generator, it is by default seeded with the current time in milliseconds. Therefore, to generate sequences of random data values, you should always instantiate 
  <b>one</b> 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
     RandomDataImpl 
   </clt></tt> and use it repeatedly instead of creating new instances for subsequent values in the sequence. For example, the following will generate a random sequence of 50 long integers between 1 and 1,000,000, using the current time in milliseconds as the seed for the JDK PRNG: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will not in general produce a good random sequence, since the PRNG is reseeded each time through the loop with the current time in milliseconds: 
  <div class=""source""> 
   <pre>
for (int i = 0; i &lt; 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce the same random sequence each time it is executed: 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    </pre> 
  </div> The following will produce a different random sequence each time it is executed. 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i &lt; 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}
    </pre> 
  </div> 
 </dd> 
</dl>",reSeed,method
,2.3 Random Vectors,"<clt fqn=""org.apache.commons.math3.random.NormalizedRandomGenerator"" api=""NormalizedRandomGenerator"" kind=""class"">
  2.3 Random Vectors Some algorithms require random vectors instead of random scalars. When the components of these vectors are uncorrelated, they may be generated simply one at a time and packed together in the vector. The UncorrelatedRandomVectorGenerator class simplifies this process by setting the mean and deviation of each component once and generating complete vectors. When the components are correlated however, generating them is much more difficult. The CorrelatedRandomVectorGenerator class provides this service. In this case, the user must set up a complete covariance matrix instead of a simple standard deviations vector. This matrix gathers both the variance and the correlation information of the probability law. The main use for correlated random vector generation is for Monte-Carlo simulation of physical problems with several variables, for example to generate error vectors to be added to a nominal vector. A particularly common case is when the generated vector should be drawn from a Multivariate Normal Distribution. Generating random vectors from a bivariate normal distribution // Create and seed a RandomGenerator (could use any of the generators in the random package here) RandomGenerator rg = new JDKRandomGenerator(); rg.setSeed(17399225432l); // Fixed seed means same results every time // Create a GassianRandomGenerator using rg as its source of randomness GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg); // Create a CorrelatedRandomVectorGenerator using rawGenerator for the components CorrelatedRandomVectorGenerator generator = new CorrelatedRandomVectorGenerator(mean, covariance, 1.0e-12 * covariance.getNorm(), rawGenerator); // Use the generator to generate correlated vectors double[] randomVector = generator.nextVector(); ... The mean argument is a double[] array holding the means of the random vector components. In the bivariate case, it must have length 2. The covariance argument is a RealMatrix, which needs to be 2 x 2. The main diagonal elements are the variances of the vector components and the off-diagonal elements are the covariances. For example, if the means are 1 and 2 respectively, and the desired standard deviations are 3 and 4, respectively, then we need to use double[] mean = {1, 2}; double[][] cov = {{9, c}, {c, 16}}; RealMatrix covariance = MatrixUtils.createRealMatrix(cov); where c is the desired covariance. If you are starting with a desired correlation, you need to translate this to a covariance by multiplying it by the product of the standard deviations. For example, if you want to generate data that will give Pearson's R of 0.5, you would use c = 3 * 4 * .5 = 6. In addition to multivariate normal distributions, correlated vectors from multivariate uniform distributions can be generated by creating a UniformRandomGenerator in place of the GaussianRandomGenerator above. More generally, any NormalizedRandomGenerator may be used. 
</clt>",NormalizedRandomGenerator,class
,2.4 Random Strings,"<h3>2.4 Random Strings</h3> 
<p> The methods <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextHexString"" api=""nextHexString"" kind=""class"">
    nextHexString 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
    nextSecureHexString 
  </clt></tt> can be used to generate random strings of hexadecimal characters. Both of these methods produce sequences of strings with good dispersion properties. The difference between the two methods is that the second is cryptographically secure. Specifically, the implementation of <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextHexString"" api=""nextHexString"" kind=""method"">
    nextHexString(n) 
  </clt></tt> in <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
    RandomDataImpl 
  </clt></tt> uses the following simple algorithm to generate a string of <tt>n</tt> hex digits: </p> 
<ol style=""list-style-type: decimal""> 
 <li>n/2+1 binary bytes are generated using the underlying Random</li> 
 <li>Each binary byte is translated into 2 hex digits</li> 
</ol> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
   RandomDataImpl 
 </clt></tt> implementation of the &quot;secure&quot; version, 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
   nextSecureHexString 
 </clt></tt> generates hex characters in 40-byte &quot;chunks&quot; using a 3-step process: 
<ol style=""list-style-type: decimal""> 
 <li>20 random bytes are generated using the underlying <tt>SecureRandom.</tt></li> 
 <li>SHA-1 hash is applied to yield a 20-byte binary digest.</li> 
 <li>Each byte of the binary digest is converted to 2 hex digits</li> 
</ol> Similarly to the secure random number generation methods, 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
   nextSecureHexString 
 </clt></tt> is 
<b>much slower</b> than the non-secure version. It should be used only for applications such as generating unique session or transaction ids where predictability of subsequent ids based on observation of previous values is a security concern. If all that is needed is an even distribution of hex characters in the generated strings, the non-secure method should be used.",nextHexString,class
,2.4 Random Strings,"<h3>2.4 Random Strings</h3> 
<p> The methods <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextHexString"" api=""nextHexString"" kind=""class"">
    nextHexString 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
    nextSecureHexString 
  </clt></tt> can be used to generate random strings of hexadecimal characters. Both of these methods produce sequences of strings with good dispersion properties. The difference between the two methods is that the second is cryptographically secure. Specifically, the implementation of <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextHexString"" api=""nextHexString"" kind=""method"">
    nextHexString(n) 
  </clt></tt> in <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
    RandomDataImpl 
  </clt></tt> uses the following simple algorithm to generate a string of <tt>n</tt> hex digits: </p> 
<ol style=""list-style-type: decimal""> 
 <li>n/2+1 binary bytes are generated using the underlying Random</li> 
 <li>Each binary byte is translated into 2 hex digits</li> 
</ol> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
   RandomDataImpl 
 </clt></tt> implementation of the &quot;secure&quot; version, 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
   nextSecureHexString 
 </clt></tt> generates hex characters in 40-byte &quot;chunks&quot; using a 3-step process: 
<ol style=""list-style-type: decimal""> 
 <li>20 random bytes are generated using the underlying <tt>SecureRandom.</tt></li> 
 <li>SHA-1 hash is applied to yield a 20-byte binary digest.</li> 
 <li>Each byte of the binary digest is converted to 2 hex digits</li> 
</ol> Similarly to the secure random number generation methods, 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
   nextSecureHexString 
 </clt></tt> is 
<b>much slower</b> than the non-secure version. It should be used only for applications such as generating unique session or transaction ids where predictability of subsequent ids based on observation of previous values is a security concern. If all that is needed is an even distribution of hex characters in the generated strings, the non-secure method should be used.",nextSecureHexString,class
,2.4 Random Strings,"<h3>2.4 Random Strings</h3> 
<p> The methods <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextHexString"" api=""nextHexString"" kind=""class"">
    nextHexString 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
    nextSecureHexString 
  </clt></tt> can be used to generate random strings of hexadecimal characters. Both of these methods produce sequences of strings with good dispersion properties. The difference between the two methods is that the second is cryptographically secure. Specifically, the implementation of <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextHexString"" api=""nextHexString"" kind=""method"">
    nextHexString(n) 
  </clt></tt> in <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
    RandomDataImpl 
  </clt></tt> uses the following simple algorithm to generate a string of <tt>n</tt> hex digits: </p> 
<ol style=""list-style-type: decimal""> 
 <li>n/2+1 binary bytes are generated using the underlying Random</li> 
 <li>Each binary byte is translated into 2 hex digits</li> 
</ol> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl"" api=""RandomDataImpl"" kind=""class"">
   RandomDataImpl 
 </clt></tt> implementation of the &quot;secure&quot; version, 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
   nextSecureHexString 
 </clt></tt> generates hex characters in 40-byte &quot;chunks&quot; using a 3-step process: 
<ol style=""list-style-type: decimal""> 
 <li>20 random bytes are generated using the underlying <tt>SecureRandom.</tt></li> 
 <li>SHA-1 hash is applied to yield a 20-byte binary digest.</li> 
 <li>Each byte of the binary digest is converted to 2 hex digits</li> 
</ol> Similarly to the secure random number generation methods, 
<tt> 
 <clt fqn=""org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"" api=""nextSecureHexString"" kind=""class"">
   nextSecureHexString 
 </clt></tt> is 
<b>much slower</b> than the non-secure version. It should be used only for applications such as generating unique session or transaction ids where predictability of subsequent ids based on observation of previous values is a security concern. If all that is needed is an even distribution of hex characters in the generated strings, the non-secure method should be used.",RandomDataImpl,class
,"2.5 Random permutations, combinations, sampling","<h3>2.5 Random permutations, combinations, sampling</h3> 
<p> To select a random sample of objects in a collection, you can use the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""class"">
    nextSample 
  </clt></tt> method in the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> interface. Specifically, if <tt>c</tt> is a collection containing at least <tt>k</tt> objects, and <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""method"">
    randomData.nextSample(c, k) 
  </clt></tt> will return an <tt>object[]</tt> array of length <tt>k</tt> consisting of elements randomly selected from the collection. If <tt>c</tt> contains duplicate references, there may be duplicate references in the returned array; otherwise returned elements will be unique -- i.e., the sampling is without replacement among the object references in the collection. </p> 
<p> If <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance, and <tt>n</tt> and <tt>k</tt> are integers with <tt> k &lt;= n</tt>, then <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns an <tt>int[]</tt> array of length <tt>k</tt> whose whose entries are selected randomly, without repetition, from the integers <tt>0</tt> through <tt>n-1</tt> (inclusive), i.e., <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns a random permutation of <tt>n</tt> taken <tt>k</tt> at a time. </p>",nextSample,class
,"2.5 Random permutations, combinations, sampling","<h3>2.5 Random permutations, combinations, sampling</h3> 
<p> To select a random sample of objects in a collection, you can use the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""class"">
    nextSample 
  </clt></tt> method in the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> interface. Specifically, if <tt>c</tt> is a collection containing at least <tt>k</tt> objects, and <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""method"">
    randomData.nextSample(c, k) 
  </clt></tt> will return an <tt>object[]</tt> array of length <tt>k</tt> consisting of elements randomly selected from the collection. If <tt>c</tt> contains duplicate references, there may be duplicate references in the returned array; otherwise returned elements will be unique -- i.e., the sampling is without replacement among the object references in the collection. </p> 
<p> If <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance, and <tt>n</tt> and <tt>k</tt> are integers with <tt> k &lt;= n</tt>, then <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns an <tt>int[]</tt> array of length <tt>k</tt> whose whose entries are selected randomly, without repetition, from the integers <tt>0</tt> through <tt>n-1</tt> (inclusive), i.e., <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns a random permutation of <tt>n</tt> taken <tt>k</tt> at a time. </p>",RandomData,class
,"2.5 Random permutations, combinations, sampling","<h3>2.5 Random permutations, combinations, sampling</h3> 
<p> To select a random sample of objects in a collection, you can use the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""class"">
    nextSample 
  </clt></tt> method in the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> interface. Specifically, if <tt>c</tt> is a collection containing at least <tt>k</tt> objects, and <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""method"">
    randomData.nextSample(c, k) 
  </clt></tt> will return an <tt>object[]</tt> array of length <tt>k</tt> consisting of elements randomly selected from the collection. If <tt>c</tt> contains duplicate references, there may be duplicate references in the returned array; otherwise returned elements will be unique -- i.e., the sampling is without replacement among the object references in the collection. </p> 
<p> If <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance, and <tt>n</tt> and <tt>k</tt> are integers with <tt> k &lt;= n</tt>, then <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns an <tt>int[]</tt> array of length <tt>k</tt> whose whose entries are selected randomly, without repetition, from the integers <tt>0</tt> through <tt>n-1</tt> (inclusive), i.e., <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns a random permutation of <tt>n</tt> taken <tt>k</tt> at a time. </p>",randomData,class
,"2.5 Random permutations, combinations, sampling","<h3>2.5 Random permutations, combinations, sampling</h3> 
<p> To select a random sample of objects in a collection, you can use the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""class"">
    nextSample 
  </clt></tt> method in the <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> interface. Specifically, if <tt>c</tt> is a collection containing at least <tt>k</tt> objects, and <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextSample"" api=""nextSample"" kind=""method"">
    randomData.nextSample(c, k) 
  </clt></tt> will return an <tt>object[]</tt> array of length <tt>k</tt> consisting of elements randomly selected from the collection. If <tt>c</tt> contains duplicate references, there may be duplicate references in the returned array; otherwise returned elements will be unique -- i.e., the sampling is without replacement among the object references in the collection. </p> 
<p> If <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"" api=""randomData"" kind=""class"">
    randomData 
  </clt></tt> is a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
    RandomData 
  </clt></tt> instance, and <tt>n</tt> and <tt>k</tt> are integers with <tt> k &lt;= n</tt>, then <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns an <tt>int[]</tt> array of length <tt>k</tt> whose whose entries are selected randomly, without repetition, from the integers <tt>0</tt> through <tt>n-1</tt> (inclusive), i.e., <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomData.nextPermutation"" api=""nextPermutation"" kind=""method"">
    randomData.nextPermutation(n, k) 
  </clt></tt> returns a random permutation of <tt>n</tt> taken <tt>k</tt> at a time. </p>",nextPermutation,method
,2.6 Generating data 'like' an input file,"<h3>2.6 Generating data 'like' an input file</h3> 
<p> Using the <tt> 
  <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
    ValueServer 
  </clt></tt> class, you can generate data based on the values in an input file in one of two ways: </p> 
<dl> 
 <dt>
   Replay Mode 
 </dt> 
 <dd>
   The following code will read data from 
  <tt>url</tt> (a 
  <tt>java.net.URL</tt> instance), cycling through the values in the file in sequence, reopening and starting at the beginning again when all values have been read. 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.REPLAY_MODE);
      vs.resetReplayFile();
      double value = vs.getNext();
      // ...Generate and use more values...
      vs.closeReplayFile();
      </pre> 
  </div> The values in the file are not stored in memory, so it does not matter how large the file is, but you do need to explicitly close the file as above. The expected file format is \n -delimited (i.e. one per line) strings representing valid floating point numbers. 
 </dd> 
 <dt>
   Digest Mode 
 </dt> 
 <dd>
   When used in Digest Mode, the ValueServer reads the entire input file and estimates a probability density function based on data from the file. The estimation method is essentially the 
  <a class=""externalLink"" href=""http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html""> Variable Kernel Method</a> with Gaussian smoothing. Once the density has been estimated, 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.getNext"" api=""getNext"" kind=""method"">
     getNext() 
   </clt></tt> returns random values whose probability distribution matches the empirical distribution -- i.e., if you generate a large number of such values, their distribution should &quot;look like&quot; the distribution of the values in the input file. The values are not stored in memory in this case either, so there is no limit to the size of the input file. Here is an example: 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      </pre> 
  </div> See the javadoc for 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
     ValueServer 
   </clt></tt> and 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.EmpiricalDistribution"" api=""EmpiricalDistribution"" kind=""class"">
     EmpiricalDistribution 
   </clt></tt> for more details. Note that 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.computeDistribution"" api=""computeDistribution"" kind=""method"">
     computeDistribution() 
   </clt></tt> opens and closes the input file by itself. 
 </dd> 
</dl>",ValueServer,class
,2.6 Generating data 'like' an input file,"<h3>2.6 Generating data 'like' an input file</h3> 
<p> Using the <tt> 
  <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
    ValueServer 
  </clt></tt> class, you can generate data based on the values in an input file in one of two ways: </p> 
<dl> 
 <dt>
   Replay Mode 
 </dt> 
 <dd>
   The following code will read data from 
  <tt>url</tt> (a 
  <tt>java.net.URL</tt> instance), cycling through the values in the file in sequence, reopening and starting at the beginning again when all values have been read. 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.REPLAY_MODE);
      vs.resetReplayFile();
      double value = vs.getNext();
      // ...Generate and use more values...
      vs.closeReplayFile();
      </pre> 
  </div> The values in the file are not stored in memory, so it does not matter how large the file is, but you do need to explicitly close the file as above. The expected file format is \n -delimited (i.e. one per line) strings representing valid floating point numbers. 
 </dd> 
 <dt>
   Digest Mode 
 </dt> 
 <dd>
   When used in Digest Mode, the ValueServer reads the entire input file and estimates a probability density function based on data from the file. The estimation method is essentially the 
  <a class=""externalLink"" href=""http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html""> Variable Kernel Method</a> with Gaussian smoothing. Once the density has been estimated, 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.getNext"" api=""getNext"" kind=""method"">
     getNext() 
   </clt></tt> returns random values whose probability distribution matches the empirical distribution -- i.e., if you generate a large number of such values, their distribution should &quot;look like&quot; the distribution of the values in the input file. The values are not stored in memory in this case either, so there is no limit to the size of the input file. Here is an example: 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      </pre> 
  </div> See the javadoc for 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
     ValueServer 
   </clt></tt> and 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.EmpiricalDistribution"" api=""EmpiricalDistribution"" kind=""class"">
     EmpiricalDistribution 
   </clt></tt> for more details. Note that 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.computeDistribution"" api=""computeDistribution"" kind=""method"">
     computeDistribution() 
   </clt></tt> opens and closes the input file by itself. 
 </dd> 
</dl>",getNext,method
,2.6 Generating data 'like' an input file,"<h3>2.6 Generating data 'like' an input file</h3> 
<p> Using the <tt> 
  <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
    ValueServer 
  </clt></tt> class, you can generate data based on the values in an input file in one of two ways: </p> 
<dl> 
 <dt>
   Replay Mode 
 </dt> 
 <dd>
   The following code will read data from 
  <tt>url</tt> (a 
  <tt>java.net.URL</tt> instance), cycling through the values in the file in sequence, reopening and starting at the beginning again when all values have been read. 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.REPLAY_MODE);
      vs.resetReplayFile();
      double value = vs.getNext();
      // ...Generate and use more values...
      vs.closeReplayFile();
      </pre> 
  </div> The values in the file are not stored in memory, so it does not matter how large the file is, but you do need to explicitly close the file as above. The expected file format is \n -delimited (i.e. one per line) strings representing valid floating point numbers. 
 </dd> 
 <dt>
   Digest Mode 
 </dt> 
 <dd>
   When used in Digest Mode, the ValueServer reads the entire input file and estimates a probability density function based on data from the file. The estimation method is essentially the 
  <a class=""externalLink"" href=""http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html""> Variable Kernel Method</a> with Gaussian smoothing. Once the density has been estimated, 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.getNext"" api=""getNext"" kind=""method"">
     getNext() 
   </clt></tt> returns random values whose probability distribution matches the empirical distribution -- i.e., if you generate a large number of such values, their distribution should &quot;look like&quot; the distribution of the values in the input file. The values are not stored in memory in this case either, so there is no limit to the size of the input file. Here is an example: 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      </pre> 
  </div> See the javadoc for 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
     ValueServer 
   </clt></tt> and 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.EmpiricalDistribution"" api=""EmpiricalDistribution"" kind=""class"">
     EmpiricalDistribution 
   </clt></tt> for more details. Note that 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.computeDistribution"" api=""computeDistribution"" kind=""method"">
     computeDistribution() 
   </clt></tt> opens and closes the input file by itself. 
 </dd> 
</dl>",EmpiricalDistribution,class
,2.6 Generating data 'like' an input file,"<h3>2.6 Generating data 'like' an input file</h3> 
<p> Using the <tt> 
  <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
    ValueServer 
  </clt></tt> class, you can generate data based on the values in an input file in one of two ways: </p> 
<dl> 
 <dt>
   Replay Mode 
 </dt> 
 <dd>
   The following code will read data from 
  <tt>url</tt> (a 
  <tt>java.net.URL</tt> instance), cycling through the values in the file in sequence, reopening and starting at the beginning again when all values have been read. 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.REPLAY_MODE);
      vs.resetReplayFile();
      double value = vs.getNext();
      // ...Generate and use more values...
      vs.closeReplayFile();
      </pre> 
  </div> The values in the file are not stored in memory, so it does not matter how large the file is, but you do need to explicitly close the file as above. The expected file format is \n -delimited (i.e. one per line) strings representing valid floating point numbers. 
 </dd> 
 <dt>
   Digest Mode 
 </dt> 
 <dd>
   When used in Digest Mode, the ValueServer reads the entire input file and estimates a probability density function based on data from the file. The estimation method is essentially the 
  <a class=""externalLink"" href=""http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html""> Variable Kernel Method</a> with Gaussian smoothing. Once the density has been estimated, 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.getNext"" api=""getNext"" kind=""method"">
     getNext() 
   </clt></tt> returns random values whose probability distribution matches the empirical distribution -- i.e., if you generate a large number of such values, their distribution should &quot;look like&quot; the distribution of the values in the input file. The values are not stored in memory in this case either, so there is no limit to the size of the input file. Here is an example: 
  <div class=""source""> 
   <pre>
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      </pre> 
  </div> See the javadoc for 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer"" api=""ValueServer"" kind=""class"">
     ValueServer 
   </clt></tt> and 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.EmpiricalDistribution"" api=""EmpiricalDistribution"" kind=""class"">
     EmpiricalDistribution 
   </clt></tt> for more details. Note that 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.ValueServer.computeDistribution"" api=""computeDistribution"" kind=""method"">
     computeDistribution() 
   </clt></tt> opens and closes the input file by itself. 
 </dd> 
</dl>",computeDistribution,method
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",RandomGenerator,class
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",AbstractRandomGenerator,class
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",nextDouble,method
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",RandomAdaptor,class
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",JDKRandomGenerator,class
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",MersenneTwister,class
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",Well512a,unknown
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",Well1024a,unknown
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",Well19937a,unknown
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",Well19937c,unknown
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",Well44497a,unknown
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",Well44497b,unknown
,2.7 PRNG Pluggability,"<h3>2.7 PRNG Pluggability</h3> 
<p> To enable alternative PRNGs to be &quot;plugged in&quot; to the commons-math data generation utilities and to provide a generic means to replace <tt>java.util.Random</tt> in applications, a random generator adaptor framework has been added to commons-math. The <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface abstracts the public interface of <tt>java.util.Random</tt> and any implementation of this interface can be used as the source of random data for the commons-math data generation classes. An abstract base class, <a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
    AbstractRandomGenerator 
  </clt></a> is provided to make implementation easier. This class provides default implementations of &quot;derived&quot; data generation methods based on the primitive, <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator.nextDouble"" api=""nextDouble"" kind=""method"">
    nextDouble() 
  </clt></tt>. To support generic replacement of <tt>java.util.Random</tt>, the <a href=""../apidocs/org/apache/commons/math3/random/RandomAdaptor.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomAdaptor"" api=""RandomAdaptor"" kind=""class"">
    RandomAdaptor 
  </clt></a> class is provided, which extends <tt>java.util.Random</tt> and wraps and delegates calls to a <tt> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></tt> instance. </p> 
<p>Commons-math provides by itself several implementations of the <a href=""../apidocs/org/apache/commons/math3/random/RandomGenerator.html""> 
  <clt fqn=""org.apache.commons.math3.random.RandomGenerator"" api=""RandomGenerator"" kind=""class"">
    RandomGenerator 
  </clt></a> interface: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
     JDKRandomGenerator 
   </clt></a> that extends the JDK provided generator</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/AbstractRandomGenerator.html""> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></a> as a helper for users generators</li> 
 <li><a href=""../apidocs/org/apache/commons/math3/random/BitStreamGenerator.html""> BitStreamGenerator</a> which is an abstract class for several generators and which in turn is extended by: 
  <ul> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></li> 
   <li><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></li> 
  </ul> </li> 
</ul> 
<p> The JDK provided generator is a simple one that can be used only for very simple needs. The Mersenne Twister is a fast generator with very good properties well suited for Monte-Carlo simulation. It is equidistributed for generating vectors up to dimension 623 and has a huge period: 2<sup>19937</sup> - 1 (which is a Mersenne prime). This generator is described in a paper by Makoto Matsumoto and Takuji Nishimura in 1998: <a class=""externalLink"" href=""http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf"">Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator</a>, ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, pp 3--30. The WELL generators are a family of generators with period ranging from 2<sup>512</sup> - 1 to 2<sup>44497</sup> - 1 (this last one is also a Mersenne prime) with even better properties than Mersenne Twister. These generators are described in a paper by Fran&ccedil;ois Panneton, Pierre L'Ecuyer and Makoto Matsumoto <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng.pdf"">Improved Long-Period Generators Based on Linear Recurrences Modulo 2</a> ACM Transactions on Mathematical Software, 32, 1 (2006). The errata for the paper are in <a class=""externalLink"" href=""http://www.iro.umontreal.ca/~lecuyer/myftp/papers/wellrng-errata.txt"">wellrng-errata.txt</a>. </p> 
<p> For simple sampling, any of these generators is sufficient. For Monte-Carlo simulations the JDK generator does not have any of the good mathematical properties of the other generators, so it should be avoided. The Mersenne twister and WELL generators have equidistribution properties proven according to their bits pool size which is directly linked to their period (all of them have maximal period, i.e. a generator with size n pool has a period 2<sup>n</sup>-1). They also have equidistribution properties for 32 bits blocks up to s/32 dimension where s is their pool size. So WELL19937c for exemple is equidistributed up to dimension 623 (19937/32). This means a Monte-Carlo simulation generating a vector of n variables at each iteration has some guarantees on the properties of the vector as long as its dimension does not exceed the limit. However, since we use bits from two successive 32 bits generated integers to create one double, this limit is smaller when the variables are of type double. so for Monte-Carlo simulation where less the 16 doubles are generated at each round, WELL1024 may be sufficient. If a larger number of doubles are needed a generator with a larger pool would be useful. </p> 
<p> The WELL generators are more modern then MersenneTwister (the paper describing than has been published in 2006 instead of 1998) and fix some of its (few) drawbacks. If initialization array contains many zero bits, MersenneTwister may take a very long time (several hundreds of thousands of iterations to reach a steady state with a balanced number of zero and one in its bits pool). So the WELL generators are better to <i>escape zeroland</i> as explained by the WELL generators creators. The Well19937a and Well44497a generator are not maximally equidistributed (i.e. there are some dimensions or bits blocks size for which they are not equidistributed). The Well512a, Well1024a, Well19937c and Well44497b are maximally equidistributed for blocks size up to 32 bits (they should behave correctly also for double based on more than 32 bits blocks, but equidistribution is not proven at these blocks sizes). </p> 
<p> The MersenneTwister generator uses a 624 elements integer array, so it consumes less than 2.5 kilobytes. The WELL generators use 6 integer arrays with a size equal to the pool size, so for example the WELL44497b generator uses about 33 kilobytes. This may be important if a very large number of generator instances were used at the same time. </p> 
<p> All generators are quite fast. As an example, here are some comparisons, obtained on a 64 bits JVM on a linux computer with a 2008 processor (AMD phenom Quad 9550 at 2.2 GHz). The generation rate for MersenneTwister was between 25 and 27 millions doubles per second (remember we generate two 32 bits integers for each double). Generation rates for other PRNG, relative to MersenneTwister: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Example of performances</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>generation rate (relative to MersenneTwister)</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/MersenneTwister.html""> 
     <clt fqn=""org.apache.commons.math3.random.MersenneTwister"" api=""MersenneTwister"" kind=""class"">
       MersenneTwister 
     </clt></a></td> 
   <td>1</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/JDKRandomGenerator.html""> 
     <clt fqn=""org.apache.commons.math3.random.JDKRandomGenerator"" api=""JDKRandomGenerator"" kind=""class"">
       JDKRandomGenerator 
     </clt></a></td> 
   <td>between 0.96 and 1.16</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well512a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well512a"" api=""Well512a"" kind=""unknown"">
       Well512a 
     </clt></a></td> 
   <td>between 0.85 and 0.88</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well1024a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well1024a"" api=""Well1024a"" kind=""unknown"">
       Well1024a 
     </clt></a></td> 
   <td>between 0.63 and 0.73</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937a"" api=""Well19937a"" kind=""unknown"">
       Well19937a 
     </clt></a></td> 
   <td>between 0.70 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
       Well19937c 
     </clt></a></td> 
   <td>between 0.57 and 0.71</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497a.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497a"" api=""Well44497a"" kind=""unknown"">
       Well44497a 
     </clt></a></td> 
   <td>between 0.69 and 0.71</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
     <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
       Well44497b 
     </clt></a></td> 
   <td>between 0.65 and 0.71</td> 
  </tr> 
 </tbody> 
</table> 
<p> So for most simulation problems, the better generators like <a href=""../apidocs/org/apache/commons/math3/random/Well19937c.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well19937c"" api=""Well19937c"" kind=""unknown"">
    Well19937c 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/random/Well44497b.html""> 
  <clt fqn=""org.apache.commons.math3.random.Well44497b"" api=""Well44497b"" kind=""unknown"">
    Well44497b 
  </clt></a> are probably very good choices. </p> 
<p> Note that <i>none</i> of these generators are suitable for cryptography. They are devoted to simulation, and to generate very long series with strong properties on the series as a whole (equidistribution, no correlation ...). They do not attempt to create small series but with very strong properties of unpredictability as needed in cryptography. </p> 
<p> Examples: </p> 
<dl> 
 <dt>
   Create a RandomGenerator based on RngPack's Mersenne Twister 
 </dt> 
 <dd>
   To create a RandomGenerator using the RngPack Mersenne Twister PRNG as the source of randomness, extend 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.AbstractRandomGenerator"" api=""AbstractRandomGenerator"" kind=""class"">
     AbstractRandomGenerator 
   </clt></tt> overriding the derived methods that the RngPack implementation provides: 
  <div class=""source""> 
   <pre>
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}
      </pre> 
  </div> 
 </dd> 
 <dt>
   Use the Mersenne Twister RandomGenerator in place of 
  <tt>java.util.Random</tt> in 
  <tt> 
   <clt fqn=""org.apache.commons.math3.random.RandomData"" api=""RandomData"" kind=""class"">
     RandomData 
   </clt></tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
RandomData randomData = new RandomDataImpl(new RngPackGenerator());
      </pre> 
  </div> 
 </dd> 
 <dt>
   Create an adaptor instance based on the Mersenne Twister generator that can be used in place of a 
  <tt>Random</tt> 
 </dt> 
 <dd> 
  <div class=""source""> 
   <pre>
 RandomGenerator generator = new RngPackGenerator();
 Random random = RandomAdaptor.createAdaptor(generator);
 // random can now be used in place of a Random instance, data generation
 // calls will be delegated to the wrapped Mersenne Twister
      </pre> 
  </div> 
 </dd> 
</dl>",RandomData,class
,3.2 Real matrices,"<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>",RealMatrix,class
,3.2 Real matrices,"<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>",Array2DRowRealMatrix,class
,3.2 Real matrices,"<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>",BlockRealMatrix,class
,3.2 Real matrices,"<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>",SparseRealMatrix,class
,3.3 Real vectors,"<h3>3.3 Real vectors</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVector.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></a> interface represents a vector with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Vector addition, subtraction</li> 
 <li>Element by element multiplication, division</li> 
 <li>Scalar addition, subtraction, multiplication, division and power</li> 
 <li>Mapping of mathematical functions (cos, sin ...)</li> 
 <li>Dot product, outer product</li> 
 <li>Distance and norm according to norms L1, L2 and Linf</li> 
</ul> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVectorFormat.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVectorFormat"" api=""RealVectorFormat"" kind=""class"">
    RealVectorFormat 
  </clt></a> class handles input/output of vectors in a customizable textual format. </p>",RealVector,class
,3.3 Real vectors,"<h3>3.3 Real vectors</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVector.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></a> interface represents a vector with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Vector addition, subtraction</li> 
 <li>Element by element multiplication, division</li> 
 <li>Scalar addition, subtraction, multiplication, division and power</li> 
 <li>Mapping of mathematical functions (cos, sin ...)</li> 
 <li>Dot product, outer product</li> 
 <li>Distance and norm according to norms L1, L2 and Linf</li> 
</ul> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVectorFormat.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVectorFormat"" api=""RealVectorFormat"" kind=""class"">
    RealVectorFormat 
  </clt></a> class handles input/output of vectors in a customizable textual format. </p>",RealVectorFormat,class
,3.4 Solving linear systems,"<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve() 
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> Start by decomposing the coefficient matrix A (in this case using LU decomposition) and build a solver 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> Next create a 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> array to represent the constant vector B and use 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
   solve(RealVector) 
 </clt></tt> to solve the system 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> The 
<tt>solution</tt> vector will contain values for x ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(0) 
 </clt></tt>), y ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(1) 
 </clt></tt>), and z ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(2) 
 </clt></tt>) that solve the system. 
<p> Each type of decomposition has its specific semantics and constraints on the coefficient matrix as shown in the following table. For algorithms that solve AX=B in least squares sense the value returned for X is such that the residual AX-B has minimal norm. If an exact solution exist (i.e. if for some X the residual AX-B is exactly 0), then this exact solution is also the solution in least square sense. This implies that algorithms suited for least squares problems can also be used to solve exact problems, but the reverse is not true. </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Decomposition algorithms</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>coefficients matrix</td> 
   <td>problem type</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/LUDecomposition.html"">LU</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/CholeskyDecomposition.html"">Cholesky</a></td> 
   <td>symmetric positive definite</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/QRDecomposition.html"">QR</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/EigenDecomposition.html"">eigen decomposition</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/SingularValueDecomposition.html"">SVD</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
 </tbody> 
</table> 
<p> It is possible to use a simple array of double instead of a <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></tt>. In this case, the solution will be provided also as an array of double. </p> 
<p> It is possible to solve multiple systems with the same coefficient matrix in one method call. To do this, create a matrix whose column vectors correspond to the constant vectors for the systems to be solved and use <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve(RealMatrix), 
  </clt></tt> which returns a matrix with column vectors representing the solutions. </p>",solve,method
,3.4 Solving linear systems,"<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve() 
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> Start by decomposing the coefficient matrix A (in this case using LU decomposition) and build a solver 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> Next create a 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> array to represent the constant vector B and use 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
   solve(RealVector) 
 </clt></tt> to solve the system 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> The 
<tt>solution</tt> vector will contain values for x ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(0) 
 </clt></tt>), y ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(1) 
 </clt></tt>), and z ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(2) 
 </clt></tt>) that solve the system. 
<p> Each type of decomposition has its specific semantics and constraints on the coefficient matrix as shown in the following table. For algorithms that solve AX=B in least squares sense the value returned for X is such that the residual AX-B has minimal norm. If an exact solution exist (i.e. if for some X the residual AX-B is exactly 0), then this exact solution is also the solution in least square sense. This implies that algorithms suited for least squares problems can also be used to solve exact problems, but the reverse is not true. </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Decomposition algorithms</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>coefficients matrix</td> 
   <td>problem type</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/LUDecomposition.html"">LU</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/CholeskyDecomposition.html"">Cholesky</a></td> 
   <td>symmetric positive definite</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/QRDecomposition.html"">QR</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/EigenDecomposition.html"">eigen decomposition</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/SingularValueDecomposition.html"">SVD</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
 </tbody> 
</table> 
<p> It is possible to use a simple array of double instead of a <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></tt>. In this case, the solution will be provided also as an array of double. </p> 
<p> It is possible to solve multiple systems with the same coefficient matrix in one method call. To do this, create a matrix whose column vectors correspond to the constant vectors for the systems to be solved and use <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve(RealMatrix), 
  </clt></tt> which returns a matrix with column vectors representing the solutions. </p>",DecompositionSolver,class
,3.4 Solving linear systems,"<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve() 
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> Start by decomposing the coefficient matrix A (in this case using LU decomposition) and build a solver 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> Next create a 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> array to represent the constant vector B and use 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
   solve(RealVector) 
 </clt></tt> to solve the system 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> The 
<tt>solution</tt> vector will contain values for x ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(0) 
 </clt></tt>), y ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(1) 
 </clt></tt>), and z ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(2) 
 </clt></tt>) that solve the system. 
<p> Each type of decomposition has its specific semantics and constraints on the coefficient matrix as shown in the following table. For algorithms that solve AX=B in least squares sense the value returned for X is such that the residual AX-B has minimal norm. If an exact solution exist (i.e. if for some X the residual AX-B is exactly 0), then this exact solution is also the solution in least square sense. This implies that algorithms suited for least squares problems can also be used to solve exact problems, but the reverse is not true. </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Decomposition algorithms</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>coefficients matrix</td> 
   <td>problem type</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/LUDecomposition.html"">LU</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/CholeskyDecomposition.html"">Cholesky</a></td> 
   <td>symmetric positive definite</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/QRDecomposition.html"">QR</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/EigenDecomposition.html"">eigen decomposition</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/SingularValueDecomposition.html"">SVD</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
 </tbody> 
</table> 
<p> It is possible to use a simple array of double instead of a <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></tt>. In this case, the solution will be provided also as an array of double. </p> 
<p> It is possible to solve multiple systems with the same coefficient matrix in one method call. To do this, create a matrix whose column vectors correspond to the constant vectors for the systems to be solved and use <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve(RealMatrix), 
  </clt></tt> which returns a matrix with column vectors representing the solutions. </p>",RealMatrix,class
,3.4 Solving linear systems,"<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve() 
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> Start by decomposing the coefficient matrix A (in this case using LU decomposition) and build a solver 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> Next create a 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> array to represent the constant vector B and use 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
   solve(RealVector) 
 </clt></tt> to solve the system 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> The 
<tt>solution</tt> vector will contain values for x ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(0) 
 </clt></tt>), y ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(1) 
 </clt></tt>), and z ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(2) 
 </clt></tt>) that solve the system. 
<p> Each type of decomposition has its specific semantics and constraints on the coefficient matrix as shown in the following table. For algorithms that solve AX=B in least squares sense the value returned for X is such that the residual AX-B has minimal norm. If an exact solution exist (i.e. if for some X the residual AX-B is exactly 0), then this exact solution is also the solution in least square sense. This implies that algorithms suited for least squares problems can also be used to solve exact problems, but the reverse is not true. </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Decomposition algorithms</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>coefficients matrix</td> 
   <td>problem type</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/LUDecomposition.html"">LU</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/CholeskyDecomposition.html"">Cholesky</a></td> 
   <td>symmetric positive definite</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/QRDecomposition.html"">QR</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/EigenDecomposition.html"">eigen decomposition</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/SingularValueDecomposition.html"">SVD</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
 </tbody> 
</table> 
<p> It is possible to use a simple array of double instead of a <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></tt>. In this case, the solution will be provided also as an array of double. </p> 
<p> It is possible to solve multiple systems with the same coefficient matrix in one method call. To do this, create a matrix whose column vectors correspond to the constant vectors for the systems to be solved and use <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve(RealMatrix), 
  </clt></tt> which returns a matrix with column vectors representing the solutions. </p>",RealVector,class
,3.4 Solving linear systems,"<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve() 
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> Start by decomposing the coefficient matrix A (in this case using LU decomposition) and build a solver 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> Next create a 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> array to represent the constant vector B and use 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
   solve(RealVector) 
 </clt></tt> to solve the system 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> The 
<tt>solution</tt> vector will contain values for x ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(0) 
 </clt></tt>), y ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(1) 
 </clt></tt>), and z ( 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""getEntry"" kind=""method"">
   solution.getEntry(2) 
 </clt></tt>) that solve the system. 
<p> Each type of decomposition has its specific semantics and constraints on the coefficient matrix as shown in the following table. For algorithms that solve AX=B in least squares sense the value returned for X is such that the residual AX-B has minimal norm. If an exact solution exist (i.e. if for some X the residual AX-B is exactly 0), then this exact solution is also the solution in least square sense. This implies that algorithms suited for least squares problems can also be used to solve exact problems, but the reverse is not true. </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Decomposition algorithms</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>coefficients matrix</td> 
   <td>problem type</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/LUDecomposition.html"">LU</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/CholeskyDecomposition.html"">Cholesky</a></td> 
   <td>symmetric positive definite</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/QRDecomposition.html"">QR</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/EigenDecomposition.html"">eigen decomposition</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/SingularValueDecomposition.html"">SVD</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
 </tbody> 
</table> 
<p> It is possible to use a simple array of double instead of a <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></tt>. In this case, the solution will be provided also as an array of double. </p> 
<p> It is possible to solve multiple systems with the same coefficient matrix in one method call. To do this, create a matrix whose column vectors correspond to the constant vectors for the systems to be solved and use <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""solve"" kind=""method"">
    solve(RealMatrix), 
  </clt></tt> which returns a matrix with column vectors representing the solutions. </p>",getEntry,method
,"3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>",Complex,unknown
,"3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>",Fraction,unknown
,"3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>",BigFraction,class
,"3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>",BigReal,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",UnivariateSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",UnivariateDifferentiableSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",PolynomialSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",solve,unknown
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",ConvergenceException,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",BrentSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",BracketingNthOrderBrentSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",SecantSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",RegulaFalsiSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",IllinoisSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",PegasusSolver,class
,4.3 Root-finding,"<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table> 
<p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
<p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""solve"" kind=""unknown"">
    solve 
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul> 
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>",BisectionSolver,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",UnivariateInterpolator,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",UnivariateFunction,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",HermiteInterpolator,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",BivariateGridInterpolator,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",BivariateFunction,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",BicubicSplineInterpolator,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",SmoothingPolynomialBicubicSplineInterpolator,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",TrivariateGridInterpolator,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",TrivariateFunction,class
,4.4 Interpolation,"<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
<p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Runge's_phenomenon"">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
<p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class=""externalLink"" href=""http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf"">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>",TricubicSplineInterpolator,class
,4.5 Integration,"<h3>4.5 Integration</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/integration/UnivariateIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.integration.UnivariateIntegrator"" api=""UnivariateIntegrator"" kind=""class"">
    UnivariateIntegrator 
  </clt></a> provides the means to numerically integrate <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real-valued functions</a>. Commons-Math includes implementations of the following integration algorithms: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/RombergIntegrator.html""> Romberg's method</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/SimpsonIntegrator.html""> Simpson's method</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.html""> trapezoid method</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.html""> Legendre-Gauss method</a></li> 
</ul>",UnivariateIntegrator,class
,4.6 Polynomials,"<h3>4.6 Polynomials</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/package-summary.html""> org.apache.commons.math3.analysis.polynomials</a> package provides real coefficients polynomials. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialFunction"" api=""PolynomialFunction"" kind=""class"">
    PolynomialFunction 
  </clt></a> class is the most general one, using traditional coefficients arrays. The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialsUtils.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialsUtils"" api=""PolynomialsUtils"" kind=""class"">
    PolynomialsUtils 
  </clt></a> utility class provides static factory methods to build Chebyshev, Hermite, Jacobi, Laguerre and Legendre polynomials. Coefficients are computed using exact fractions so these factory methods can build polynomials up to any degree. </p>",PolynomialFunction,class
,4.6 Polynomials,"<h3>4.6 Polynomials</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/package-summary.html""> org.apache.commons.math3.analysis.polynomials</a> package provides real coefficients polynomials. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialFunction"" api=""PolynomialFunction"" kind=""class"">
    PolynomialFunction 
  </clt></a> class is the most general one, using traditional coefficients arrays. The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialsUtils.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialsUtils"" api=""PolynomialsUtils"" kind=""class"">
    PolynomialsUtils 
  </clt></a> utility class provides static factory methods to build Chebyshev, Hermite, Jacobi, Laguerre and Legendre polynomials. Coefficients are computed using exact fractions so these factory methods can build polynomials up to any degree. </p>",PolynomialsUtils,class
,4.7 Differentiation,"<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p> 
<p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
<div class=""source""> 
 <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
</div> 
<p> In fact, there are no notions of <i>variables</i> in the framework, so neither <tt>x</tt> nor <tt>y</tt> are considered to be variables per se. They are both considered to be <i>functions</i> and to depend on implicit free parameters which are represented only by indices in the framework. The <tt>x</tt> instance above is there considered by the framework to be a function of free parameter <tt>p0</tt> at index 0, and as <tt>y</tt> is computed from <tt>x</tt> it is the result of a functions composition and is therefore also a function of this <tt>p0</tt> free parameter. The <tt>p0</tt> is not represented by itself, it is simply defined implicitely by the 0 index above. This index is the third argument in the constructor of the <tt>x</tt> instance. What this constructor means is that we built <tt>x</tt> as a function that depends on one free parameter only (first constructor argument set to 1), that can be differentiated up to order 3 (second constructor argument set to 3), and which correspond to an identity function with respect to implicit free parameter number 0 (third constructor argument set to 0), with current value equal to 2.5 (fourth constructor argument set to 2.5). This specific constructor defines identity functions, and identity functions are the trick we use to represent variables (there are of course other constructors, for example to build constants or functions from all their derivatives if they are known beforehand). From the user point of view, the <tt>x</tt> instance can be seen as the <tt>x</tt> variable, but it is really the identity function applied to free parameter number 0. As the identity function, it has the same value as its parameter, its first derivative is 1.0 with respect to this free parameter, and all its higher order derivatives are 0.0. This can be checked by calling the getValue() or getPartialDerivative() methods on <tt>x</tt>. </p> 
<p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""method"">
    z.getPartialDerivative(1) 
  </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
<p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p> 
<p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""class"">
    getPartialDerivative 
  </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p> 
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p> 
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>",DerivativeStructure,class
,4.7 Differentiation,"<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p> 
<p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
<div class=""source""> 
 <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
</div> 
<p> In fact, there are no notions of <i>variables</i> in the framework, so neither <tt>x</tt> nor <tt>y</tt> are considered to be variables per se. They are both considered to be <i>functions</i> and to depend on implicit free parameters which are represented only by indices in the framework. The <tt>x</tt> instance above is there considered by the framework to be a function of free parameter <tt>p0</tt> at index 0, and as <tt>y</tt> is computed from <tt>x</tt> it is the result of a functions composition and is therefore also a function of this <tt>p0</tt> free parameter. The <tt>p0</tt> is not represented by itself, it is simply defined implicitely by the 0 index above. This index is the third argument in the constructor of the <tt>x</tt> instance. What this constructor means is that we built <tt>x</tt> as a function that depends on one free parameter only (first constructor argument set to 1), that can be differentiated up to order 3 (second constructor argument set to 3), and which correspond to an identity function with respect to implicit free parameter number 0 (third constructor argument set to 0), with current value equal to 2.5 (fourth constructor argument set to 2.5). This specific constructor defines identity functions, and identity functions are the trick we use to represent variables (there are of course other constructors, for example to build constants or functions from all their derivatives if they are known beforehand). From the user point of view, the <tt>x</tt> instance can be seen as the <tt>x</tt> variable, but it is really the identity function applied to free parameter number 0. As the identity function, it has the same value as its parameter, its first derivative is 1.0 with respect to this free parameter, and all its higher order derivatives are 0.0. This can be checked by calling the getValue() or getPartialDerivative() methods on <tt>x</tt>. </p> 
<p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""method"">
    z.getPartialDerivative(1) 
  </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
<p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p> 
<p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""class"">
    getPartialDerivative 
  </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p> 
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p> 
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>",UnivariateDifferentiableFunction,class
,4.7 Differentiation,"<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p> 
<p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
<div class=""source""> 
 <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
</div> 
<p> In fact, there are no notions of <i>variables</i> in the framework, so neither <tt>x</tt> nor <tt>y</tt> are considered to be variables per se. They are both considered to be <i>functions</i> and to depend on implicit free parameters which are represented only by indices in the framework. The <tt>x</tt> instance above is there considered by the framework to be a function of free parameter <tt>p0</tt> at index 0, and as <tt>y</tt> is computed from <tt>x</tt> it is the result of a functions composition and is therefore also a function of this <tt>p0</tt> free parameter. The <tt>p0</tt> is not represented by itself, it is simply defined implicitely by the 0 index above. This index is the third argument in the constructor of the <tt>x</tt> instance. What this constructor means is that we built <tt>x</tt> as a function that depends on one free parameter only (first constructor argument set to 1), that can be differentiated up to order 3 (second constructor argument set to 3), and which correspond to an identity function with respect to implicit free parameter number 0 (third constructor argument set to 0), with current value equal to 2.5 (fourth constructor argument set to 2.5). This specific constructor defines identity functions, and identity functions are the trick we use to represent variables (there are of course other constructors, for example to build constants or functions from all their derivatives if they are known beforehand). From the user point of view, the <tt>x</tt> instance can be seen as the <tt>x</tt> variable, but it is really the identity function applied to free parameter number 0. As the identity function, it has the same value as its parameter, its first derivative is 1.0 with respect to this free parameter, and all its higher order derivatives are 0.0. This can be checked by calling the getValue() or getPartialDerivative() methods on <tt>x</tt>. </p> 
<p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""method"">
    z.getPartialDerivative(1) 
  </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
<p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p> 
<p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""class"">
    getPartialDerivative 
  </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p> 
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p> 
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>",getPartialDerivative,method
,4.7 Differentiation,"<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p> 
<p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
<div class=""source""> 
 <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
</div> 
<p> In fact, there are no notions of <i>variables</i> in the framework, so neither <tt>x</tt> nor <tt>y</tt> are considered to be variables per se. They are both considered to be <i>functions</i> and to depend on implicit free parameters which are represented only by indices in the framework. The <tt>x</tt> instance above is there considered by the framework to be a function of free parameter <tt>p0</tt> at index 0, and as <tt>y</tt> is computed from <tt>x</tt> it is the result of a functions composition and is therefore also a function of this <tt>p0</tt> free parameter. The <tt>p0</tt> is not represented by itself, it is simply defined implicitely by the 0 index above. This index is the third argument in the constructor of the <tt>x</tt> instance. What this constructor means is that we built <tt>x</tt> as a function that depends on one free parameter only (first constructor argument set to 1), that can be differentiated up to order 3 (second constructor argument set to 3), and which correspond to an identity function with respect to implicit free parameter number 0 (third constructor argument set to 0), with current value equal to 2.5 (fourth constructor argument set to 2.5). This specific constructor defines identity functions, and identity functions are the trick we use to represent variables (there are of course other constructors, for example to build constants or functions from all their derivatives if they are known beforehand). From the user point of view, the <tt>x</tt> instance can be seen as the <tt>x</tt> variable, but it is really the identity function applied to free parameter number 0. As the identity function, it has the same value as its parameter, its first derivative is 1.0 with respect to this free parameter, and all its higher order derivatives are 0.0. This can be checked by calling the getValue() or getPartialDerivative() methods on <tt>x</tt>. </p> 
<p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""method"">
    z.getPartialDerivative(1) 
  </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
<p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p> 
<p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""class"">
    getPartialDerivative 
  </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p> 
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p> 
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>",UnivariateFunction,class
,4.7 Differentiation,"<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p> 
<p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
<div class=""source""> 
 <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
</div> 
<p> In fact, there are no notions of <i>variables</i> in the framework, so neither <tt>x</tt> nor <tt>y</tt> are considered to be variables per se. They are both considered to be <i>functions</i> and to depend on implicit free parameters which are represented only by indices in the framework. The <tt>x</tt> instance above is there considered by the framework to be a function of free parameter <tt>p0</tt> at index 0, and as <tt>y</tt> is computed from <tt>x</tt> it is the result of a functions composition and is therefore also a function of this <tt>p0</tt> free parameter. The <tt>p0</tt> is not represented by itself, it is simply defined implicitely by the 0 index above. This index is the third argument in the constructor of the <tt>x</tt> instance. What this constructor means is that we built <tt>x</tt> as a function that depends on one free parameter only (first constructor argument set to 1), that can be differentiated up to order 3 (second constructor argument set to 3), and which correspond to an identity function with respect to implicit free parameter number 0 (third constructor argument set to 0), with current value equal to 2.5 (fourth constructor argument set to 2.5). This specific constructor defines identity functions, and identity functions are the trick we use to represent variables (there are of course other constructors, for example to build constants or functions from all their derivatives if they are known beforehand). From the user point of view, the <tt>x</tt> instance can be seen as the <tt>x</tt> variable, but it is really the identity function applied to free parameter number 0. As the identity function, it has the same value as its parameter, its first derivative is 1.0 with respect to this free parameter, and all its higher order derivatives are 0.0. This can be checked by calling the getValue() or getPartialDerivative() methods on <tt>x</tt>. </p> 
<p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""method"">
    z.getPartialDerivative(1) 
  </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
<p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p> 
<p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""class"">
    getPartialDerivative 
  </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p> 
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p> 
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>",UnivariateFunctionDifferentiator,class
,4.7 Differentiation,"<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p> 
<p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
<div class=""source""> 
 <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
</div> 
<p> In fact, there are no notions of <i>variables</i> in the framework, so neither <tt>x</tt> nor <tt>y</tt> are considered to be variables per se. They are both considered to be <i>functions</i> and to depend on implicit free parameters which are represented only by indices in the framework. The <tt>x</tt> instance above is there considered by the framework to be a function of free parameter <tt>p0</tt> at index 0, and as <tt>y</tt> is computed from <tt>x</tt> it is the result of a functions composition and is therefore also a function of this <tt>p0</tt> free parameter. The <tt>p0</tt> is not represented by itself, it is simply defined implicitely by the 0 index above. This index is the third argument in the constructor of the <tt>x</tt> instance. What this constructor means is that we built <tt>x</tt> as a function that depends on one free parameter only (first constructor argument set to 1), that can be differentiated up to order 3 (second constructor argument set to 3), and which correspond to an identity function with respect to implicit free parameter number 0 (third constructor argument set to 0), with current value equal to 2.5 (fourth constructor argument set to 2.5). This specific constructor defines identity functions, and identity functions are the trick we use to represent variables (there are of course other constructors, for example to build constants or functions from all their derivatives if they are known beforehand). From the user point of view, the <tt>x</tt> instance can be seen as the <tt>x</tt> variable, but it is really the identity function applied to free parameter number 0. As the identity function, it has the same value as its parameter, its first derivative is 1.0 with respect to this free parameter, and all its higher order derivatives are 0.0. This can be checked by calling the getValue() or getPartialDerivative() methods on <tt>x</tt>. </p> 
<p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""method"">
    z.getPartialDerivative(1) 
  </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
<p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p> 
<p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""getPartialDerivative"" kind=""class"">
    getPartialDerivative 
  </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p> 
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p> 
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>",FiniteDifferencesDifferentiator,class
,5.2 Erf functions,"<clt fqn=""org.apache.commons.math3.special.Erf"" api=""Erf"" kind=""unknown"">
  5.2 Erf functions Erf contains several useful functions involving the Error Function, Erf. Function Method Reference Error Function erf See Erf from MathWorld 
</clt>",Erf,unknown
,5.3 Gamma functions,"<clt fqn=""org.apache.commons.math3.special.Gamma.regularizedGammaP"" api=""regularizedGammaP"" kind=""method"">
  5.3 Gamma functions Class Gamma contains several useful functions involving the Gamma Function. Gamma Gamma.gamma(x) computes the Gamma function, ?(x) (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System. Interval Values tested Average error Standard deviation Maximum error -5 &lt; x &lt; -4 x[i] = i / 1024, i = -5119, ..., -4097 0.49 ulps 0.57 ulps 3.0 ulps -4 &lt; x &lt; -3 x[i] = i / 1024, i = -4095, ..., -3073 0.36 ulps 0.51 ulps 2.0 ulps -3 &lt; x &lt; -2 x[i] = i / 1024, i = -3071, ..., -2049 0.41 ulps 0.53 ulps 2.0 ulps -2 &lt; x &lt; -1 x[i] = i / 1024, i = -2047, ..., -1025 0.37 ulps 0.50 ulps 2.0 ulps -1 &lt; x &lt; 0 x[i] = i / 1024, i = -1023, ..., -1 0.46 ulps 0.54 ulps 2.0 ulps 0 &lt; x ? 8 x[i] = i / 1024, i = 1, ..., 8192 0.33 ulps 0.48 ulps 2.0 ulps 8 &lt; x ? 141 x[i] = i / 64, i = 513, ..., 9024 1.32 ulps 1.19 ulps 7.0 ulps Log Gamma Gamma.logGamma(x) computes the natural logarithm of the Gamma function, log ?(x), for x &gt; 0 (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System. Interval Values tested Average error Standard deviation Maximum error 0 &lt; x ? 8 x[i] = i / 1024, i = 1, ..., 8192 0.32 ulps 0.50 ulps 4.0 ulps 8 &lt; x ? 1024 x[i] = i / 8, i = 65, ..., 8192 0.43 ulps 0.53 ulps 3.0 ulps 1024 &lt; x ? 8192 x[i], i = 1025, ..., 8192 0.53 ulps 0.56 ulps 3.0 ulps 8933.439345993791 ? x ? 1.75555970201398e+305 x[i] = 2**(i / 8), i = 105, ..., 8112 0.35 ulps 0.49 ulps 2.0 ulps Regularized Gamma Gamma.regularizedGammaP(a, x) computes the value of the regularized Gamma function, P(a, x) (see MathWorld). 
</clt>",regularizedGammaP,method
,6.2 Double array utilities,"<h3>6.2 Double array utilities</h3> 
<p> To maintain statistics based on a &quot;rolling&quot; window of values, a resizable array implementation was developed and is provided for reuse in the <tt>util</tt> package. The core functionality provided is described in the documentation for the interface, <a href=""../apidocs/org/apache/commons/math3/util/DoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.DoubleArray"" api=""DoubleArray"" kind=""class"">
    DoubleArray 
  </clt></a>. This interface adds one method, <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""method"">
    addElementRolling(double) 
  </clt></tt> to basic list accessors. The <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""class"">
    addElementRolling 
  </clt></tt> method adds an element (the actual parameter) to the end of the list and removes the first element in the list. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/util/ResizableDoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray"" api=""ResizableDoubleArray"" kind=""class"">
    ResizableDoubleArray 
  </clt></a> class provides a configurable, array-backed implementation of the <tt> 
  <clt fqn=""org.apache.commons.math3.util.DoubleArray"" api=""DoubleArray"" kind=""class"">
    DoubleArray 
  </clt></tt> interface. When <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""class"">
    addElementRolling 
  </clt></tt> is invoked, the underlying array is expanded if necessary, the new element is added to the end of the array and the &quot;usable window&quot; of the array is moved forward, so that the first element is effectively discarded, what was the second becomes the first, and so on. To efficiently manage storage, two maintenance operations need to be periodically performed -- orphaned elements at the beginning of the array need to be reclaimed and space for new elements at the end needs to be created. Both of these operations are handled automatically, with frequency / effect driven by the configuration properties <tt>expansionMode</tt>, <tt>expansionFactor</tt> and <tt>contractionCriteria.</tt> See <a href=""../apidocs/org/apache/commons/math3/util/ResizableDoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray"" api=""ResizableDoubleArray"" kind=""class"">
    ResizableDoubleArray 
  </clt></a> for details. </p>",DoubleArray,class
,6.2 Double array utilities,"<h3>6.2 Double array utilities</h3> 
<p> To maintain statistics based on a &quot;rolling&quot; window of values, a resizable array implementation was developed and is provided for reuse in the <tt>util</tt> package. The core functionality provided is described in the documentation for the interface, <a href=""../apidocs/org/apache/commons/math3/util/DoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.DoubleArray"" api=""DoubleArray"" kind=""class"">
    DoubleArray 
  </clt></a>. This interface adds one method, <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""method"">
    addElementRolling(double) 
  </clt></tt> to basic list accessors. The <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""class"">
    addElementRolling 
  </clt></tt> method adds an element (the actual parameter) to the end of the list and removes the first element in the list. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/util/ResizableDoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray"" api=""ResizableDoubleArray"" kind=""class"">
    ResizableDoubleArray 
  </clt></a> class provides a configurable, array-backed implementation of the <tt> 
  <clt fqn=""org.apache.commons.math3.util.DoubleArray"" api=""DoubleArray"" kind=""class"">
    DoubleArray 
  </clt></tt> interface. When <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""class"">
    addElementRolling 
  </clt></tt> is invoked, the underlying array is expanded if necessary, the new element is added to the end of the array and the &quot;usable window&quot; of the array is moved forward, so that the first element is effectively discarded, what was the second becomes the first, and so on. To efficiently manage storage, two maintenance operations need to be periodically performed -- orphaned elements at the beginning of the array need to be reclaimed and space for new elements at the end needs to be created. Both of these operations are handled automatically, with frequency / effect driven by the configuration properties <tt>expansionMode</tt>, <tt>expansionFactor</tt> and <tt>contractionCriteria.</tt> See <a href=""../apidocs/org/apache/commons/math3/util/ResizableDoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray"" api=""ResizableDoubleArray"" kind=""class"">
    ResizableDoubleArray 
  </clt></a> for details. </p>",addElementRolling,method
,6.2 Double array utilities,"<h3>6.2 Double array utilities</h3> 
<p> To maintain statistics based on a &quot;rolling&quot; window of values, a resizable array implementation was developed and is provided for reuse in the <tt>util</tt> package. The core functionality provided is described in the documentation for the interface, <a href=""../apidocs/org/apache/commons/math3/util/DoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.DoubleArray"" api=""DoubleArray"" kind=""class"">
    DoubleArray 
  </clt></a>. This interface adds one method, <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""method"">
    addElementRolling(double) 
  </clt></tt> to basic list accessors. The <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""class"">
    addElementRolling 
  </clt></tt> method adds an element (the actual parameter) to the end of the list and removes the first element in the list. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/util/ResizableDoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray"" api=""ResizableDoubleArray"" kind=""class"">
    ResizableDoubleArray 
  </clt></a> class provides a configurable, array-backed implementation of the <tt> 
  <clt fqn=""org.apache.commons.math3.util.DoubleArray"" api=""DoubleArray"" kind=""class"">
    DoubleArray 
  </clt></tt> interface. When <tt> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"" api=""addElementRolling"" kind=""class"">
    addElementRolling 
  </clt></tt> is invoked, the underlying array is expanded if necessary, the new element is added to the end of the array and the &quot;usable window&quot; of the array is moved forward, so that the first element is effectively discarded, what was the second becomes the first, and so on. To efficiently manage storage, two maintenance operations need to be periodically performed -- orphaned elements at the beginning of the array need to be reclaimed and space for new elements at the end needs to be created. Both of these operations are handled automatically, with frequency / effect driven by the configuration properties <tt>expansionMode</tt>, <tt>expansionFactor</tt> and <tt>contractionCriteria.</tt> See <a href=""../apidocs/org/apache/commons/math3/util/ResizableDoubleArray.html""> 
  <clt fqn=""org.apache.commons.math3.util.ResizableDoubleArray"" api=""ResizableDoubleArray"" kind=""class"">
    ResizableDoubleArray 
  </clt></a> for details. </p>",ResizableDoubleArray,class
,6.4 Continued Fractions,"<h3>6.4 Continued Fractions</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/util/ContinuedFraction.html""> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction"" api=""ContinuedFraction"" kind=""class"">
    ContinuedFraction 
  </clt></a> class provides a generic way to create and evaluate continued fractions. The easiest way to create a continued fraction is to subclass <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction"" api=""ContinuedFraction"" kind=""class"">
    ContinuedFraction 
  </clt></tt> and override the <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction.getA"" api=""getA"" kind=""unknown"">
    getA 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction.getB"" api=""getB"" kind=""unknown"">
    getB 
  </clt></tt> methods which return the continued fraction terms. The precise definition of these terms is explained in <a class=""externalLink"" href=""http://mathworld.wolfram.com/ContinuedFraction.html""> Continued Fraction, equation (1)</a> from MathWorld. </p> 
<p> As an example, the constant Pi can be computed using a <a class=""externalLink"" href=""http://functions.wolfram.com/Constants/Pi/10/0002/"">continued fraction</a>. The following anonymous class provides the implementation: </p> 
<div class=""source""> 
 <pre>ContinuedFraction c = new ContinuedFraction() {
    public double getA(int n, double x) {
        switch(n) {
            case 0: return 3.0;
            default: return 6.0;
        }
    }
    
    public double getB(int n, double x) {
        double y = (2.0 * n) - 1.0;
        return y * y;
    }
}</pre> 
</div> 
<p> Then, to evalute Pi, simply call any of the <tt>evalute</tt> methods (Note, the point of evalution in this example is meaningless since Pi is a constant). </p> 
<p> For a more practical use of continued fractions, consider the <a class=""externalLink"" href=""http://functions.wolfram.com/ElementaryFunctions/Exp/10/"">exponential function</a>. The following anonymous class provides its implementation: </p> 
<div class=""source""> 
 <pre>ContinuedFraction c = new ContinuedFraction() {
    public double getA(int n, double x) {
        if (n % 2 == 0) {
            switch(n) {
                case 0: return 1.0;
                default: return 2.0;
            }
        } else {
            return n;
        }
    }
    
    public double getB(int n, double x) {
        if (n % 2 == 0) {
            return -x;
        } else {
            return x;
        }
    }
}</pre> 
</div> 
<p> Then, to evalute <i>e</i><sup>x</sup> for any value x, simply call any of the <tt>evalute</tt> methods. </p>",ContinuedFraction,class
,6.4 Continued Fractions,"<h3>6.4 Continued Fractions</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/util/ContinuedFraction.html""> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction"" api=""ContinuedFraction"" kind=""class"">
    ContinuedFraction 
  </clt></a> class provides a generic way to create and evaluate continued fractions. The easiest way to create a continued fraction is to subclass <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction"" api=""ContinuedFraction"" kind=""class"">
    ContinuedFraction 
  </clt></tt> and override the <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction.getA"" api=""getA"" kind=""unknown"">
    getA 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction.getB"" api=""getB"" kind=""unknown"">
    getB 
  </clt></tt> methods which return the continued fraction terms. The precise definition of these terms is explained in <a class=""externalLink"" href=""http://mathworld.wolfram.com/ContinuedFraction.html""> Continued Fraction, equation (1)</a> from MathWorld. </p> 
<p> As an example, the constant Pi can be computed using a <a class=""externalLink"" href=""http://functions.wolfram.com/Constants/Pi/10/0002/"">continued fraction</a>. The following anonymous class provides the implementation: </p> 
<div class=""source""> 
 <pre>ContinuedFraction c = new ContinuedFraction() {
    public double getA(int n, double x) {
        switch(n) {
            case 0: return 3.0;
            default: return 6.0;
        }
    }
    
    public double getB(int n, double x) {
        double y = (2.0 * n) - 1.0;
        return y * y;
    }
}</pre> 
</div> 
<p> Then, to evalute Pi, simply call any of the <tt>evalute</tt> methods (Note, the point of evalution in this example is meaningless since Pi is a constant). </p> 
<p> For a more practical use of continued fractions, consider the <a class=""externalLink"" href=""http://functions.wolfram.com/ElementaryFunctions/Exp/10/"">exponential function</a>. The following anonymous class provides its implementation: </p> 
<div class=""source""> 
 <pre>ContinuedFraction c = new ContinuedFraction() {
    public double getA(int n, double x) {
        if (n % 2 == 0) {
            switch(n) {
                case 0: return 1.0;
                default: return 2.0;
            }
        } else {
            return n;
        }
    }
    
    public double getB(int n, double x) {
        if (n % 2 == 0) {
            return -x;
        } else {
            return x;
        }
    }
}</pre> 
</div> 
<p> Then, to evalute <i>e</i><sup>x</sup> for any value x, simply call any of the <tt>evalute</tt> methods. </p>",getA,unknown
,6.4 Continued Fractions,"<h3>6.4 Continued Fractions</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/util/ContinuedFraction.html""> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction"" api=""ContinuedFraction"" kind=""class"">
    ContinuedFraction 
  </clt></a> class provides a generic way to create and evaluate continued fractions. The easiest way to create a continued fraction is to subclass <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction"" api=""ContinuedFraction"" kind=""class"">
    ContinuedFraction 
  </clt></tt> and override the <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction.getA"" api=""getA"" kind=""unknown"">
    getA 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.util.ContinuedFraction.getB"" api=""getB"" kind=""unknown"">
    getB 
  </clt></tt> methods which return the continued fraction terms. The precise definition of these terms is explained in <a class=""externalLink"" href=""http://mathworld.wolfram.com/ContinuedFraction.html""> Continued Fraction, equation (1)</a> from MathWorld. </p> 
<p> As an example, the constant Pi can be computed using a <a class=""externalLink"" href=""http://functions.wolfram.com/Constants/Pi/10/0002/"">continued fraction</a>. The following anonymous class provides the implementation: </p> 
<div class=""source""> 
 <pre>ContinuedFraction c = new ContinuedFraction() {
    public double getA(int n, double x) {
        switch(n) {
            case 0: return 3.0;
            default: return 6.0;
        }
    }
    
    public double getB(int n, double x) {
        double y = (2.0 * n) - 1.0;
        return y * y;
    }
}</pre> 
</div> 
<p> Then, to evalute Pi, simply call any of the <tt>evalute</tt> methods (Note, the point of evalution in this example is meaningless since Pi is a constant). </p> 
<p> For a more practical use of continued fractions, consider the <a class=""externalLink"" href=""http://functions.wolfram.com/ElementaryFunctions/Exp/10/"">exponential function</a>. The following anonymous class provides its implementation: </p> 
<div class=""source""> 
 <pre>ContinuedFraction c = new ContinuedFraction() {
    public double getA(int n, double x) {
        if (n % 2 == 0) {
            switch(n) {
                case 0: return 1.0;
                default: return 2.0;
            }
        } else {
            return n;
        }
    }
    
    public double getB(int n, double x) {
        if (n % 2 == 0) {
            return -x;
        } else {
            return x;
        }
    }
}</pre> 
</div> 
<p> Then, to evalute <i>e</i><sup>x</sup> for any value x, simply call any of the <tt>evalute</tt> methods. </p>",getB,unknown
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",ArithmeticUtils,class
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",binomialCoefficient,method
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",binomialCoefficientDouble,method
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",binomialCoefficientLog,method
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",stirlingS2,method
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",factorial,method
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",factorialDouble,method
,"6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions","<h3>6.5 Binomial coefficients, factorials, Stirling numbers and other common math functions</h3> 
<p> A collection of reusable math functions is provided in the <a href=""../apidocs/org/apache/commons/math3/util/ArithmeticUtils.html""> 
  <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils"" api=""ArithmeticUtils"" kind=""class"">
    ArithmeticUtils 
  </clt></a> utility class. ArithmeticUtils currently includes methods to compute the following: </p> 
<ul> 
 <li> Binomial coefficients -- &quot;n choose k&quot; available as an (exact) long value, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"" api=""binomialCoefficient"" kind=""method"">
     binomialCoefficient(int, int) 
   </clt></tt> for small n, k; as a double, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"" api=""binomialCoefficientDouble"" kind=""method"">
     binomialCoefficientDouble(int, int) 
   </clt></tt> for larger values; and in a &quot;super-sized&quot; version, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"" api=""binomialCoefficientLog"" kind=""method"">
     binomialCoefficientLog(int, int) 
   </clt></tt> that returns the natural logarithm of the value.</li> 
 <li> Stirling numbers of the second kind -- S(n,k) as an exact long value <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"" api=""stirlingS2"" kind=""method"">
     stirlingS2(int, int) 
   </clt></tt> for small n, k.</li> 
 <li> Factorials -- like binomial coefficients, these are available as exact long values, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorial"" api=""factorial"" kind=""method"">
     factorial(int) 
   </clt></tt>; doubles, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"" api=""factorialDouble"" kind=""method"">
     factorialDouble(int) 
   </clt></tt>; or logs, <tt> 
   <clt fqn=""org.apache.commons.math3.util.ArithmeticUtils.factorialLog"" api=""factorialLog"" kind=""method"">
     factorialLog(int) 
   </clt></tt>. </li> 
 <li> Least common multiple and greatest common denominator functions. </li> 
</ul>",factorialLog,method
,6.6 Fast mathematical functions,"<h3>6.6 Fast mathematical functions</h3> 
<p> Apache Commons Math provides a faster, more accurate, portable alternative to the regular <tt>Math</tt> and <tt>StrictMath</tt>classes for large scale computation. </p> 
<p> FastMath is a drop-in replacement for both Math and StrictMath. This means that for any method in Math (say <tt>Math.sin(x)</tt> or <tt>Math.cbrt(y)</tt>), user can directly change the class and use the methods as is (using <tt> 
  <clt fqn=""org.apache.commons.math3.util.FastMath.sin"" api=""sin"" kind=""method"">
    FastMath.sin(x) 
  </clt></tt> or <tt> 
  <clt fqn=""org.apache.commons.math3.util.FastMath.cbrt"" api=""cbrt"" kind=""method"">
    FastMath.cbrt(y) 
  </clt></tt> in the previous example). </p> 
<p> FastMath speed is achieved by relying heavily on optimizing compilers to native code present in many JVM todays and use of large tables. Precomputed literal arrays are provided in this class to speed up load time. These precomputed tables are used in the default configuration, to improve speed even at first use of the class. If users prefer to compute the tables automatically at load time, they can change a compile-time constant. This will increase class load time at first use, but this overhead will occur only once per run, regardless of the number of subsequent calls to computation methods. Note that FastMath is extensively used inside Apache Commons Math, so by calling some algorithms, the one-shot overhead when the constant is set to false will occur regardless of the end-user calling FastMath methods directly or not. Performance figures for a specific JVM and hardware can be evaluated by running the FastMathTestPerformance tests in the test directory of the source distribution. </p> 
<p> FastMath accuracy should be mostly independent of the JVM as it relies only on IEEE-754 basic operations and on embedded tables. Almost all operations are accurate to about 0.5 ulp throughout the domain range. This statement, of course is only a rough global observed behavior, it is <i>not</i> a guarantee for <i>every</i> double numbers input (see William Kahan's <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma"">Table Maker's Dilemma</a>). </p> 
<p> FastMath additionally implements the following methods not found in Math/StrictMath: </p> 
<ul> 
 <li>asinh(double)</li> 
 <li>acosh(double)</li> 
 <li>atanh(double)</li> 
 <li>pow(double,int)</li> 
</ul> The following methods are found in Math/StrictMath since 1.6 only, they are provided by FastMath even in 1.5 Java virtual machines 
<ul> 
 <li>copySign(double, double)</li> 
 <li>getExponent(double)</li> 
 <li>nextAfter(double,double)</li> 
 <li>nextUp(double)</li> 
 <li>scalb(double, int)</li> 
 <li>copySign(float, float)</li> 
 <li>getExponent(float)</li> 
 <li>nextAfter(float,double)</li> 
 <li>nextUp(float)</li> 
 <li>scalb(float, int)</li> 
</ul>",sin,method
,6.6 Fast mathematical functions,"<h3>6.6 Fast mathematical functions</h3> 
<p> Apache Commons Math provides a faster, more accurate, portable alternative to the regular <tt>Math</tt> and <tt>StrictMath</tt>classes for large scale computation. </p> 
<p> FastMath is a drop-in replacement for both Math and StrictMath. This means that for any method in Math (say <tt>Math.sin(x)</tt> or <tt>Math.cbrt(y)</tt>), user can directly change the class and use the methods as is (using <tt> 
  <clt fqn=""org.apache.commons.math3.util.FastMath.sin"" api=""sin"" kind=""method"">
    FastMath.sin(x) 
  </clt></tt> or <tt> 
  <clt fqn=""org.apache.commons.math3.util.FastMath.cbrt"" api=""cbrt"" kind=""method"">
    FastMath.cbrt(y) 
  </clt></tt> in the previous example). </p> 
<p> FastMath speed is achieved by relying heavily on optimizing compilers to native code present in many JVM todays and use of large tables. Precomputed literal arrays are provided in this class to speed up load time. These precomputed tables are used in the default configuration, to improve speed even at first use of the class. If users prefer to compute the tables automatically at load time, they can change a compile-time constant. This will increase class load time at first use, but this overhead will occur only once per run, regardless of the number of subsequent calls to computation methods. Note that FastMath is extensively used inside Apache Commons Math, so by calling some algorithms, the one-shot overhead when the constant is set to false will occur regardless of the end-user calling FastMath methods directly or not. Performance figures for a specific JVM and hardware can be evaluated by running the FastMathTestPerformance tests in the test directory of the source distribution. </p> 
<p> FastMath accuracy should be mostly independent of the JVM as it relies only on IEEE-754 basic operations and on embedded tables. Almost all operations are accurate to about 0.5 ulp throughout the domain range. This statement, of course is only a rough global observed behavior, it is <i>not</i> a guarantee for <i>every</i> double numbers input (see William Kahan's <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma"">Table Maker's Dilemma</a>). </p> 
<p> FastMath additionally implements the following methods not found in Math/StrictMath: </p> 
<ul> 
 <li>asinh(double)</li> 
 <li>acosh(double)</li> 
 <li>atanh(double)</li> 
 <li>pow(double,int)</li> 
</ul> The following methods are found in Math/StrictMath since 1.6 only, they are provided by FastMath even in 1.5 Java virtual machines 
<ul> 
 <li>copySign(double, double)</li> 
 <li>getExponent(double)</li> 
 <li>nextAfter(double,double)</li> 
 <li>nextUp(double)</li> 
 <li>scalb(double, int)</li> 
 <li>copySign(float, float)</li> 
 <li>getExponent(float)</li> 
 <li>nextAfter(float,double)</li> 
 <li>nextUp(float)</li> 
 <li>scalb(float, int)</li> 
</ul>",cbrt,method
,6.7 Miscellaneous,"<h3>6.7 Miscellaneous</h3> The 
<a href=""../apidocs/org/apache/commons/math3/util/MultidimensionalCounter.html""> 
 <clt fqn=""org.apache.commons.math3.util.MultidimensionalCounter"" api=""MultidimensionalCounter"" kind=""class"">
   MultidimensionalCounter 
 </clt></a> is a utility class that converts a set of indices (identifying points in a multidimensional space) to a single index (e.g. identifying a location in a one-dimensional array.",MultidimensionalCounter,class
,7.1 Overview,"<clt fqn=""org.apache.commons.math3.complex.Complex.NaN"" api=""NaN"" kind=""class"">
  7 Complex Numbers 7.1 Overview The complex packages provides a complex number type as well as complex versions of common transcendental functions and complex number formatting. 7.2 Complex Numbers Complex provides a complex number type that forms the basis for the complex functionality found in commons-math. Complex functions and arithmetic operations are implemented in commons-math by applying standard computational formulas and following the rules for java.lang.Double arithmetic in handling infinite and NaN values. No attempt is made to comply with ANSII/IEC C99x Annex G or any other standard for Complex arithmetic. See the class and method javadocs for the Complex and ComplexUtils classes for details on computing formulas. To create a complex number, simply call the constructor passing in two floating-point arguments, the first being the real part of the complex number and the second being the imaginary part: Complex c = new Complex(1.0, 3.0); // 1 + 3i Complex numbers may also be created from polar representations using the polar2Complex method in ComplexUtils . The Complex class provides basic unary and binary complex number operations. These operations provide the means to add, subtract, multiply and divide complex numbers along with other complex number functions similar to the real number functions found in java.math.BigDecimal: Complex lhs = new Complex(1.0, 3.0); Complex rhs = new Complex(2.0, 5.0); Complex answer = lhs.add(rhs); // add two complex numbers answer = lhs.subtract(rhs); // subtract two complex numbers answer = lhs.abs(); // absolute value answer = lhs.conjugate(rhs); // complex conjugate 7.3 Complex Transcendental Functions Complex also provides implementations of serveral transcendental functions involving complex number arguments. Prior to version 1.2, these functions were provided by ComplexUtils in a way similar to the real number functions found in java.lang.Math, but this has been deprecated. These operations provide the means to compute the log, sine, tangent, and other complex values : Complex first = new Complex(1.0, 3.0); Complex second = new Complex(2.0, 5.0); Complex answer = first.log(); // natural logarithm. answer = first.cos(); // cosine answer = first.pow(second); // first raised to the power of second 7.4 Complex Formatting and Parsing Complex instances can be converted to and from strings using the ComplexFormat class. ComplexFormat is a java.text.Format extension and, as such, is used like other formatting objects (e.g. java.text.SimpleDateFormat): ComplexFormat format = new ComplexFormat(); // default format Complex c = new Complex(1.1111, 2.2222); String s = format.format(c); // s contains &quot;1.11 + 2.22i&quot; To customize the formatting output, one or two java.text.NumberFormat instances can be used to construct a ComplexFormat . These number formats control the formatting of the real and imaginary values of the complex number: NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(3); nf.setMaximumFractionDigits(3); // create complex format with custom number format // when one number format is used, both real and // imaginary parts are formatted the same ComplexFormat cf = new ComplexFormat(nf); Complex c = new Complex(1.11, 2.2222); String s = format.format(c); // s contains &quot;1.110 + 2.222i&quot; NumberFormat nf2 = NumberFormat.getInstance(); nf.setMinimumFractionDigits(1); nf.setMaximumFractionDigits(1); // create complex format with custom number formats cf = new ComplexFormat(nf, nf2); s = format.format(c); // s contains &quot;1.110 + 2.2i&quot; Another formatting customization provided by ComplexFormat is the text used for the imaginary designation. By default, the imaginary notation is &quot;i&quot; but, it can be manipulated using the setImaginaryCharacter method. Formatting inverse operation, parsing, can also be performed by ComplexFormat . Parse a complex number from a string, simply call the parse method: ComplexFormat cf = new ComplexFormat(); Complex c = cf.parse(&quot;1.110 + 2.222i&quot;); 
</clt>",NaN,class
,7.2 Complex Numbers,"<clt fqn=""org.apache.commons.math3.complex.Complex.NaN"" api=""NaN"" kind=""class"">
  7 Complex Numbers 7.1 Overview The complex packages provides a complex number type as well as complex versions of common transcendental functions and complex number formatting. 7.2 Complex Numbers Complex provides a complex number type that forms the basis for the complex functionality found in commons-math. Complex functions and arithmetic operations are implemented in commons-math by applying standard computational formulas and following the rules for java.lang.Double arithmetic in handling infinite and NaN values. No attempt is made to comply with ANSII/IEC C99x Annex G or any other standard for Complex arithmetic. See the class and method javadocs for the Complex and ComplexUtils classes for details on computing formulas. To create a complex number, simply call the constructor passing in two floating-point arguments, the first being the real part of the complex number and the second being the imaginary part: Complex c = new Complex(1.0, 3.0); // 1 + 3i Complex numbers may also be created from polar representations using the polar2Complex method in ComplexUtils . The Complex class provides basic unary and binary complex number operations. These operations provide the means to add, subtract, multiply and divide complex numbers along with other complex number functions similar to the real number functions found in java.math.BigDecimal: Complex lhs = new Complex(1.0, 3.0); Complex rhs = new Complex(2.0, 5.0); Complex answer = lhs.add(rhs); // add two complex numbers answer = lhs.subtract(rhs); // subtract two complex numbers answer = lhs.abs(); // absolute value answer = lhs.conjugate(rhs); // complex conjugate 7.3 Complex Transcendental Functions Complex also provides implementations of serveral transcendental functions involving complex number arguments. Prior to version 1.2, these functions were provided by ComplexUtils in a way similar to the real number functions found in java.lang.Math, but this has been deprecated. These operations provide the means to compute the log, sine, tangent, and other complex values : Complex first = new Complex(1.0, 3.0); Complex second = new Complex(2.0, 5.0); Complex answer = first.log(); // natural logarithm. answer = first.cos(); // cosine answer = first.pow(second); // first raised to the power of second 7.4 Complex Formatting and Parsing Complex instances can be converted to and from strings using the ComplexFormat class. ComplexFormat is a java.text.Format extension and, as such, is used like other formatting objects (e.g. java.text.SimpleDateFormat): ComplexFormat format = new ComplexFormat(); // default format Complex c = new Complex(1.1111, 2.2222); String s = format.format(c); // s contains &quot;1.11 + 2.22i&quot; To customize the formatting output, one or two java.text.NumberFormat instances can be used to construct a ComplexFormat . These number formats control the formatting of the real and imaginary values of the complex number: NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(3); nf.setMaximumFractionDigits(3); // create complex format with custom number format // when one number format is used, both real and // imaginary parts are formatted the same ComplexFormat cf = new ComplexFormat(nf); Complex c = new Complex(1.11, 2.2222); String s = format.format(c); // s contains &quot;1.110 + 2.222i&quot; NumberFormat nf2 = NumberFormat.getInstance(); nf.setMinimumFractionDigits(1); nf.setMaximumFractionDigits(1); // create complex format with custom number formats cf = new ComplexFormat(nf, nf2); s = format.format(c); // s contains &quot;1.110 + 2.2i&quot; Another formatting customization provided by ComplexFormat is the text used for the imaginary designation. By default, the imaginary notation is &quot;i&quot; but, it can be manipulated using the setImaginaryCharacter method. Formatting inverse operation, parsing, can also be performed by ComplexFormat . Parse a complex number from a string, simply call the parse method: ComplexFormat cf = new ComplexFormat(); Complex c = cf.parse(&quot;1.110 + 2.222i&quot;); 
</clt>",NaN,class
,7.3 Complex Transcendental Functions,"<clt fqn=""org.apache.commons.math3.complex.Complex.NaN"" api=""NaN"" kind=""class"">
  7 Complex Numbers 7.1 Overview The complex packages provides a complex number type as well as complex versions of common transcendental functions and complex number formatting. 7.2 Complex Numbers Complex provides a complex number type that forms the basis for the complex functionality found in commons-math. Complex functions and arithmetic operations are implemented in commons-math by applying standard computational formulas and following the rules for java.lang.Double arithmetic in handling infinite and NaN values. No attempt is made to comply with ANSII/IEC C99x Annex G or any other standard for Complex arithmetic. See the class and method javadocs for the Complex and ComplexUtils classes for details on computing formulas. To create a complex number, simply call the constructor passing in two floating-point arguments, the first being the real part of the complex number and the second being the imaginary part: Complex c = new Complex(1.0, 3.0); // 1 + 3i Complex numbers may also be created from polar representations using the polar2Complex method in ComplexUtils . The Complex class provides basic unary and binary complex number operations. These operations provide the means to add, subtract, multiply and divide complex numbers along with other complex number functions similar to the real number functions found in java.math.BigDecimal: Complex lhs = new Complex(1.0, 3.0); Complex rhs = new Complex(2.0, 5.0); Complex answer = lhs.add(rhs); // add two complex numbers answer = lhs.subtract(rhs); // subtract two complex numbers answer = lhs.abs(); // absolute value answer = lhs.conjugate(rhs); // complex conjugate 7.3 Complex Transcendental Functions Complex also provides implementations of serveral transcendental functions involving complex number arguments. Prior to version 1.2, these functions were provided by ComplexUtils in a way similar to the real number functions found in java.lang.Math, but this has been deprecated. These operations provide the means to compute the log, sine, tangent, and other complex values : Complex first = new Complex(1.0, 3.0); Complex second = new Complex(2.0, 5.0); Complex answer = first.log(); // natural logarithm. answer = first.cos(); // cosine answer = first.pow(second); // first raised to the power of second 7.4 Complex Formatting and Parsing Complex instances can be converted to and from strings using the ComplexFormat class. ComplexFormat is a java.text.Format extension and, as such, is used like other formatting objects (e.g. java.text.SimpleDateFormat): ComplexFormat format = new ComplexFormat(); // default format Complex c = new Complex(1.1111, 2.2222); String s = format.format(c); // s contains &quot;1.11 + 2.22i&quot; To customize the formatting output, one or two java.text.NumberFormat instances can be used to construct a ComplexFormat . These number formats control the formatting of the real and imaginary values of the complex number: NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(3); nf.setMaximumFractionDigits(3); // create complex format with custom number format // when one number format is used, both real and // imaginary parts are formatted the same ComplexFormat cf = new ComplexFormat(nf); Complex c = new Complex(1.11, 2.2222); String s = format.format(c); // s contains &quot;1.110 + 2.222i&quot; NumberFormat nf2 = NumberFormat.getInstance(); nf.setMinimumFractionDigits(1); nf.setMaximumFractionDigits(1); // create complex format with custom number formats cf = new ComplexFormat(nf, nf2); s = format.format(c); // s contains &quot;1.110 + 2.2i&quot; Another formatting customization provided by ComplexFormat is the text used for the imaginary designation. By default, the imaginary notation is &quot;i&quot; but, it can be manipulated using the setImaginaryCharacter method. Formatting inverse operation, parsing, can also be performed by ComplexFormat . Parse a complex number from a string, simply call the parse method: ComplexFormat cf = new ComplexFormat(); Complex c = cf.parse(&quot;1.110 + 2.222i&quot;); 
</clt>",NaN,class
,7.4 Complex Formatting and Parsing,"<clt fqn=""org.apache.commons.math3.complex.Complex.NaN"" api=""NaN"" kind=""class"">
  7 Complex Numbers 7.1 Overview The complex packages provides a complex number type as well as complex versions of common transcendental functions and complex number formatting. 7.2 Complex Numbers Complex provides a complex number type that forms the basis for the complex functionality found in commons-math. Complex functions and arithmetic operations are implemented in commons-math by applying standard computational formulas and following the rules for java.lang.Double arithmetic in handling infinite and NaN values. No attempt is made to comply with ANSII/IEC C99x Annex G or any other standard for Complex arithmetic. See the class and method javadocs for the Complex and ComplexUtils classes for details on computing formulas. To create a complex number, simply call the constructor passing in two floating-point arguments, the first being the real part of the complex number and the second being the imaginary part: Complex c = new Complex(1.0, 3.0); // 1 + 3i Complex numbers may also be created from polar representations using the polar2Complex method in ComplexUtils . The Complex class provides basic unary and binary complex number operations. These operations provide the means to add, subtract, multiply and divide complex numbers along with other complex number functions similar to the real number functions found in java.math.BigDecimal: Complex lhs = new Complex(1.0, 3.0); Complex rhs = new Complex(2.0, 5.0); Complex answer = lhs.add(rhs); // add two complex numbers answer = lhs.subtract(rhs); // subtract two complex numbers answer = lhs.abs(); // absolute value answer = lhs.conjugate(rhs); // complex conjugate 7.3 Complex Transcendental Functions Complex also provides implementations of serveral transcendental functions involving complex number arguments. Prior to version 1.2, these functions were provided by ComplexUtils in a way similar to the real number functions found in java.lang.Math, but this has been deprecated. These operations provide the means to compute the log, sine, tangent, and other complex values : Complex first = new Complex(1.0, 3.0); Complex second = new Complex(2.0, 5.0); Complex answer = first.log(); // natural logarithm. answer = first.cos(); // cosine answer = first.pow(second); // first raised to the power of second 7.4 Complex Formatting and Parsing Complex instances can be converted to and from strings using the ComplexFormat class. ComplexFormat is a java.text.Format extension and, as such, is used like other formatting objects (e.g. java.text.SimpleDateFormat): ComplexFormat format = new ComplexFormat(); // default format Complex c = new Complex(1.1111, 2.2222); String s = format.format(c); // s contains &quot;1.11 + 2.22i&quot; To customize the formatting output, one or two java.text.NumberFormat instances can be used to construct a ComplexFormat . These number formats control the formatting of the real and imaginary values of the complex number: NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(3); nf.setMaximumFractionDigits(3); // create complex format with custom number format // when one number format is used, both real and // imaginary parts are formatted the same ComplexFormat cf = new ComplexFormat(nf); Complex c = new Complex(1.11, 2.2222); String s = format.format(c); // s contains &quot;1.110 + 2.222i&quot; NumberFormat nf2 = NumberFormat.getInstance(); nf.setMinimumFractionDigits(1); nf.setMaximumFractionDigits(1); // create complex format with custom number formats cf = new ComplexFormat(nf, nf2); s = format.format(c); // s contains &quot;1.110 + 2.2i&quot; Another formatting customization provided by ComplexFormat is the text used for the imaginary designation. By default, the imaginary notation is &quot;i&quot; but, it can be manipulated using the setImaginaryCharacter method. Formatting inverse operation, parsing, can also be performed by ComplexFormat . Parse a complex number from a string, simply call the parse method: ComplexFormat cf = new ComplexFormat(); Complex c = cf.parse(&quot;1.110 + 2.222i&quot;); 
</clt>",NaN,class
,8.2 Distribution Framework,"<h3>8.2 Distribution Framework</h3> 
<p> The distribution framework provides the means to compute probability density function (PDF) probabilities and cumulative distribution function (CDF) probabilities for common probability distributions. Along with the direct computation of PDF and CDF probabilities, the framework also allows for the computation of inverse PDF and inverse CDF values. </p> 
<p> Using a distribution object, PDF and CDF probabilities are easily computed using the <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"" api=""cumulativeProbability"" kind=""class"">
    cumulativeProbability 
  </clt></tt> methods. For a distribution <tt>X</tt>, and a domain value, <tt>x</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"" api=""cumulativeProbability"" kind=""class"">
    cumulativeProbability 
  </clt></tt> computes <tt>P(X &lt;= x)</tt> (i.e. the lower tail probability of <tt>X</tt>). </p> 
<div class=""source""> 
 <pre>TDistribution t = new TDistribution(29);
double lowerTail = t.cumulativeProbability(-2.656);     // P(T &lt;= -2.656)
double upperTail = 1.0 - t.cumulativeProbability(2.75); // P(T &gt;= 2.75)</pre> 
</div> 
<p> The inverse PDF and CDF values are just as easily computed using the <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"" api=""inverseCumulativeProbability"" kind=""class"">
    inverseCumulativeProbability 
  </clt></tt> methods. For a distribution <tt>X</tt>, and a probability, <tt>p</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"" api=""inverseCumulativeProbability"" kind=""class"">
    inverseCumulativeProbability 
  </clt></tt> computes the domain value <tt>x</tt>, such that: </p> 
<ul> 
 <li><tt>P(X &lt;= x) = p</tt>, for continuous distributions</li> 
 <li><tt>P(X &lt;= x) &lt;= p</tt>, for discrete distributions</li> 
</ul> Notice the different cases for continuous and discrete distributions. This is the result of PDFs not being invertible functions. As such, for discrete distributions, an exact domain value can not be returned. Only the &quot;best&quot; domain value. For Commons-Math, the &quot;best&quot; domain value is determined by the largest domain value whose cumulative probability is less-than or equal to the given probability.",cumulativeProbability,class
,8.2 Distribution Framework,"<h3>8.2 Distribution Framework</h3> 
<p> The distribution framework provides the means to compute probability density function (PDF) probabilities and cumulative distribution function (CDF) probabilities for common probability distributions. Along with the direct computation of PDF and CDF probabilities, the framework also allows for the computation of inverse PDF and inverse CDF values. </p> 
<p> Using a distribution object, PDF and CDF probabilities are easily computed using the <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"" api=""cumulativeProbability"" kind=""class"">
    cumulativeProbability 
  </clt></tt> methods. For a distribution <tt>X</tt>, and a domain value, <tt>x</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"" api=""cumulativeProbability"" kind=""class"">
    cumulativeProbability 
  </clt></tt> computes <tt>P(X &lt;= x)</tt> (i.e. the lower tail probability of <tt>X</tt>). </p> 
<div class=""source""> 
 <pre>TDistribution t = new TDistribution(29);
double lowerTail = t.cumulativeProbability(-2.656);     // P(T &lt;= -2.656)
double upperTail = 1.0 - t.cumulativeProbability(2.75); // P(T &gt;= 2.75)</pre> 
</div> 
<p> The inverse PDF and CDF values are just as easily computed using the <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"" api=""inverseCumulativeProbability"" kind=""class"">
    inverseCumulativeProbability 
  </clt></tt> methods. For a distribution <tt>X</tt>, and a probability, <tt>p</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"" api=""inverseCumulativeProbability"" kind=""class"">
    inverseCumulativeProbability 
  </clt></tt> computes the domain value <tt>x</tt>, such that: </p> 
<ul> 
 <li><tt>P(X &lt;= x) = p</tt>, for continuous distributions</li> 
 <li><tt>P(X &lt;= x) &lt;= p</tt>, for discrete distributions</li> 
</ul> Notice the different cases for continuous and discrete distributions. This is the result of PDFs not being invertible functions. As such, for discrete distributions, an exact domain value can not be returned. Only the &quot;best&quot; domain value. For Commons-Math, the &quot;best&quot; domain value is determined by the largest domain value whose cumulative probability is less-than or equal to the given probability.",inverseCumulativeProbability,class
,8.3 User Defined Distributions,"<h3>8.3 User Defined Distributions</h3> 
<p> Since there are numerous distributions and Commons-Math only directly supports a handful, it may be necessary to extend the distribution framework to satisfy individual needs. It is recommended that the <a href=""../apidocs/org/apache/commons/math3/distribution/Distribution.html"">Distribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/ContinuousDistribution.html""> ContinuousDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/DiscreteDistribution.html""> DiscreteDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/IntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.IntegerDistribution"" api=""IntegerDistribution"" kind=""class"">
    IntegerDistribution 
  </clt></a> interfaces serve as base types for any extension. These serve as the basis for all the distributions directly supported by Commons-Math and using those interfaces for implementation purposes will ensure any extension is compatible with the remainder of Commons-Math. To aid in implementing a distribution extension, the <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractDistribution.html""> AbstractDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractContinuousDistribution.html""> AbstractContinuousDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractIntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution"" api=""AbstractIntegerDistribution"" kind=""class"">
    AbstractIntegerDistribution 
  </clt></a> provide implementation building blocks and offer basic distribution functionality. By extending these abstract classes directly, much of the repetitive distribution implementation is already developed and should save time and effort in developing user-defined distributions. </p>",IntegerDistribution,class
,8.3 User Defined Distributions,"<h3>8.3 User Defined Distributions</h3> 
<p> Since there are numerous distributions and Commons-Math only directly supports a handful, it may be necessary to extend the distribution framework to satisfy individual needs. It is recommended that the <a href=""../apidocs/org/apache/commons/math3/distribution/Distribution.html"">Distribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/ContinuousDistribution.html""> ContinuousDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/DiscreteDistribution.html""> DiscreteDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/IntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.IntegerDistribution"" api=""IntegerDistribution"" kind=""class"">
    IntegerDistribution 
  </clt></a> interfaces serve as base types for any extension. These serve as the basis for all the distributions directly supported by Commons-Math and using those interfaces for implementation purposes will ensure any extension is compatible with the remainder of Commons-Math. To aid in implementing a distribution extension, the <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractDistribution.html""> AbstractDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractContinuousDistribution.html""> AbstractContinuousDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractIntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution"" api=""AbstractIntegerDistribution"" kind=""class"">
    AbstractIntegerDistribution 
  </clt></a> provide implementation building blocks and offer basic distribution functionality. By extending these abstract classes directly, much of the repetitive distribution implementation is already developed and should save time and effort in developing user-defined distributions. </p>",AbstractIntegerDistribution,class
,9.2 Fraction Numbers,"<clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
  9.2 Fraction Numbers Fraction and BigFraction provide fraction number type that forms the basis for the fraction functionality found in Commons-Math. The former one can be used for fractions whose numerators and denominators are small enough to fit in an int (taking care of intermediate values) while the second class should be used when there is a risk the numerator and denominator grow very large. A fraction number, can be built from two integer arguments representing numerator and denominator or from a double which will be approximated: Fraction f = new Fraction(1, 3); // 1 / 3 Fraction g = new Fraction(0.25); // 1 / 4 Of special note with fraction construction, when a fraction is created it is always reduced to lowest terms. The Fraction class provides many unary and binary fraction operations. These operations provide the means to add, subtract, multiple and, divide fractions along with other functions similar to the real number functions found in java.math.BigDecimal: Fraction lhs = new Fraction(1, 3); Fraction rhs = new Fraction(2, 5); Fraction answer = lhs.add(rhs); // add two fractions answer = lhs.subtract(rhs); // subtract two fractions answer = lhs.abs(); // absolute value answer = lhs.reciprocal(); // reciprocal of lhs Like fraction construction, for each of the fraction functions, the resulting fraction is reduced to lowest terms. 
</clt>",Fraction,unknown
,9.3 Fraction Formatting and Parsing,"<clt fqn=""org.apache.commons.math3.fraction.FractionFormat.parse"" api=""parse"" kind=""unknown"">
  9.3 Fraction Formatting and Parsing Fraction instances can be converted to and from strings using the FractionFormat class. FractionFormat is a java.text.Format extension and, as such, is used like other formatting objects (e.g. java.text.SimpleDateFormat): FractionFormat format = new FractionFormat(); // default format Fraction f = new Fraction(2, 4); String s = format.format(f); // s contains &quot;1 / 2&quot;, note the reduced fraction To customize the formatting output, one or two java.text.NumberFormat instances can be used to construct a FractionFormat. These number formats control the formatting of the numerator and denominator of the fraction: NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE); // create fraction format with custom number format // when one number format is used, both numerator and // denominator are formatted the same FractionFormat format = new FractionFormat(nf); Fraction f = new Fraction(2000, 3333); String s = format.format(c); // s contains &quot;2.000 / 3.333&quot; NumberFormat nf2 = NumberFormat.getInstance(Locale.US); // create fraction format with custom number formats format = new FractionFormat(nf, nf2); s = format.format(f); // s contains &quot;2.000 / 3,333&quot; Formatting's inverse operation, parsing, can also be performed by FractionFormat. To parse a fraction from a string, simply call the parse method: FractionFormat ff = new FractionFormat(); Fraction f = ff.parse(&quot;-10 / 21&quot;); 
</clt>",parse,unknown
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",GoalType,class
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",MAXIMIZE,field
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",MINIMIZE,field
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",UnivariateOptimizer,class
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",MultivariateOptimizer,class
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",DifferentiableMultivariateOptimizer,class
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",DifferentiableMultivariateVectorOptimizer,class
,12.1 Overview,"<h3>12.1 Overview</h3> 
<p> The optimization package provides algorithms to optimize (i.e. either minimize or maximize) some objective or cost function. The package is split in several sub-packages dedicated to different kind of functions or algorithms. </p> 
<ul> 
 <li>the univariate package handles univariate scalar functions,</li> 
 <li>the linear package handles multivariate vector linear functions with linear constraints,</li> 
 <li>the direct package handles multivariate scalar functions using direct search methods (i.e. not using derivatives),</li> 
 <li>the general package handles multivariate scalar or vector functions using derivatives.</li> 
 <li>the fitting package handles curve fitting by univariate real functions</li> 
</ul> 
<p> The top level optimization package provides common interfaces for the optimization algorithms provided in sub-packages. The main interfaces defines defines optimizers and convergence checkers. The functions that are optimized by the algorithms provided by this package and its sub-packages are a subset of the one defined in the <tt>analysis</tt> package, namely the real and vector valued functions. These functions are called objective function here. When the goal is to minimize, the functions are often called cost function, this name is not used in this package. </p> 
<p> The type of goal, i.e. minimization or maximization, is defined by the enumerated <a href=""../apidocs/org/apache/commons/math3/optimization/GoalType.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType"" api=""GoalType"" kind=""class"">
    GoalType 
  </clt></a> which has only two values: <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MAXIMIZE"" api=""MAXIMIZE"" kind=""field"">
    MAXIMIZE 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.optimization.GoalType.MINIMIZE"" api=""MINIMIZE"" kind=""field"">
    MINIMIZE 
  </clt></tt>. </p> 
<p> Optimizers are the algorithms that will either minimize or maximize, the objective function by changing its input variables set until an optimal set is found. There are only four interfaces defining the common behavior of optimizers, one for each supported type of objective function: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
     UnivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
     MultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"" api=""DifferentiableMultivariateOptimizer"" kind=""class"">
     DifferentiableMultivariateOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> differentiable multivariate real functions</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/optimization/DifferentiableMultivariateVectorOptimizer.html""> 
   <clt fqn=""org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"" api=""DifferentiableMultivariateVectorOptimizer"" kind=""class"">
     DifferentiableMultivariateVectorOptimizer 
   </clt></a> for <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> differentiable multivariate vectorial functions</a></li> 
</ul> 
<p> Despite there are only four types of supported optimizers, it is possible to optimize a transform a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateVectorFunction.html""> non-differentiable multivariate vectorial function</a> by converting it to a <a href=""../apidocs/org/apache/commons/math3/analysis/MultivariateFunction.html""> non-differentiable multivariate real function</a> thanks to the <a href=""../apidocs/org/apache/commons/math3/optimization/LeastSquaresConverter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.LeastSquaresConverter"" api=""LeastSquaresConverter"" kind=""class"">
    LeastSquaresConverter 
  </clt></a> helper class. The transformed function can be optimized using any implementation of the <a href=""../apidocs/org/apache/commons/math3/optimization/MultivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.MultivariateOptimizer"" api=""MultivariateOptimizer"" kind=""class"">
    MultivariateOptimizer 
  </clt></a> interface. </p> 
<p> For each of the four types of supported optimizers, there is a special implementation which wraps a classical optimizer in order to add it a multi-start feature. This feature call the underlying optimizer several times in sequence with different starting points and returns the best optimum found or all optima if desired. This is a classical way to prevent being trapped into a local extremum when looking for a global one. </p>",LeastSquaresConverter,class
,12.2 Univariate Functions,"<h3>12.2 Univariate Functions</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
    UnivariateOptimizer 
  </clt></a> is used to find the minimal values of a univariate real-valued function <tt>f</tt>. </p> 
<p> These algorithms usage is very similar to root-finding algorithms usage explained in the analysis package. The main difference is that the <tt>solve</tt> methods in root finding algorithms is replaced by <tt> 
  <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer.optimize"" api=""optimize"" kind=""unknown"">
    optimize 
  </clt></tt> methods. </p>",UnivariateOptimizer,class
,12.2 Univariate Functions,"<h3>12.2 Univariate Functions</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/optimization/univariate/UnivariateOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer"" api=""UnivariateOptimizer"" kind=""class"">
    UnivariateOptimizer 
  </clt></a> is used to find the minimal values of a univariate real-valued function <tt>f</tt>. </p> 
<p> These algorithms usage is very similar to root-finding algorithms usage explained in the analysis package. The main difference is that the <tt>solve</tt> methods in root finding algorithms is replaced by <tt> 
  <clt fqn=""org.apache.commons.math3.optim.univariate.UnivariateOptimizer.optimize"" api=""optimize"" kind=""unknown"">
    optimize 
  </clt></tt> methods. </p>",optimize,unknown
,12.4 Direct Methods,"<h3>12.4 Direct Methods</h3> 
<p> Direct search methods only use cost function values, they don't need derivatives and don't either try to compute approximation of the derivatives. According to a 1996 paper by Margaret H. Wright (<a class=""externalLink"" href=""http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz"">Direct Search Methods: Once Scorned, Now Respectable</a>), they are used when either the computation of the derivative is impossible (noisy functions, unpredictable discontinuities) or difficult (complexity, computation cost). In the first cases, rather than an optimum, a <i>not too bad</i> point is desired. In the latter cases, an optimum is desired but cannot be reasonably found. In all cases direct search methods can be useful. </p> 
<p> Simplex-based direct search methods are based on comparison of the cost function values at the vertices of a simplex (which is a set of n+1 points in dimension n) that is updated by the algorithms steps. </p> 
<p> The instances can be built either in single-start or in multi-start mode. Multi-start is a traditional way to try to avoid being trapped in a local minimum and miss the global minimum of a function. It can also be used to verify the convergence of an algorithm. In multi-start mode, the <tt>minimizes</tt>method returns the best minimum found after all starts, and the <tt>etMinima</tt> method can be used to retrieve all minima from all starts (including the one already provided by the <tt>minimizes</tt> method). </p> 
<p> The <tt>direct</tt> package provides four solvers: </p> 
<ul> 
 <li>the classical <a href=""../apidocs/org/apache/commons/math3/optimization/direct/NelderMeadSimplex.html""> Nelder-Mead</a> method,</li> 
 <li>Virginia Torczon's <a href=""../apidocs/org/apache/commons/math3/optimization/direct/MultiDirectionalSimplex.html""> multi-directional</a> method,</li> 
 <li>Nikolaus Hansen's Covariance Matrix Adaptation Evolution Strategy (CMA-ES),</li> 
 <li>Mike Powell's <a href=""../apidocs/org/apache/commons/math3/optimization/direct/BOBYQAOptimizer.html""> BOBYQA</a> method. </li> 
</ul> 
<p> The first two simplex-based methods do not handle simple bounds constraints by themselves. However there are two adapters(<a href=""../apidocs/org/apache/commons/math3/optimization/direct/MultivariateFunctionMappingAdapter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter"" api=""MultivariateFunctionMappingAdapter"" kind=""class"">
    MultivariateFunctionMappingAdapter 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/optimization/direct/MultivariateFunctionPenaltyAdapter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.MultivariateFunctionPenaltyAdapter"" api=""MultivariateFunctionPenaltyAdapter"" kind=""class"">
    MultivariateFunctionPenaltyAdapter 
  </clt></a>) that can be used to wrap the user function in such a way the wrapped function is unbounded and can be used with these optimizers, despite the fact the underlying function is still bounded and will be called only with feasible points that fulfill the constraints. Note however that using these adapters are only a poor man solutions to simple bounds optimization constraints. Better solutions are to use an optimizer that directly supports simple bounds. Some caveats of the mapping adapter solution are that </p> 
<ul> 
 <li>behavior near the bounds may be numerically unstable as bounds are mapped from infinite values,</li> 
 <li>start value is evaluated by the optimizer as an unbounded variable, so it must be converted from bounded to unbounded by user,</li> 
 <li>optimum result is evaluated by the optimizer as an unbounded variable, so it must be converted from unbounded to bounded by user,</li> 
 <li>convergence values are evaluated by the optimizer as unbounded variables, so there will be scales differences when converted to bounded variables,</li> 
 <li>in the case of simplex based solvers, the initial simplex should be set up as delta in unbounded variables.</li> 
</ul> One caveat of penalty adapter is that if start point or start simplex is outside of the allowed range, only the penalty function is used, and the optimizer may converge without ever entering the allowed range. 
<p> The last methods do handle simple bounds constraints directly, so the adapters are not needed with them. </p>",MultivariateFunctionMappingAdapter,class
,12.4 Direct Methods,"<h3>12.4 Direct Methods</h3> 
<p> Direct search methods only use cost function values, they don't need derivatives and don't either try to compute approximation of the derivatives. According to a 1996 paper by Margaret H. Wright (<a class=""externalLink"" href=""http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz"">Direct Search Methods: Once Scorned, Now Respectable</a>), they are used when either the computation of the derivative is impossible (noisy functions, unpredictable discontinuities) or difficult (complexity, computation cost). In the first cases, rather than an optimum, a <i>not too bad</i> point is desired. In the latter cases, an optimum is desired but cannot be reasonably found. In all cases direct search methods can be useful. </p> 
<p> Simplex-based direct search methods are based on comparison of the cost function values at the vertices of a simplex (which is a set of n+1 points in dimension n) that is updated by the algorithms steps. </p> 
<p> The instances can be built either in single-start or in multi-start mode. Multi-start is a traditional way to try to avoid being trapped in a local minimum and miss the global minimum of a function. It can also be used to verify the convergence of an algorithm. In multi-start mode, the <tt>minimizes</tt>method returns the best minimum found after all starts, and the <tt>etMinima</tt> method can be used to retrieve all minima from all starts (including the one already provided by the <tt>minimizes</tt> method). </p> 
<p> The <tt>direct</tt> package provides four solvers: </p> 
<ul> 
 <li>the classical <a href=""../apidocs/org/apache/commons/math3/optimization/direct/NelderMeadSimplex.html""> Nelder-Mead</a> method,</li> 
 <li>Virginia Torczon's <a href=""../apidocs/org/apache/commons/math3/optimization/direct/MultiDirectionalSimplex.html""> multi-directional</a> method,</li> 
 <li>Nikolaus Hansen's Covariance Matrix Adaptation Evolution Strategy (CMA-ES),</li> 
 <li>Mike Powell's <a href=""../apidocs/org/apache/commons/math3/optimization/direct/BOBYQAOptimizer.html""> BOBYQA</a> method. </li> 
</ul> 
<p> The first two simplex-based methods do not handle simple bounds constraints by themselves. However there are two adapters(<a href=""../apidocs/org/apache/commons/math3/optimization/direct/MultivariateFunctionMappingAdapter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter"" api=""MultivariateFunctionMappingAdapter"" kind=""class"">
    MultivariateFunctionMappingAdapter 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/optimization/direct/MultivariateFunctionPenaltyAdapter.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.MultivariateFunctionPenaltyAdapter"" api=""MultivariateFunctionPenaltyAdapter"" kind=""class"">
    MultivariateFunctionPenaltyAdapter 
  </clt></a>) that can be used to wrap the user function in such a way the wrapped function is unbounded and can be used with these optimizers, despite the fact the underlying function is still bounded and will be called only with feasible points that fulfill the constraints. Note however that using these adapters are only a poor man solutions to simple bounds optimization constraints. Better solutions are to use an optimizer that directly supports simple bounds. Some caveats of the mapping adapter solution are that </p> 
<ul> 
 <li>behavior near the bounds may be numerically unstable as bounds are mapped from infinite values,</li> 
 <li>start value is evaluated by the optimizer as an unbounded variable, so it must be converted from bounded to unbounded by user,</li> 
 <li>optimum result is evaluated by the optimizer as an unbounded variable, so it must be converted from unbounded to bounded by user,</li> 
 <li>convergence values are evaluated by the optimizer as unbounded variables, so there will be scales differences when converted to bounded variables,</li> 
 <li>in the case of simplex based solvers, the initial simplex should be set up as delta in unbounded variables.</li> 
</ul> One caveat of penalty adapter is that if start point or start simplex is outside of the allowed range, only the penalty function is used, and the optimizer may converge without ever entering the allowed range. 
<p> The last methods do handle simple bounds constraints directly, so the adapters are not needed with them. </p>",MultivariateFunctionPenaltyAdapter,class
,12.5 General Case,"<h3>12.5 General Case</h3> 
<p> The general package deals with non-linear vectorial optimization problems when the partial derivatives of the objective function are available. </p> 
<p> One important class of estimation problems is weighted least squares problems. They basically consist in finding the values for some parameters p<sub>k</sub> such that a cost function J = sum(w<sub>i</sub>(mes<sub>i</sub> - mod<sub>i</sub>)<sup>2</sup>) is minimized. The various (target<sub>i</sub> - model<sub>i</sub>(p<sub>k</sub>)) terms are called residuals. They represent the deviation between a set of target values target<sub>i</sub> and theoretical values computed from models model<sub>i</sub> depending on free parameters p<sub>k</sub>. The w<sub>i</sub> factors are weights. One classical use case is when the target values are experimental observations or measurements. </p> 
<p> Solving a least-squares problem is finding the free parameters p<sub>k</sub> of the theoretical models such that they are close to the target values, i.e. when the residual are small. </p> 
<p> Two optimizers are available in the general package, both devoted to least-squares problems. The first one is based on the <a href=""../apidocs/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.html""> Gauss-Newton</a> method. The second one is the <a href=""../apidocs/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.html""> Levenberg-Marquardt</a> method. </p> 
<p> In order to solve a vectorial optimization problem, the user must provide it as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
    DifferentiableMultivariateVectorFunction 
  </clt></a> interface. The object will be provided to the <tt>estimate</tt> method of the optimizer, along with the target and weight arrays, thus allowing the optimizer to compute the residuals at will. The last parameter to the <tt>estimate</tt> method is the point from which the optimizer will start its search for the optimal point. </p> 
<dl> 
 <dt>
   Quadratic Problem Example 
 </dt> 
 <dd>
   We are looking to find the best parameters [a, b, c] for the quadratic function 
  <b><tt>f(x) = a x<sup>2</sup> + b x + c</tt></b>. The data set below was generated using [a = 8, b = 10, c = 16]. A random number between zero and one was added to each y value calculated. 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>X</b></td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>Y</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">34.234064369</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">68.2681162306108</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">118.615899084602</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">184.138197238557</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">266.599877916276</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">364.147735251579</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">478.019226091914</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">608.140949270688</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">754.598868667148</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">916.128818085883</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> First we need to implement the interface <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
    <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
      DifferentiableMultivariateVectorFunction 
    </clt></a>. This requires the implementation of the method signatures: </p> 
  <ul> 
   <li><b>MultivariateMatrixFunction jacobian()</b></li> 
   <li><b>double[] value(double[] point)</b></li> 
  </ul> 
  <p> We'll tackle the implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> method first. You may wish to familiarize yourself with what a <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant""> Jacobian Matrix</a> is. In this case the Jacobian is the partial derivative of the function with respect to the parameters a, b and c. These derivatives are computed as follows: </p> 
  <ul> 
   <li>d(ax<sup>2</sup> + bx + c)/da = x<sup>2</sup></li> 
   <li>d(ax<sup>2</sup> + bx + c)/db = x</li> 
   <li>d(ax<sup>2</sup> + bx + c)/dc = 1</li> 
  </ul> 
  <p> For a quadratic which has three variables the Jacobian Matrix will have three columns, one for each variable, and the number of rows will equal the number of rows in our data set, which in this case is ten. So for example for <tt>[a = 1, b = 1, c = 1]</tt>, the Jacobian Matrix is (excluding the first column which shows the value of x): </p> 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>x</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/da</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/db</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/dc</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">16</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">25</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">36</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">49</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">64</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">81</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">100</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> for this problem looks like this (The <tt>x</tt> parameter is an ArrayList containing the independent values of the data set): </p> 
  <div class=""source""> 
   <pre>
 private double[][] jacobian(double[] variables) {
     double[][] jacobian = new double[x.size()][3];
     for (int i = 0; i &lt; jacobian.length; ++i) {
         jacobian[i][0] = x.get(i) * x.get(i);
         jacobian[i][1] = x.get(i);
         jacobian[i][2] = 1.0;
     }
     return jacobian;
 }

 public MultivariateMatrixFunction jacobian() {
     return new MultivariateMatrixFunction() {
         private static final long serialVersionUID = -8673650298627399464L;
         public double[][] value(double[] point) {
             return jacobian(point);
         }
     };
 }
</pre> 
  </div> 
  <p> Note that if for some reason the derivative of the objective function with respect to its variables is difficult to obtain, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Numerical_differentiation"">Numerical differentiation</a> can be used. </p> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction.value"" api=""value"" kind=""method"">
      double[] value(double[] point) 
    </clt></tt> method, which returns a <tt>double</tt> array containing the values the objective function returns per given independent value and the current set of variables or parameters, can be seen below: </p> 
  <div class=""source""> 
   <pre>
    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }
</pre> 
  </div> 
  <p> Below is the the class containing all the implementation details (Taken from the Apache Commons Math <b>org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizerTest</b>): </p> 
  <div class=""source""> 
   <pre>
private static class QuadraticProblem
    implements DifferentiableMultivariateVectorFunction, Serializable {

    private static final long serialVersionUID = 7072187082052755854L;
    private List&lt;Double&gt; x;
    private List&lt;Double&gt; y;

    public QuadraticProblem() {
        x = new ArrayList&lt;Double&gt;();
        y = new ArrayList&lt;Double&gt;();
    }

    public void addPoint(double x, double y) {
        this.x.add(x);
        this.y.add(y);
    }

    public double[] calculateTarget() {
    	double[] target = new double[y.size()];
    	for (int i = 0; i &lt; y.size(); i++) {
    		target[i] = y.get(i).doubleValue();
    	}
    	return target;
    }

    private double[][] jacobian(double[] variables) {
        double[][] jacobian = new double[x.size()][3];
        for (int i = 0; i &lt; jacobian.length; ++i) {
            jacobian[i][0] = x.get(i) * x.get(i);
            jacobian[i][1] = x.get(i);
            jacobian[i][2] = 1.0;
        }
        return jacobian;
    }

    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }

    public MultivariateMatrixFunction jacobian() {
        return new MultivariateMatrixFunction() {
            private static final long serialVersionUID = -8673650298627399464L;
            public double[][] value(double[] point) {
                return jacobian(point);
            }
        };
    }
}
</pre> 
  </div> 
  <p> The below code shows how to go about using the above class and a LevenbergMarquardtOptimizer instance to produce an optimal set of quadratic curve fitting parameters: </p> 
  <div class=""source""> 
   <pre>
 QuadraticProblem problem = new QuadraticProblem();

 problem.addPoint(1, 34.234064369);
 problem.addPoint(2, 68.2681162306);
 problem.addPoint(3, 118.6158990846);
 problem.addPoint(4, 184.1381972386);
 problem.addPoint(5, 266.5998779163);
 problem.addPoint(6, 364.1477352516);
 problem.addPoint(7, 478.0192260919);
 problem.addPoint(8, 608.1409492707);
 problem.addPoint(9, 754.5988686671);
 problem.addPoint(10, 916.1288180859);

 LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

 final double[] weights = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

 final double[] initialSolution = {1, 1, 1};

 PointVectorValuePair optimum = optimizer.optimize(100,
                                                   problem,
                                                   problem.calculateTarget(),
                                                   weights,
                                                   initialSolution);

 final double[] optimalValues = optimum.getPoint();

 System.out.println(&quot;A: &quot; + optimalValues[0]);
 System.out.println(&quot;B: &quot; + optimalValues[1]);
 System.out.println(&quot;C: &quot; + optimalValues[2]);

    </pre> 
  </div> 
  <p> If you run the above sample you will see the following printed by the console: </p> 
  <div> 
   <pre>
A: 7.998832172372726
B: 10.001841530162448
C: 16.324008168386605
</pre> 
  </div> 
 </dd> 
</dl> 
<p> In addition to least squares solving, the <a href=""../apidocs/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer"" api=""NonLinearConjugateGradientOptimizer"" kind=""class"">
    NonLinearConjugateGradientOptimizer 
  </clt></a> class provides a non-linear conjugate gradient algorithm to optimize <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateFunction"" api=""DifferentiableMultivariateFunction"" kind=""class"">
    DifferentiableMultivariateFunction 
  </clt></a>. Both the Fletcher-Reeves and the Polak-Ribi&egrave;re search direction update methods are supported. It is also possible to set up a preconditioner or to change the line-search algorithm of the inner loop if desired (the default one is a Brent solver). </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/direct/PowellOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.PowellOptimizer"" api=""PowellOptimizer"" kind=""class"">
    PowellOptimizer 
  </clt></a> provides an optimization method for non-differentiable functions. </p>",DifferentiableMultivariateVectorFunction,class
,12.5 General Case,"<h3>12.5 General Case</h3> 
<p> The general package deals with non-linear vectorial optimization problems when the partial derivatives of the objective function are available. </p> 
<p> One important class of estimation problems is weighted least squares problems. They basically consist in finding the values for some parameters p<sub>k</sub> such that a cost function J = sum(w<sub>i</sub>(mes<sub>i</sub> - mod<sub>i</sub>)<sup>2</sup>) is minimized. The various (target<sub>i</sub> - model<sub>i</sub>(p<sub>k</sub>)) terms are called residuals. They represent the deviation between a set of target values target<sub>i</sub> and theoretical values computed from models model<sub>i</sub> depending on free parameters p<sub>k</sub>. The w<sub>i</sub> factors are weights. One classical use case is when the target values are experimental observations or measurements. </p> 
<p> Solving a least-squares problem is finding the free parameters p<sub>k</sub> of the theoretical models such that they are close to the target values, i.e. when the residual are small. </p> 
<p> Two optimizers are available in the general package, both devoted to least-squares problems. The first one is based on the <a href=""../apidocs/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.html""> Gauss-Newton</a> method. The second one is the <a href=""../apidocs/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.html""> Levenberg-Marquardt</a> method. </p> 
<p> In order to solve a vectorial optimization problem, the user must provide it as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
    DifferentiableMultivariateVectorFunction 
  </clt></a> interface. The object will be provided to the <tt>estimate</tt> method of the optimizer, along with the target and weight arrays, thus allowing the optimizer to compute the residuals at will. The last parameter to the <tt>estimate</tt> method is the point from which the optimizer will start its search for the optimal point. </p> 
<dl> 
 <dt>
   Quadratic Problem Example 
 </dt> 
 <dd>
   We are looking to find the best parameters [a, b, c] for the quadratic function 
  <b><tt>f(x) = a x<sup>2</sup> + b x + c</tt></b>. The data set below was generated using [a = 8, b = 10, c = 16]. A random number between zero and one was added to each y value calculated. 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>X</b></td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>Y</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">34.234064369</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">68.2681162306108</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">118.615899084602</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">184.138197238557</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">266.599877916276</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">364.147735251579</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">478.019226091914</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">608.140949270688</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">754.598868667148</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">916.128818085883</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> First we need to implement the interface <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
    <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
      DifferentiableMultivariateVectorFunction 
    </clt></a>. This requires the implementation of the method signatures: </p> 
  <ul> 
   <li><b>MultivariateMatrixFunction jacobian()</b></li> 
   <li><b>double[] value(double[] point)</b></li> 
  </ul> 
  <p> We'll tackle the implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> method first. You may wish to familiarize yourself with what a <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant""> Jacobian Matrix</a> is. In this case the Jacobian is the partial derivative of the function with respect to the parameters a, b and c. These derivatives are computed as follows: </p> 
  <ul> 
   <li>d(ax<sup>2</sup> + bx + c)/da = x<sup>2</sup></li> 
   <li>d(ax<sup>2</sup> + bx + c)/db = x</li> 
   <li>d(ax<sup>2</sup> + bx + c)/dc = 1</li> 
  </ul> 
  <p> For a quadratic which has three variables the Jacobian Matrix will have three columns, one for each variable, and the number of rows will equal the number of rows in our data set, which in this case is ten. So for example for <tt>[a = 1, b = 1, c = 1]</tt>, the Jacobian Matrix is (excluding the first column which shows the value of x): </p> 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>x</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/da</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/db</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/dc</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">16</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">25</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">36</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">49</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">64</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">81</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">100</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> for this problem looks like this (The <tt>x</tt> parameter is an ArrayList containing the independent values of the data set): </p> 
  <div class=""source""> 
   <pre>
 private double[][] jacobian(double[] variables) {
     double[][] jacobian = new double[x.size()][3];
     for (int i = 0; i &lt; jacobian.length; ++i) {
         jacobian[i][0] = x.get(i) * x.get(i);
         jacobian[i][1] = x.get(i);
         jacobian[i][2] = 1.0;
     }
     return jacobian;
 }

 public MultivariateMatrixFunction jacobian() {
     return new MultivariateMatrixFunction() {
         private static final long serialVersionUID = -8673650298627399464L;
         public double[][] value(double[] point) {
             return jacobian(point);
         }
     };
 }
</pre> 
  </div> 
  <p> Note that if for some reason the derivative of the objective function with respect to its variables is difficult to obtain, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Numerical_differentiation"">Numerical differentiation</a> can be used. </p> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction.value"" api=""value"" kind=""method"">
      double[] value(double[] point) 
    </clt></tt> method, which returns a <tt>double</tt> array containing the values the objective function returns per given independent value and the current set of variables or parameters, can be seen below: </p> 
  <div class=""source""> 
   <pre>
    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }
</pre> 
  </div> 
  <p> Below is the the class containing all the implementation details (Taken from the Apache Commons Math <b>org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizerTest</b>): </p> 
  <div class=""source""> 
   <pre>
private static class QuadraticProblem
    implements DifferentiableMultivariateVectorFunction, Serializable {

    private static final long serialVersionUID = 7072187082052755854L;
    private List&lt;Double&gt; x;
    private List&lt;Double&gt; y;

    public QuadraticProblem() {
        x = new ArrayList&lt;Double&gt;();
        y = new ArrayList&lt;Double&gt;();
    }

    public void addPoint(double x, double y) {
        this.x.add(x);
        this.y.add(y);
    }

    public double[] calculateTarget() {
    	double[] target = new double[y.size()];
    	for (int i = 0; i &lt; y.size(); i++) {
    		target[i] = y.get(i).doubleValue();
    	}
    	return target;
    }

    private double[][] jacobian(double[] variables) {
        double[][] jacobian = new double[x.size()][3];
        for (int i = 0; i &lt; jacobian.length; ++i) {
            jacobian[i][0] = x.get(i) * x.get(i);
            jacobian[i][1] = x.get(i);
            jacobian[i][2] = 1.0;
        }
        return jacobian;
    }

    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }

    public MultivariateMatrixFunction jacobian() {
        return new MultivariateMatrixFunction() {
            private static final long serialVersionUID = -8673650298627399464L;
            public double[][] value(double[] point) {
                return jacobian(point);
            }
        };
    }
}
</pre> 
  </div> 
  <p> The below code shows how to go about using the above class and a LevenbergMarquardtOptimizer instance to produce an optimal set of quadratic curve fitting parameters: </p> 
  <div class=""source""> 
   <pre>
 QuadraticProblem problem = new QuadraticProblem();

 problem.addPoint(1, 34.234064369);
 problem.addPoint(2, 68.2681162306);
 problem.addPoint(3, 118.6158990846);
 problem.addPoint(4, 184.1381972386);
 problem.addPoint(5, 266.5998779163);
 problem.addPoint(6, 364.1477352516);
 problem.addPoint(7, 478.0192260919);
 problem.addPoint(8, 608.1409492707);
 problem.addPoint(9, 754.5988686671);
 problem.addPoint(10, 916.1288180859);

 LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

 final double[] weights = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

 final double[] initialSolution = {1, 1, 1};

 PointVectorValuePair optimum = optimizer.optimize(100,
                                                   problem,
                                                   problem.calculateTarget(),
                                                   weights,
                                                   initialSolution);

 final double[] optimalValues = optimum.getPoint();

 System.out.println(&quot;A: &quot; + optimalValues[0]);
 System.out.println(&quot;B: &quot; + optimalValues[1]);
 System.out.println(&quot;C: &quot; + optimalValues[2]);

    </pre> 
  </div> 
  <p> If you run the above sample you will see the following printed by the console: </p> 
  <div> 
   <pre>
A: 7.998832172372726
B: 10.001841530162448
C: 16.324008168386605
</pre> 
  </div> 
 </dd> 
</dl> 
<p> In addition to least squares solving, the <a href=""../apidocs/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer"" api=""NonLinearConjugateGradientOptimizer"" kind=""class"">
    NonLinearConjugateGradientOptimizer 
  </clt></a> class provides a non-linear conjugate gradient algorithm to optimize <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateFunction"" api=""DifferentiableMultivariateFunction"" kind=""class"">
    DifferentiableMultivariateFunction 
  </clt></a>. Both the Fletcher-Reeves and the Polak-Ribi&egrave;re search direction update methods are supported. It is also possible to set up a preconditioner or to change the line-search algorithm of the inner loop if desired (the default one is a Brent solver). </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/direct/PowellOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.PowellOptimizer"" api=""PowellOptimizer"" kind=""class"">
    PowellOptimizer 
  </clt></a> provides an optimization method for non-differentiable functions. </p>",MultivariateMatrixFunction,class
,12.5 General Case,"<h3>12.5 General Case</h3> 
<p> The general package deals with non-linear vectorial optimization problems when the partial derivatives of the objective function are available. </p> 
<p> One important class of estimation problems is weighted least squares problems. They basically consist in finding the values for some parameters p<sub>k</sub> such that a cost function J = sum(w<sub>i</sub>(mes<sub>i</sub> - mod<sub>i</sub>)<sup>2</sup>) is minimized. The various (target<sub>i</sub> - model<sub>i</sub>(p<sub>k</sub>)) terms are called residuals. They represent the deviation between a set of target values target<sub>i</sub> and theoretical values computed from models model<sub>i</sub> depending on free parameters p<sub>k</sub>. The w<sub>i</sub> factors are weights. One classical use case is when the target values are experimental observations or measurements. </p> 
<p> Solving a least-squares problem is finding the free parameters p<sub>k</sub> of the theoretical models such that they are close to the target values, i.e. when the residual are small. </p> 
<p> Two optimizers are available in the general package, both devoted to least-squares problems. The first one is based on the <a href=""../apidocs/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.html""> Gauss-Newton</a> method. The second one is the <a href=""../apidocs/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.html""> Levenberg-Marquardt</a> method. </p> 
<p> In order to solve a vectorial optimization problem, the user must provide it as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
    DifferentiableMultivariateVectorFunction 
  </clt></a> interface. The object will be provided to the <tt>estimate</tt> method of the optimizer, along with the target and weight arrays, thus allowing the optimizer to compute the residuals at will. The last parameter to the <tt>estimate</tt> method is the point from which the optimizer will start its search for the optimal point. </p> 
<dl> 
 <dt>
   Quadratic Problem Example 
 </dt> 
 <dd>
   We are looking to find the best parameters [a, b, c] for the quadratic function 
  <b><tt>f(x) = a x<sup>2</sup> + b x + c</tt></b>. The data set below was generated using [a = 8, b = 10, c = 16]. A random number between zero and one was added to each y value calculated. 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>X</b></td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>Y</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">34.234064369</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">68.2681162306108</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">118.615899084602</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">184.138197238557</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">266.599877916276</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">364.147735251579</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">478.019226091914</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">608.140949270688</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">754.598868667148</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">916.128818085883</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> First we need to implement the interface <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
    <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
      DifferentiableMultivariateVectorFunction 
    </clt></a>. This requires the implementation of the method signatures: </p> 
  <ul> 
   <li><b>MultivariateMatrixFunction jacobian()</b></li> 
   <li><b>double[] value(double[] point)</b></li> 
  </ul> 
  <p> We'll tackle the implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> method first. You may wish to familiarize yourself with what a <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant""> Jacobian Matrix</a> is. In this case the Jacobian is the partial derivative of the function with respect to the parameters a, b and c. These derivatives are computed as follows: </p> 
  <ul> 
   <li>d(ax<sup>2</sup> + bx + c)/da = x<sup>2</sup></li> 
   <li>d(ax<sup>2</sup> + bx + c)/db = x</li> 
   <li>d(ax<sup>2</sup> + bx + c)/dc = 1</li> 
  </ul> 
  <p> For a quadratic which has three variables the Jacobian Matrix will have three columns, one for each variable, and the number of rows will equal the number of rows in our data set, which in this case is ten. So for example for <tt>[a = 1, b = 1, c = 1]</tt>, the Jacobian Matrix is (excluding the first column which shows the value of x): </p> 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>x</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/da</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/db</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/dc</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">16</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">25</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">36</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">49</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">64</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">81</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">100</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> for this problem looks like this (The <tt>x</tt> parameter is an ArrayList containing the independent values of the data set): </p> 
  <div class=""source""> 
   <pre>
 private double[][] jacobian(double[] variables) {
     double[][] jacobian = new double[x.size()][3];
     for (int i = 0; i &lt; jacobian.length; ++i) {
         jacobian[i][0] = x.get(i) * x.get(i);
         jacobian[i][1] = x.get(i);
         jacobian[i][2] = 1.0;
     }
     return jacobian;
 }

 public MultivariateMatrixFunction jacobian() {
     return new MultivariateMatrixFunction() {
         private static final long serialVersionUID = -8673650298627399464L;
         public double[][] value(double[] point) {
             return jacobian(point);
         }
     };
 }
</pre> 
  </div> 
  <p> Note that if for some reason the derivative of the objective function with respect to its variables is difficult to obtain, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Numerical_differentiation"">Numerical differentiation</a> can be used. </p> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction.value"" api=""value"" kind=""method"">
      double[] value(double[] point) 
    </clt></tt> method, which returns a <tt>double</tt> array containing the values the objective function returns per given independent value and the current set of variables or parameters, can be seen below: </p> 
  <div class=""source""> 
   <pre>
    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }
</pre> 
  </div> 
  <p> Below is the the class containing all the implementation details (Taken from the Apache Commons Math <b>org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizerTest</b>): </p> 
  <div class=""source""> 
   <pre>
private static class QuadraticProblem
    implements DifferentiableMultivariateVectorFunction, Serializable {

    private static final long serialVersionUID = 7072187082052755854L;
    private List&lt;Double&gt; x;
    private List&lt;Double&gt; y;

    public QuadraticProblem() {
        x = new ArrayList&lt;Double&gt;();
        y = new ArrayList&lt;Double&gt;();
    }

    public void addPoint(double x, double y) {
        this.x.add(x);
        this.y.add(y);
    }

    public double[] calculateTarget() {
    	double[] target = new double[y.size()];
    	for (int i = 0; i &lt; y.size(); i++) {
    		target[i] = y.get(i).doubleValue();
    	}
    	return target;
    }

    private double[][] jacobian(double[] variables) {
        double[][] jacobian = new double[x.size()][3];
        for (int i = 0; i &lt; jacobian.length; ++i) {
            jacobian[i][0] = x.get(i) * x.get(i);
            jacobian[i][1] = x.get(i);
            jacobian[i][2] = 1.0;
        }
        return jacobian;
    }

    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }

    public MultivariateMatrixFunction jacobian() {
        return new MultivariateMatrixFunction() {
            private static final long serialVersionUID = -8673650298627399464L;
            public double[][] value(double[] point) {
                return jacobian(point);
            }
        };
    }
}
</pre> 
  </div> 
  <p> The below code shows how to go about using the above class and a LevenbergMarquardtOptimizer instance to produce an optimal set of quadratic curve fitting parameters: </p> 
  <div class=""source""> 
   <pre>
 QuadraticProblem problem = new QuadraticProblem();

 problem.addPoint(1, 34.234064369);
 problem.addPoint(2, 68.2681162306);
 problem.addPoint(3, 118.6158990846);
 problem.addPoint(4, 184.1381972386);
 problem.addPoint(5, 266.5998779163);
 problem.addPoint(6, 364.1477352516);
 problem.addPoint(7, 478.0192260919);
 problem.addPoint(8, 608.1409492707);
 problem.addPoint(9, 754.5988686671);
 problem.addPoint(10, 916.1288180859);

 LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

 final double[] weights = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

 final double[] initialSolution = {1, 1, 1};

 PointVectorValuePair optimum = optimizer.optimize(100,
                                                   problem,
                                                   problem.calculateTarget(),
                                                   weights,
                                                   initialSolution);

 final double[] optimalValues = optimum.getPoint();

 System.out.println(&quot;A: &quot; + optimalValues[0]);
 System.out.println(&quot;B: &quot; + optimalValues[1]);
 System.out.println(&quot;C: &quot; + optimalValues[2]);

    </pre> 
  </div> 
  <p> If you run the above sample you will see the following printed by the console: </p> 
  <div> 
   <pre>
A: 7.998832172372726
B: 10.001841530162448
C: 16.324008168386605
</pre> 
  </div> 
 </dd> 
</dl> 
<p> In addition to least squares solving, the <a href=""../apidocs/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer"" api=""NonLinearConjugateGradientOptimizer"" kind=""class"">
    NonLinearConjugateGradientOptimizer 
  </clt></a> class provides a non-linear conjugate gradient algorithm to optimize <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateFunction"" api=""DifferentiableMultivariateFunction"" kind=""class"">
    DifferentiableMultivariateFunction 
  </clt></a>. Both the Fletcher-Reeves and the Polak-Ribi&egrave;re search direction update methods are supported. It is also possible to set up a preconditioner or to change the line-search algorithm of the inner loop if desired (the default one is a Brent solver). </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/direct/PowellOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.PowellOptimizer"" api=""PowellOptimizer"" kind=""class"">
    PowellOptimizer 
  </clt></a> provides an optimization method for non-differentiable functions. </p>",value,method
,12.5 General Case,"<h3>12.5 General Case</h3> 
<p> The general package deals with non-linear vectorial optimization problems when the partial derivatives of the objective function are available. </p> 
<p> One important class of estimation problems is weighted least squares problems. They basically consist in finding the values for some parameters p<sub>k</sub> such that a cost function J = sum(w<sub>i</sub>(mes<sub>i</sub> - mod<sub>i</sub>)<sup>2</sup>) is minimized. The various (target<sub>i</sub> - model<sub>i</sub>(p<sub>k</sub>)) terms are called residuals. They represent the deviation between a set of target values target<sub>i</sub> and theoretical values computed from models model<sub>i</sub> depending on free parameters p<sub>k</sub>. The w<sub>i</sub> factors are weights. One classical use case is when the target values are experimental observations or measurements. </p> 
<p> Solving a least-squares problem is finding the free parameters p<sub>k</sub> of the theoretical models such that they are close to the target values, i.e. when the residual are small. </p> 
<p> Two optimizers are available in the general package, both devoted to least-squares problems. The first one is based on the <a href=""../apidocs/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.html""> Gauss-Newton</a> method. The second one is the <a href=""../apidocs/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.html""> Levenberg-Marquardt</a> method. </p> 
<p> In order to solve a vectorial optimization problem, the user must provide it as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
    DifferentiableMultivariateVectorFunction 
  </clt></a> interface. The object will be provided to the <tt>estimate</tt> method of the optimizer, along with the target and weight arrays, thus allowing the optimizer to compute the residuals at will. The last parameter to the <tt>estimate</tt> method is the point from which the optimizer will start its search for the optimal point. </p> 
<dl> 
 <dt>
   Quadratic Problem Example 
 </dt> 
 <dd>
   We are looking to find the best parameters [a, b, c] for the quadratic function 
  <b><tt>f(x) = a x<sup>2</sup> + b x + c</tt></b>. The data set below was generated using [a = 8, b = 10, c = 16]. A random number between zero and one was added to each y value calculated. 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>X</b></td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>Y</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">34.234064369</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">68.2681162306108</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">118.615899084602</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">184.138197238557</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">266.599877916276</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">364.147735251579</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">478.019226091914</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">608.140949270688</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">754.598868667148</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">916.128818085883</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> First we need to implement the interface <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
    <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
      DifferentiableMultivariateVectorFunction 
    </clt></a>. This requires the implementation of the method signatures: </p> 
  <ul> 
   <li><b>MultivariateMatrixFunction jacobian()</b></li> 
   <li><b>double[] value(double[] point)</b></li> 
  </ul> 
  <p> We'll tackle the implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> method first. You may wish to familiarize yourself with what a <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant""> Jacobian Matrix</a> is. In this case the Jacobian is the partial derivative of the function with respect to the parameters a, b and c. These derivatives are computed as follows: </p> 
  <ul> 
   <li>d(ax<sup>2</sup> + bx + c)/da = x<sup>2</sup></li> 
   <li>d(ax<sup>2</sup> + bx + c)/db = x</li> 
   <li>d(ax<sup>2</sup> + bx + c)/dc = 1</li> 
  </ul> 
  <p> For a quadratic which has three variables the Jacobian Matrix will have three columns, one for each variable, and the number of rows will equal the number of rows in our data set, which in this case is ten. So for example for <tt>[a = 1, b = 1, c = 1]</tt>, the Jacobian Matrix is (excluding the first column which shows the value of x): </p> 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>x</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/da</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/db</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/dc</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">16</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">25</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">36</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">49</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">64</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">81</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">100</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> for this problem looks like this (The <tt>x</tt> parameter is an ArrayList containing the independent values of the data set): </p> 
  <div class=""source""> 
   <pre>
 private double[][] jacobian(double[] variables) {
     double[][] jacobian = new double[x.size()][3];
     for (int i = 0; i &lt; jacobian.length; ++i) {
         jacobian[i][0] = x.get(i) * x.get(i);
         jacobian[i][1] = x.get(i);
         jacobian[i][2] = 1.0;
     }
     return jacobian;
 }

 public MultivariateMatrixFunction jacobian() {
     return new MultivariateMatrixFunction() {
         private static final long serialVersionUID = -8673650298627399464L;
         public double[][] value(double[] point) {
             return jacobian(point);
         }
     };
 }
</pre> 
  </div> 
  <p> Note that if for some reason the derivative of the objective function with respect to its variables is difficult to obtain, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Numerical_differentiation"">Numerical differentiation</a> can be used. </p> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction.value"" api=""value"" kind=""method"">
      double[] value(double[] point) 
    </clt></tt> method, which returns a <tt>double</tt> array containing the values the objective function returns per given independent value and the current set of variables or parameters, can be seen below: </p> 
  <div class=""source""> 
   <pre>
    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }
</pre> 
  </div> 
  <p> Below is the the class containing all the implementation details (Taken from the Apache Commons Math <b>org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizerTest</b>): </p> 
  <div class=""source""> 
   <pre>
private static class QuadraticProblem
    implements DifferentiableMultivariateVectorFunction, Serializable {

    private static final long serialVersionUID = 7072187082052755854L;
    private List&lt;Double&gt; x;
    private List&lt;Double&gt; y;

    public QuadraticProblem() {
        x = new ArrayList&lt;Double&gt;();
        y = new ArrayList&lt;Double&gt;();
    }

    public void addPoint(double x, double y) {
        this.x.add(x);
        this.y.add(y);
    }

    public double[] calculateTarget() {
    	double[] target = new double[y.size()];
    	for (int i = 0; i &lt; y.size(); i++) {
    		target[i] = y.get(i).doubleValue();
    	}
    	return target;
    }

    private double[][] jacobian(double[] variables) {
        double[][] jacobian = new double[x.size()][3];
        for (int i = 0; i &lt; jacobian.length; ++i) {
            jacobian[i][0] = x.get(i) * x.get(i);
            jacobian[i][1] = x.get(i);
            jacobian[i][2] = 1.0;
        }
        return jacobian;
    }

    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }

    public MultivariateMatrixFunction jacobian() {
        return new MultivariateMatrixFunction() {
            private static final long serialVersionUID = -8673650298627399464L;
            public double[][] value(double[] point) {
                return jacobian(point);
            }
        };
    }
}
</pre> 
  </div> 
  <p> The below code shows how to go about using the above class and a LevenbergMarquardtOptimizer instance to produce an optimal set of quadratic curve fitting parameters: </p> 
  <div class=""source""> 
   <pre>
 QuadraticProblem problem = new QuadraticProblem();

 problem.addPoint(1, 34.234064369);
 problem.addPoint(2, 68.2681162306);
 problem.addPoint(3, 118.6158990846);
 problem.addPoint(4, 184.1381972386);
 problem.addPoint(5, 266.5998779163);
 problem.addPoint(6, 364.1477352516);
 problem.addPoint(7, 478.0192260919);
 problem.addPoint(8, 608.1409492707);
 problem.addPoint(9, 754.5988686671);
 problem.addPoint(10, 916.1288180859);

 LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

 final double[] weights = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

 final double[] initialSolution = {1, 1, 1};

 PointVectorValuePair optimum = optimizer.optimize(100,
                                                   problem,
                                                   problem.calculateTarget(),
                                                   weights,
                                                   initialSolution);

 final double[] optimalValues = optimum.getPoint();

 System.out.println(&quot;A: &quot; + optimalValues[0]);
 System.out.println(&quot;B: &quot; + optimalValues[1]);
 System.out.println(&quot;C: &quot; + optimalValues[2]);

    </pre> 
  </div> 
  <p> If you run the above sample you will see the following printed by the console: </p> 
  <div> 
   <pre>
A: 7.998832172372726
B: 10.001841530162448
C: 16.324008168386605
</pre> 
  </div> 
 </dd> 
</dl> 
<p> In addition to least squares solving, the <a href=""../apidocs/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer"" api=""NonLinearConjugateGradientOptimizer"" kind=""class"">
    NonLinearConjugateGradientOptimizer 
  </clt></a> class provides a non-linear conjugate gradient algorithm to optimize <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateFunction"" api=""DifferentiableMultivariateFunction"" kind=""class"">
    DifferentiableMultivariateFunction 
  </clt></a>. Both the Fletcher-Reeves and the Polak-Ribi&egrave;re search direction update methods are supported. It is also possible to set up a preconditioner or to change the line-search algorithm of the inner loop if desired (the default one is a Brent solver). </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/direct/PowellOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.PowellOptimizer"" api=""PowellOptimizer"" kind=""class"">
    PowellOptimizer 
  </clt></a> provides an optimization method for non-differentiable functions. </p>",NonLinearConjugateGradientOptimizer,class
,12.5 General Case,"<h3>12.5 General Case</h3> 
<p> The general package deals with non-linear vectorial optimization problems when the partial derivatives of the objective function are available. </p> 
<p> One important class of estimation problems is weighted least squares problems. They basically consist in finding the values for some parameters p<sub>k</sub> such that a cost function J = sum(w<sub>i</sub>(mes<sub>i</sub> - mod<sub>i</sub>)<sup>2</sup>) is minimized. The various (target<sub>i</sub> - model<sub>i</sub>(p<sub>k</sub>)) terms are called residuals. They represent the deviation between a set of target values target<sub>i</sub> and theoretical values computed from models model<sub>i</sub> depending on free parameters p<sub>k</sub>. The w<sub>i</sub> factors are weights. One classical use case is when the target values are experimental observations or measurements. </p> 
<p> Solving a least-squares problem is finding the free parameters p<sub>k</sub> of the theoretical models such that they are close to the target values, i.e. when the residual are small. </p> 
<p> Two optimizers are available in the general package, both devoted to least-squares problems. The first one is based on the <a href=""../apidocs/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.html""> Gauss-Newton</a> method. The second one is the <a href=""../apidocs/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.html""> Levenberg-Marquardt</a> method. </p> 
<p> In order to solve a vectorial optimization problem, the user must provide it as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
    DifferentiableMultivariateVectorFunction 
  </clt></a> interface. The object will be provided to the <tt>estimate</tt> method of the optimizer, along with the target and weight arrays, thus allowing the optimizer to compute the residuals at will. The last parameter to the <tt>estimate</tt> method is the point from which the optimizer will start its search for the optimal point. </p> 
<dl> 
 <dt>
   Quadratic Problem Example 
 </dt> 
 <dd>
   We are looking to find the best parameters [a, b, c] for the quadratic function 
  <b><tt>f(x) = a x<sup>2</sup> + b x + c</tt></b>. The data set below was generated using [a = 8, b = 10, c = 16]. A random number between zero and one was added to each y value calculated. 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>X</b></td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>Y</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">34.234064369</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">68.2681162306108</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">118.615899084602</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">184.138197238557</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">266.599877916276</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">364.147735251579</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">478.019226091914</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">608.140949270688</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">754.598868667148</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">916.128818085883</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> First we need to implement the interface <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
    <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
      DifferentiableMultivariateVectorFunction 
    </clt></a>. This requires the implementation of the method signatures: </p> 
  <ul> 
   <li><b>MultivariateMatrixFunction jacobian()</b></li> 
   <li><b>double[] value(double[] point)</b></li> 
  </ul> 
  <p> We'll tackle the implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> method first. You may wish to familiarize yourself with what a <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant""> Jacobian Matrix</a> is. In this case the Jacobian is the partial derivative of the function with respect to the parameters a, b and c. These derivatives are computed as follows: </p> 
  <ul> 
   <li>d(ax<sup>2</sup> + bx + c)/da = x<sup>2</sup></li> 
   <li>d(ax<sup>2</sup> + bx + c)/db = x</li> 
   <li>d(ax<sup>2</sup> + bx + c)/dc = 1</li> 
  </ul> 
  <p> For a quadratic which has three variables the Jacobian Matrix will have three columns, one for each variable, and the number of rows will equal the number of rows in our data set, which in this case is ten. So for example for <tt>[a = 1, b = 1, c = 1]</tt>, the Jacobian Matrix is (excluding the first column which shows the value of x): </p> 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>x</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/da</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/db</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/dc</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">16</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">25</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">36</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">49</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">64</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">81</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">100</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> for this problem looks like this (The <tt>x</tt> parameter is an ArrayList containing the independent values of the data set): </p> 
  <div class=""source""> 
   <pre>
 private double[][] jacobian(double[] variables) {
     double[][] jacobian = new double[x.size()][3];
     for (int i = 0; i &lt; jacobian.length; ++i) {
         jacobian[i][0] = x.get(i) * x.get(i);
         jacobian[i][1] = x.get(i);
         jacobian[i][2] = 1.0;
     }
     return jacobian;
 }

 public MultivariateMatrixFunction jacobian() {
     return new MultivariateMatrixFunction() {
         private static final long serialVersionUID = -8673650298627399464L;
         public double[][] value(double[] point) {
             return jacobian(point);
         }
     };
 }
</pre> 
  </div> 
  <p> Note that if for some reason the derivative of the objective function with respect to its variables is difficult to obtain, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Numerical_differentiation"">Numerical differentiation</a> can be used. </p> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction.value"" api=""value"" kind=""method"">
      double[] value(double[] point) 
    </clt></tt> method, which returns a <tt>double</tt> array containing the values the objective function returns per given independent value and the current set of variables or parameters, can be seen below: </p> 
  <div class=""source""> 
   <pre>
    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }
</pre> 
  </div> 
  <p> Below is the the class containing all the implementation details (Taken from the Apache Commons Math <b>org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizerTest</b>): </p> 
  <div class=""source""> 
   <pre>
private static class QuadraticProblem
    implements DifferentiableMultivariateVectorFunction, Serializable {

    private static final long serialVersionUID = 7072187082052755854L;
    private List&lt;Double&gt; x;
    private List&lt;Double&gt; y;

    public QuadraticProblem() {
        x = new ArrayList&lt;Double&gt;();
        y = new ArrayList&lt;Double&gt;();
    }

    public void addPoint(double x, double y) {
        this.x.add(x);
        this.y.add(y);
    }

    public double[] calculateTarget() {
    	double[] target = new double[y.size()];
    	for (int i = 0; i &lt; y.size(); i++) {
    		target[i] = y.get(i).doubleValue();
    	}
    	return target;
    }

    private double[][] jacobian(double[] variables) {
        double[][] jacobian = new double[x.size()][3];
        for (int i = 0; i &lt; jacobian.length; ++i) {
            jacobian[i][0] = x.get(i) * x.get(i);
            jacobian[i][1] = x.get(i);
            jacobian[i][2] = 1.0;
        }
        return jacobian;
    }

    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }

    public MultivariateMatrixFunction jacobian() {
        return new MultivariateMatrixFunction() {
            private static final long serialVersionUID = -8673650298627399464L;
            public double[][] value(double[] point) {
                return jacobian(point);
            }
        };
    }
}
</pre> 
  </div> 
  <p> The below code shows how to go about using the above class and a LevenbergMarquardtOptimizer instance to produce an optimal set of quadratic curve fitting parameters: </p> 
  <div class=""source""> 
   <pre>
 QuadraticProblem problem = new QuadraticProblem();

 problem.addPoint(1, 34.234064369);
 problem.addPoint(2, 68.2681162306);
 problem.addPoint(3, 118.6158990846);
 problem.addPoint(4, 184.1381972386);
 problem.addPoint(5, 266.5998779163);
 problem.addPoint(6, 364.1477352516);
 problem.addPoint(7, 478.0192260919);
 problem.addPoint(8, 608.1409492707);
 problem.addPoint(9, 754.5988686671);
 problem.addPoint(10, 916.1288180859);

 LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

 final double[] weights = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

 final double[] initialSolution = {1, 1, 1};

 PointVectorValuePair optimum = optimizer.optimize(100,
                                                   problem,
                                                   problem.calculateTarget(),
                                                   weights,
                                                   initialSolution);

 final double[] optimalValues = optimum.getPoint();

 System.out.println(&quot;A: &quot; + optimalValues[0]);
 System.out.println(&quot;B: &quot; + optimalValues[1]);
 System.out.println(&quot;C: &quot; + optimalValues[2]);

    </pre> 
  </div> 
  <p> If you run the above sample you will see the following printed by the console: </p> 
  <div> 
   <pre>
A: 7.998832172372726
B: 10.001841530162448
C: 16.324008168386605
</pre> 
  </div> 
 </dd> 
</dl> 
<p> In addition to least squares solving, the <a href=""../apidocs/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer"" api=""NonLinearConjugateGradientOptimizer"" kind=""class"">
    NonLinearConjugateGradientOptimizer 
  </clt></a> class provides a non-linear conjugate gradient algorithm to optimize <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateFunction"" api=""DifferentiableMultivariateFunction"" kind=""class"">
    DifferentiableMultivariateFunction 
  </clt></a>. Both the Fletcher-Reeves and the Polak-Ribi&egrave;re search direction update methods are supported. It is also possible to set up a preconditioner or to change the line-search algorithm of the inner loop if desired (the default one is a Brent solver). </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/direct/PowellOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.PowellOptimizer"" api=""PowellOptimizer"" kind=""class"">
    PowellOptimizer 
  </clt></a> provides an optimization method for non-differentiable functions. </p>",DifferentiableMultivariateFunction,class
,12.5 General Case,"<h3>12.5 General Case</h3> 
<p> The general package deals with non-linear vectorial optimization problems when the partial derivatives of the objective function are available. </p> 
<p> One important class of estimation problems is weighted least squares problems. They basically consist in finding the values for some parameters p<sub>k</sub> such that a cost function J = sum(w<sub>i</sub>(mes<sub>i</sub> - mod<sub>i</sub>)<sup>2</sup>) is minimized. The various (target<sub>i</sub> - model<sub>i</sub>(p<sub>k</sub>)) terms are called residuals. They represent the deviation between a set of target values target<sub>i</sub> and theoretical values computed from models model<sub>i</sub> depending on free parameters p<sub>k</sub>. The w<sub>i</sub> factors are weights. One classical use case is when the target values are experimental observations or measurements. </p> 
<p> Solving a least-squares problem is finding the free parameters p<sub>k</sub> of the theoretical models such that they are close to the target values, i.e. when the residual are small. </p> 
<p> Two optimizers are available in the general package, both devoted to least-squares problems. The first one is based on the <a href=""../apidocs/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.html""> Gauss-Newton</a> method. The second one is the <a href=""../apidocs/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.html""> Levenberg-Marquardt</a> method. </p> 
<p> In order to solve a vectorial optimization problem, the user must provide it as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
    DifferentiableMultivariateVectorFunction 
  </clt></a> interface. The object will be provided to the <tt>estimate</tt> method of the optimizer, along with the target and weight arrays, thus allowing the optimizer to compute the residuals at will. The last parameter to the <tt>estimate</tt> method is the point from which the optimizer will start its search for the optimal point. </p> 
<dl> 
 <dt>
   Quadratic Problem Example 
 </dt> 
 <dd>
   We are looking to find the best parameters [a, b, c] for the quadratic function 
  <b><tt>f(x) = a x<sup>2</sup> + b x + c</tt></b>. The data set below was generated using [a = 8, b = 10, c = 16]. A random number between zero and one was added to each y value calculated. 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>X</b></td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;""><b>Y</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">34.234064369</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">68.2681162306108</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">118.615899084602</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">184.138197238557</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">266.599877916276</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">364.147735251579</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">478.019226091914</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">608.140949270688</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">754.598868667148</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">916.128818085883</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> First we need to implement the interface <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateVectorFunction.html""> 
    <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"" api=""DifferentiableMultivariateVectorFunction"" kind=""class"">
      DifferentiableMultivariateVectorFunction 
    </clt></a>. This requires the implementation of the method signatures: </p> 
  <ul> 
   <li><b>MultivariateMatrixFunction jacobian()</b></li> 
   <li><b>double[] value(double[] point)</b></li> 
  </ul> 
  <p> We'll tackle the implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> method first. You may wish to familiarize yourself with what a <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant""> Jacobian Matrix</a> is. In this case the Jacobian is the partial derivative of the function with respect to the parameters a, b and c. These derivatives are computed as follows: </p> 
  <ul> 
   <li>d(ax<sup>2</sup> + bx + c)/da = x<sup>2</sup></li> 
   <li>d(ax<sup>2</sup> + bx + c)/db = x</li> 
   <li>d(ax<sup>2</sup> + bx + c)/dc = 1</li> 
  </ul> 
  <p> For a quadratic which has three variables the Jacobian Matrix will have three columns, one for each variable, and the number of rows will equal the number of rows in our data set, which in this case is ten. So for example for <tt>[a = 1, b = 1, c = 1]</tt>, the Jacobian Matrix is (excluding the first column which shows the value of x): </p> 
  <table border=""0"" class=""bodyTable"" cellspacing=""0"" cellpadding=""3""> 
   <tbody> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>x</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/da</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/db</b></td> 
     <td valign=""bottom"" align=""left"" style="" font-size:10pt;""><b>d(ax<sup>2</sup> + bx + c)/dc</b></td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">2</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">3</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">16</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">4</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">25</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">5</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">36</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">6</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">49</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">7</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">64</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">8</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""b""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">81</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">9</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
    <tr class=""a""> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">100</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">10</td> 
     <td valign=""bottom"" align=""center"" style="" font-size:10pt;"">1</td> 
    </tr> 
   </tbody> 
  </table> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction"" api=""MultivariateMatrixFunction"" kind=""class"">
      MultivariateMatrixFunction jacobian() 
    </clt></tt> for this problem looks like this (The <tt>x</tt> parameter is an ArrayList containing the independent values of the data set): </p> 
  <div class=""source""> 
   <pre>
 private double[][] jacobian(double[] variables) {
     double[][] jacobian = new double[x.size()][3];
     for (int i = 0; i &lt; jacobian.length; ++i) {
         jacobian[i][0] = x.get(i) * x.get(i);
         jacobian[i][1] = x.get(i);
         jacobian[i][2] = 1.0;
     }
     return jacobian;
 }

 public MultivariateMatrixFunction jacobian() {
     return new MultivariateMatrixFunction() {
         private static final long serialVersionUID = -8673650298627399464L;
         public double[][] value(double[] point) {
             return jacobian(point);
         }
     };
 }
</pre> 
  </div> 
  <p> Note that if for some reason the derivative of the objective function with respect to its variables is difficult to obtain, <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Numerical_differentiation"">Numerical differentiation</a> can be used. </p> 
  <p> The implementation of the <tt> 
    <clt fqn=""org.apache.commons.math3.analysis.MultivariateMatrixFunction.value"" api=""value"" kind=""method"">
      double[] value(double[] point) 
    </clt></tt> method, which returns a <tt>double</tt> array containing the values the objective function returns per given independent value and the current set of variables or parameters, can be seen below: </p> 
  <div class=""source""> 
   <pre>
    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }
</pre> 
  </div> 
  <p> Below is the the class containing all the implementation details (Taken from the Apache Commons Math <b>org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizerTest</b>): </p> 
  <div class=""source""> 
   <pre>
private static class QuadraticProblem
    implements DifferentiableMultivariateVectorFunction, Serializable {

    private static final long serialVersionUID = 7072187082052755854L;
    private List&lt;Double&gt; x;
    private List&lt;Double&gt; y;

    public QuadraticProblem() {
        x = new ArrayList&lt;Double&gt;();
        y = new ArrayList&lt;Double&gt;();
    }

    public void addPoint(double x, double y) {
        this.x.add(x);
        this.y.add(y);
    }

    public double[] calculateTarget() {
    	double[] target = new double[y.size()];
    	for (int i = 0; i &lt; y.size(); i++) {
    		target[i] = y.get(i).doubleValue();
    	}
    	return target;
    }

    private double[][] jacobian(double[] variables) {
        double[][] jacobian = new double[x.size()][3];
        for (int i = 0; i &lt; jacobian.length; ++i) {
            jacobian[i][0] = x.get(i) * x.get(i);
            jacobian[i][1] = x.get(i);
            jacobian[i][2] = 1.0;
        }
        return jacobian;
    }

    public double[] value(double[] variables) {
        double[] values = new double[x.size()];
        for (int i = 0; i &lt; values.length; ++i) {
            values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];
        }
        return values;
    }

    public MultivariateMatrixFunction jacobian() {
        return new MultivariateMatrixFunction() {
            private static final long serialVersionUID = -8673650298627399464L;
            public double[][] value(double[] point) {
                return jacobian(point);
            }
        };
    }
}
</pre> 
  </div> 
  <p> The below code shows how to go about using the above class and a LevenbergMarquardtOptimizer instance to produce an optimal set of quadratic curve fitting parameters: </p> 
  <div class=""source""> 
   <pre>
 QuadraticProblem problem = new QuadraticProblem();

 problem.addPoint(1, 34.234064369);
 problem.addPoint(2, 68.2681162306);
 problem.addPoint(3, 118.6158990846);
 problem.addPoint(4, 184.1381972386);
 problem.addPoint(5, 266.5998779163);
 problem.addPoint(6, 364.1477352516);
 problem.addPoint(7, 478.0192260919);
 problem.addPoint(8, 608.1409492707);
 problem.addPoint(9, 754.5988686671);
 problem.addPoint(10, 916.1288180859);

 LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();

 final double[] weights = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

 final double[] initialSolution = {1, 1, 1};

 PointVectorValuePair optimum = optimizer.optimize(100,
                                                   problem,
                                                   problem.calculateTarget(),
                                                   weights,
                                                   initialSolution);

 final double[] optimalValues = optimum.getPoint();

 System.out.println(&quot;A: &quot; + optimalValues[0]);
 System.out.println(&quot;B: &quot; + optimalValues[1]);
 System.out.println(&quot;C: &quot; + optimalValues[2]);

    </pre> 
  </div> 
  <p> If you run the above sample you will see the following printed by the console: </p> 
  <div> 
   <pre>
A: 7.998832172372726
B: 10.001841530162448
C: 16.324008168386605
</pre> 
  </div> 
 </dd> 
</dl> 
<p> In addition to least squares solving, the <a href=""../apidocs/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer"" api=""NonLinearConjugateGradientOptimizer"" kind=""class"">
    NonLinearConjugateGradientOptimizer 
  </clt></a> class provides a non-linear conjugate gradient algorithm to optimize <a href=""../apidocs/org/apache/commons/math3/analysis/DifferentiableMultivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.DifferentiableMultivariateFunction"" api=""DifferentiableMultivariateFunction"" kind=""class"">
    DifferentiableMultivariateFunction 
  </clt></a>. Both the Fletcher-Reeves and the Polak-Ribi&egrave;re search direction update methods are supported. It is also possible to set up a preconditioner or to change the line-search algorithm of the inner loop if desired (the default one is a Brent solver). </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/direct/PowellOptimizer.html""> 
  <clt fqn=""org.apache.commons.math3.optimization.direct.PowellOptimizer"" api=""PowellOptimizer"" kind=""class"">
    PowellOptimizer 
  </clt></a> provides an optimization method for non-differentiable functions. </p>",PowellOptimizer,class
,12.6 Curve Fitting,"<h3>12.6 Curve Fitting</h3> 
<p> The fitting package deals with curve fitting for univariate real functions. When a univariate real function y = f(x) does depend on some unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>, curve fitting can be used to find these parameters. It does this by <i>fitting</i> the curve so it remains very close to a set of observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>, y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting is done by finding the parameters values that minimizes the objective function sum(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is really a least squares problem. </p> 
<p> For all provided curve fitters, the operating principle is the same. Users must first create an instance of the fitter, then add the observed points and once the complete sample of observed points has been added they must call the <tt> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter.fit"" api=""fit"" kind=""unknown"">
    fit 
  </clt></tt> method which will compute the parameters that best fit the sample. A weight is associated with each observed point, this allows to take into account uncertainty on some points when they come from loosy measurements for example. If no such information exist and all points should be treated the same, it is safe to put 1.0 as the weight for all points. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/CurveFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter"" api=""CurveFitter"" kind=""class"">
    CurveFitter 
  </clt></a> class provides curve fitting for general curves. Users must provide their own implementation of the curve template as a class implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/ParametricUnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.ParametricUnivariateFunction"" api=""ParametricUnivariateFunction"" kind=""class"">
    ParametricUnivariateFunction 
  </clt></a> interface and they must provide the initial guess of the parameters. </p> 
<p> The following example shows how to fit data with a polynomial function. </p> 
<div class=""source""> 
 <pre>final CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());
fitter.addObservedPoint(-1.00, 2.021170021833143);
fitter.addObservedPoint(-0.99, 2.221135431136975);
fitter.addObservedPoint(-0.98, 2.09985277659314);
fitter.addObservedPoint(-0.97, 2.0211192647627025);
// ... Lots of lines omitted ...
fitter.addObservedPoint( 0.99, -2.4345814727089854);

// The degree of the polynomial is deduced from the length of the array containing
// the initial guess for the coefficients of the polynomial.
final double[] init = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2

// Compute optimal coefficients.
final double[] best = fitter.fit(new PolynomialFunction.Parametric(), init);

// Construct the polynomial that best fits the data.
final PolynomialFunction fitted = new PolynomialFunction(best);
        </pre> 
</div> 
<p> The more specialized <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/HarmonicFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.HarmonicFitter"" api=""HarmonicFitter"" kind=""class"">
    HarmonicFitter 
  </clt></a> classes requires neither an implementation of the parametric real function nor an initial guess as it is are able to compute them internally. </p>",fit,unknown
,12.6 Curve Fitting,"<h3>12.6 Curve Fitting</h3> 
<p> The fitting package deals with curve fitting for univariate real functions. When a univariate real function y = f(x) does depend on some unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>, curve fitting can be used to find these parameters. It does this by <i>fitting</i> the curve so it remains very close to a set of observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>, y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting is done by finding the parameters values that minimizes the objective function sum(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is really a least squares problem. </p> 
<p> For all provided curve fitters, the operating principle is the same. Users must first create an instance of the fitter, then add the observed points and once the complete sample of observed points has been added they must call the <tt> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter.fit"" api=""fit"" kind=""unknown"">
    fit 
  </clt></tt> method which will compute the parameters that best fit the sample. A weight is associated with each observed point, this allows to take into account uncertainty on some points when they come from loosy measurements for example. If no such information exist and all points should be treated the same, it is safe to put 1.0 as the weight for all points. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/CurveFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter"" api=""CurveFitter"" kind=""class"">
    CurveFitter 
  </clt></a> class provides curve fitting for general curves. Users must provide their own implementation of the curve template as a class implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/ParametricUnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.ParametricUnivariateFunction"" api=""ParametricUnivariateFunction"" kind=""class"">
    ParametricUnivariateFunction 
  </clt></a> interface and they must provide the initial guess of the parameters. </p> 
<p> The following example shows how to fit data with a polynomial function. </p> 
<div class=""source""> 
 <pre>final CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());
fitter.addObservedPoint(-1.00, 2.021170021833143);
fitter.addObservedPoint(-0.99, 2.221135431136975);
fitter.addObservedPoint(-0.98, 2.09985277659314);
fitter.addObservedPoint(-0.97, 2.0211192647627025);
// ... Lots of lines omitted ...
fitter.addObservedPoint( 0.99, -2.4345814727089854);

// The degree of the polynomial is deduced from the length of the array containing
// the initial guess for the coefficients of the polynomial.
final double[] init = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2

// Compute optimal coefficients.
final double[] best = fitter.fit(new PolynomialFunction.Parametric(), init);

// Construct the polynomial that best fits the data.
final PolynomialFunction fitted = new PolynomialFunction(best);
        </pre> 
</div> 
<p> The more specialized <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/HarmonicFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.HarmonicFitter"" api=""HarmonicFitter"" kind=""class"">
    HarmonicFitter 
  </clt></a> classes requires neither an implementation of the parametric real function nor an initial guess as it is are able to compute them internally. </p>",CurveFitter,class
,12.6 Curve Fitting,"<h3>12.6 Curve Fitting</h3> 
<p> The fitting package deals with curve fitting for univariate real functions. When a univariate real function y = f(x) does depend on some unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>, curve fitting can be used to find these parameters. It does this by <i>fitting</i> the curve so it remains very close to a set of observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>, y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting is done by finding the parameters values that minimizes the objective function sum(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is really a least squares problem. </p> 
<p> For all provided curve fitters, the operating principle is the same. Users must first create an instance of the fitter, then add the observed points and once the complete sample of observed points has been added they must call the <tt> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter.fit"" api=""fit"" kind=""unknown"">
    fit 
  </clt></tt> method which will compute the parameters that best fit the sample. A weight is associated with each observed point, this allows to take into account uncertainty on some points when they come from loosy measurements for example. If no such information exist and all points should be treated the same, it is safe to put 1.0 as the weight for all points. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/CurveFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter"" api=""CurveFitter"" kind=""class"">
    CurveFitter 
  </clt></a> class provides curve fitting for general curves. Users must provide their own implementation of the curve template as a class implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/ParametricUnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.ParametricUnivariateFunction"" api=""ParametricUnivariateFunction"" kind=""class"">
    ParametricUnivariateFunction 
  </clt></a> interface and they must provide the initial guess of the parameters. </p> 
<p> The following example shows how to fit data with a polynomial function. </p> 
<div class=""source""> 
 <pre>final CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());
fitter.addObservedPoint(-1.00, 2.021170021833143);
fitter.addObservedPoint(-0.99, 2.221135431136975);
fitter.addObservedPoint(-0.98, 2.09985277659314);
fitter.addObservedPoint(-0.97, 2.0211192647627025);
// ... Lots of lines omitted ...
fitter.addObservedPoint( 0.99, -2.4345814727089854);

// The degree of the polynomial is deduced from the length of the array containing
// the initial guess for the coefficients of the polynomial.
final double[] init = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2

// Compute optimal coefficients.
final double[] best = fitter.fit(new PolynomialFunction.Parametric(), init);

// Construct the polynomial that best fits the data.
final PolynomialFunction fitted = new PolynomialFunction(best);
        </pre> 
</div> 
<p> The more specialized <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/HarmonicFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.HarmonicFitter"" api=""HarmonicFitter"" kind=""class"">
    HarmonicFitter 
  </clt></a> classes requires neither an implementation of the parametric real function nor an initial guess as it is are able to compute them internally. </p>",ParametricUnivariateFunction,class
,12.6 Curve Fitting,"<h3>12.6 Curve Fitting</h3> 
<p> The fitting package deals with curve fitting for univariate real functions. When a univariate real function y = f(x) does depend on some unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>, curve fitting can be used to find these parameters. It does this by <i>fitting</i> the curve so it remains very close to a set of observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>, y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting is done by finding the parameters values that minimizes the objective function sum(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is really a least squares problem. </p> 
<p> For all provided curve fitters, the operating principle is the same. Users must first create an instance of the fitter, then add the observed points and once the complete sample of observed points has been added they must call the <tt> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter.fit"" api=""fit"" kind=""unknown"">
    fit 
  </clt></tt> method which will compute the parameters that best fit the sample. A weight is associated with each observed point, this allows to take into account uncertainty on some points when they come from loosy measurements for example. If no such information exist and all points should be treated the same, it is safe to put 1.0 as the weight for all points. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/CurveFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.CurveFitter"" api=""CurveFitter"" kind=""class"">
    CurveFitter 
  </clt></a> class provides curve fitting for general curves. Users must provide their own implementation of the curve template as a class implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/ParametricUnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.ParametricUnivariateFunction"" api=""ParametricUnivariateFunction"" kind=""class"">
    ParametricUnivariateFunction 
  </clt></a> interface and they must provide the initial guess of the parameters. </p> 
<p> The following example shows how to fit data with a polynomial function. </p> 
<div class=""source""> 
 <pre>final CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());
fitter.addObservedPoint(-1.00, 2.021170021833143);
fitter.addObservedPoint(-0.99, 2.221135431136975);
fitter.addObservedPoint(-0.98, 2.09985277659314);
fitter.addObservedPoint(-0.97, 2.0211192647627025);
// ... Lots of lines omitted ...
fitter.addObservedPoint( 0.99, -2.4345814727089854);

// The degree of the polynomial is deduced from the length of the array containing
// the initial guess for the coefficients of the polynomial.
final double[] init = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2

// Compute optimal coefficients.
final double[] best = fitter.fit(new PolynomialFunction.Parametric(), init);

// Construct the polynomial that best fits the data.
final PolynomialFunction fitted = new PolynomialFunction(best);
        </pre> 
</div> 
<p> The more specialized <a href=""../apidocs/org/apache/commons/math3/optimization/fitting/HarmonicFitter.html""> 
  <clt fqn=""org.apache.commons.math3.fitting.HarmonicFitter"" api=""HarmonicFitter"" kind=""class"">
    HarmonicFitter 
  </clt></a> classes requires neither an implementation of the parametric real function nor an initial guess as it is are able to compute them internally. </p>",HarmonicFitter,class
,13.1 Overview,"<h3>13.1 Overview</h3> 
<p> The ode package provides classes to solve Ordinary Differential Equations problems. </p> 
<p> This package solves Initial Value Problems of the form y'=f(t,y) with t<sub>0</sub> and y(t<sub>0</sub>)=y<sub>0</sub> known. The provided integrators compute an estimate of y(t) from t=t<sub>0</sub> to t=t<sub>1</sub>. </p> 
<p> All integrators provide dense output. This means that besides computing the state vector at discrete times, they also provide a cheap mean to get both the state and its derivative between the time steps. They do so through classes extending the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepInterpolator"" api=""StepInterpolator"" kind=""class"">
    StepInterpolator 
  </clt></a> abstract class, which are made available to the user at the end of each step. </p> 
<p> All integrators handle multiple discrete events detection based on switching functions. This means that the integrator can be driven by user specified discrete events (occurring when the sign of user-supplied <i>switching function</i> changes). The steps are shortened as needed to ensure the events occur at step boundaries (even if the integrator is a fixed-step integrator). When the events are triggered, integration can be stopped (this is called a G-stop facility), the state vector can be changed, or integration can simply go on. The latter case is useful to handle discontinuities in the differential equations gracefully and get accurate dense output even close to the discontinuity. </p> 
<p> All integrators support setting a maximal number of evaluations of differential equations function. If this number is exceeded, an exception will be thrown during integration. This can be used to prevent infinite loops if for example error control or discrete events create a really large number of extremely small steps. By default, the maximal number of evaluation is set to <tt>Integer.MAX_VALUE</tt> (i.e. 2<sup>31</sup>-1 or 2147483647). It is recommended to set this maximal number to a value suited to the ODE problem, integration range, and step size or error control settings. </p> 
<p> The user should describe his problem in his own classes which should implement the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderDifferentialEquations"" api=""FirstOrderDifferentialEquations"" kind=""class"">
    FirstOrderDifferentialEquations 
  </clt></a> interface. Then he should pass it to the integrator he prefers among all the classes that implement the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator"" api=""FirstOrderIntegrator"" kind=""class"">
    FirstOrderIntegrator 
  </clt></a> interface. The following example shows how to implement the simple two-dimensional problem: </p> 
<ul> 
 <li>y'<sub>0</sub>(t) = ? &times; (c<sub>1</sub> - y<sub>1</sub>(t))</li> 
 <li>y'<sub>1</sub>(t) = ? &times; (y<sub>0</sub>(t) - c<sub>0</sub>)</li> 
</ul> with some initial state y(t 
<sub>0</sub>) = (y 
<sub>0</sub>(t 
<sub>0</sub>), y 
<sub>1</sub>(t 
<sub>0</sub>)). In fact, the exact solution of this problem is that y(t) moves along a circle centered at c = (c 
<sub>0</sub>, c 
<sub>1</sub>) with constant angular rate ?. 
<div class=""source""> 
 <pre>
private static class CircleODE implements FirstOrderDifferentialEquations {

    private double[] c;
    private double omega;

    public CircleODE(double[] c, double omega) {
        this.c     = c;
        this.omega = omega;
    }

    public int getDimension() {
        return 2;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        yDot[0] = omega * (c[1] - y[1]);
        yDot[1] = omega * (y[0] - c[0]);
    }

}
        </pre> 
</div> 
<p> Computing the state y(16.0) starting from y(0.0) = (0.0, 1.0) and integrating the ODE is done as follows (using Dormand-Prince 8(5,3) integrator as an example): </p> 
<div class=""source""> 
 <pre>
FirstOrderIntegrator dp853 = new DormandPrince853Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);
FirstOrderDifferentialEquations ode = new CircleODE(new double[] { 1.0, 1.0 }, 0.1);
double[] y = new double[] { 0.0, 1.0 }; // initial state
dp853.integrate(ode, 0.0, y, 16.0, y); // now y contains final state at time t=16.0
        </pre> 
</div>",StepInterpolator,class
,13.1 Overview,"<h3>13.1 Overview</h3> 
<p> The ode package provides classes to solve Ordinary Differential Equations problems. </p> 
<p> This package solves Initial Value Problems of the form y'=f(t,y) with t<sub>0</sub> and y(t<sub>0</sub>)=y<sub>0</sub> known. The provided integrators compute an estimate of y(t) from t=t<sub>0</sub> to t=t<sub>1</sub>. </p> 
<p> All integrators provide dense output. This means that besides computing the state vector at discrete times, they also provide a cheap mean to get both the state and its derivative between the time steps. They do so through classes extending the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepInterpolator"" api=""StepInterpolator"" kind=""class"">
    StepInterpolator 
  </clt></a> abstract class, which are made available to the user at the end of each step. </p> 
<p> All integrators handle multiple discrete events detection based on switching functions. This means that the integrator can be driven by user specified discrete events (occurring when the sign of user-supplied <i>switching function</i> changes). The steps are shortened as needed to ensure the events occur at step boundaries (even if the integrator is a fixed-step integrator). When the events are triggered, integration can be stopped (this is called a G-stop facility), the state vector can be changed, or integration can simply go on. The latter case is useful to handle discontinuities in the differential equations gracefully and get accurate dense output even close to the discontinuity. </p> 
<p> All integrators support setting a maximal number of evaluations of differential equations function. If this number is exceeded, an exception will be thrown during integration. This can be used to prevent infinite loops if for example error control or discrete events create a really large number of extremely small steps. By default, the maximal number of evaluation is set to <tt>Integer.MAX_VALUE</tt> (i.e. 2<sup>31</sup>-1 or 2147483647). It is recommended to set this maximal number to a value suited to the ODE problem, integration range, and step size or error control settings. </p> 
<p> The user should describe his problem in his own classes which should implement the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderDifferentialEquations"" api=""FirstOrderDifferentialEquations"" kind=""class"">
    FirstOrderDifferentialEquations 
  </clt></a> interface. Then he should pass it to the integrator he prefers among all the classes that implement the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator"" api=""FirstOrderIntegrator"" kind=""class"">
    FirstOrderIntegrator 
  </clt></a> interface. The following example shows how to implement the simple two-dimensional problem: </p> 
<ul> 
 <li>y'<sub>0</sub>(t) = ? &times; (c<sub>1</sub> - y<sub>1</sub>(t))</li> 
 <li>y'<sub>1</sub>(t) = ? &times; (y<sub>0</sub>(t) - c<sub>0</sub>)</li> 
</ul> with some initial state y(t 
<sub>0</sub>) = (y 
<sub>0</sub>(t 
<sub>0</sub>), y 
<sub>1</sub>(t 
<sub>0</sub>)). In fact, the exact solution of this problem is that y(t) moves along a circle centered at c = (c 
<sub>0</sub>, c 
<sub>1</sub>) with constant angular rate ?. 
<div class=""source""> 
 <pre>
private static class CircleODE implements FirstOrderDifferentialEquations {

    private double[] c;
    private double omega;

    public CircleODE(double[] c, double omega) {
        this.c     = c;
        this.omega = omega;
    }

    public int getDimension() {
        return 2;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        yDot[0] = omega * (c[1] - y[1]);
        yDot[1] = omega * (y[0] - c[0]);
    }

}
        </pre> 
</div> 
<p> Computing the state y(16.0) starting from y(0.0) = (0.0, 1.0) and integrating the ODE is done as follows (using Dormand-Prince 8(5,3) integrator as an example): </p> 
<div class=""source""> 
 <pre>
FirstOrderIntegrator dp853 = new DormandPrince853Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);
FirstOrderDifferentialEquations ode = new CircleODE(new double[] { 1.0, 1.0 }, 0.1);
double[] y = new double[] { 0.0, 1.0 }; // initial state
dp853.integrate(ode, 0.0, y, 16.0, y); // now y contains final state at time t=16.0
        </pre> 
</div>",FirstOrderDifferentialEquations,class
,13.1 Overview,"<h3>13.1 Overview</h3> 
<p> The ode package provides classes to solve Ordinary Differential Equations problems. </p> 
<p> This package solves Initial Value Problems of the form y'=f(t,y) with t<sub>0</sub> and y(t<sub>0</sub>)=y<sub>0</sub> known. The provided integrators compute an estimate of y(t) from t=t<sub>0</sub> to t=t<sub>1</sub>. </p> 
<p> All integrators provide dense output. This means that besides computing the state vector at discrete times, they also provide a cheap mean to get both the state and its derivative between the time steps. They do so through classes extending the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepInterpolator"" api=""StepInterpolator"" kind=""class"">
    StepInterpolator 
  </clt></a> abstract class, which are made available to the user at the end of each step. </p> 
<p> All integrators handle multiple discrete events detection based on switching functions. This means that the integrator can be driven by user specified discrete events (occurring when the sign of user-supplied <i>switching function</i> changes). The steps are shortened as needed to ensure the events occur at step boundaries (even if the integrator is a fixed-step integrator). When the events are triggered, integration can be stopped (this is called a G-stop facility), the state vector can be changed, or integration can simply go on. The latter case is useful to handle discontinuities in the differential equations gracefully and get accurate dense output even close to the discontinuity. </p> 
<p> All integrators support setting a maximal number of evaluations of differential equations function. If this number is exceeded, an exception will be thrown during integration. This can be used to prevent infinite loops if for example error control or discrete events create a really large number of extremely small steps. By default, the maximal number of evaluation is set to <tt>Integer.MAX_VALUE</tt> (i.e. 2<sup>31</sup>-1 or 2147483647). It is recommended to set this maximal number to a value suited to the ODE problem, integration range, and step size or error control settings. </p> 
<p> The user should describe his problem in his own classes which should implement the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderDifferentialEquations"" api=""FirstOrderDifferentialEquations"" kind=""class"">
    FirstOrderDifferentialEquations 
  </clt></a> interface. Then he should pass it to the integrator he prefers among all the classes that implement the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator"" api=""FirstOrderIntegrator"" kind=""class"">
    FirstOrderIntegrator 
  </clt></a> interface. The following example shows how to implement the simple two-dimensional problem: </p> 
<ul> 
 <li>y'<sub>0</sub>(t) = ? &times; (c<sub>1</sub> - y<sub>1</sub>(t))</li> 
 <li>y'<sub>1</sub>(t) = ? &times; (y<sub>0</sub>(t) - c<sub>0</sub>)</li> 
</ul> with some initial state y(t 
<sub>0</sub>) = (y 
<sub>0</sub>(t 
<sub>0</sub>), y 
<sub>1</sub>(t 
<sub>0</sub>)). In fact, the exact solution of this problem is that y(t) moves along a circle centered at c = (c 
<sub>0</sub>, c 
<sub>1</sub>) with constant angular rate ?. 
<div class=""source""> 
 <pre>
private static class CircleODE implements FirstOrderDifferentialEquations {

    private double[] c;
    private double omega;

    public CircleODE(double[] c, double omega) {
        this.c     = c;
        this.omega = omega;
    }

    public int getDimension() {
        return 2;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        yDot[0] = omega * (c[1] - y[1]);
        yDot[1] = omega * (y[0] - c[0]);
    }

}
        </pre> 
</div> 
<p> Computing the state y(16.0) starting from y(0.0) = (0.0, 1.0) and integrating the ODE is done as follows (using Dormand-Prince 8(5,3) integrator as an example): </p> 
<div class=""source""> 
 <pre>
FirstOrderIntegrator dp853 = new DormandPrince853Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);
FirstOrderDifferentialEquations ode = new CircleODE(new double[] { 1.0, 1.0 }, 0.1);
double[] y = new double[] { 0.0, 1.0 }; // initial state
dp853.integrate(ode, 0.0, y, 16.0, y); // now y contains final state at time t=16.0
        </pre> 
</div>",FirstOrderIntegrator,class
,13.2 Continuous Output,"<h3>13.2 Continuous Output</h3> 
<p> The solution of the integration problem is provided by two means. The first one is aimed towards simple use: the state vector at the end of the integration process is copied in the y array of the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method, as shown by previous example. The second one should be used when more in-depth information is needed throughout the integration process. The user can register an object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface or a <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> object wrapping a user-specified object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface into the integrator before calling the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method. The user object will be called appropriately during the integration process, allowing the user to process intermediate results. The default step handler does nothing. Considering again the previous example, we want to print the trajectory of the point to check it really is a circle arc. We simply add the following before the call to integrator.integrate: </p> 
<div class=""source""> 
 <pre>
StepHandler stepHandler = new StepHandler() {
    public void init(double t0, double[] y0, double t) {
    }
            
    public void handleStep(StepInterpolator interpolator, boolean isLast) {
        double   t = interpolator.getCurrentTime();
        double[] y = interpolator.getInterpolatedState();
        System.out.println(t + &quot; &quot; + y[0] + &quot; &quot; + y[1]);
    }
};
integrator.addStepHandler(stepHandler);
        </pre> 
</div> 
<p> <a href=""../apidocs/org/apache/commons/math3/ode/ContinuousOutputModel.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ContinuousOutputModel"" api=""ContinuousOutputModel"" kind=""class"">
    ContinuousOutputModel 
  </clt></a> is a special-purpose step handler that is able to store all steps and to provide transparent access to any intermediate result once the integration is over. An important feature of this class is that it implements the <tt>Serializable</tt> interface. This means that a complete continuous model of the integrated function throughout the integration range can be serialized and reused later (if stored into a persistent medium like a file system or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. </p> 
<p> Other default implementations of the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface are available for general needs (<a href=""../apidocs/org/apache/commons/math3/ode/sampling/DummyStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.DummyStepHandler"" api=""DummyStepHandler"" kind=""class"">
    DummyStepHandler 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a>) and custom implementations can be developed for specific needs. As an example, if an application is to be completely driven by the integration process, then most of the application code will be run inside a step handler specific to this application. </p> 
<p> Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient integrators use variable steps that are handled internally in order to control the integration error with respect to a specified accuracy (these integrators extend the <a href=""../apidocs/org/apache/commons/math3/ode/AdaptiveStepsizeIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"" api=""AdaptiveStepsizeIntegrator"" kind=""class"">
    AdaptiveStepsizeIntegrator 
  </clt></a> abstract class). In this case, the step handler which is called after each successful step shows up the variable stepsize. The <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves, however the user can specify it if he prefers to retain full control over the integration or if the automatic guess is wrong. </p>",integrate,field
,13.2 Continuous Output,"<h3>13.2 Continuous Output</h3> 
<p> The solution of the integration problem is provided by two means. The first one is aimed towards simple use: the state vector at the end of the integration process is copied in the y array of the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method, as shown by previous example. The second one should be used when more in-depth information is needed throughout the integration process. The user can register an object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface or a <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> object wrapping a user-specified object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface into the integrator before calling the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method. The user object will be called appropriately during the integration process, allowing the user to process intermediate results. The default step handler does nothing. Considering again the previous example, we want to print the trajectory of the point to check it really is a circle arc. We simply add the following before the call to integrator.integrate: </p> 
<div class=""source""> 
 <pre>
StepHandler stepHandler = new StepHandler() {
    public void init(double t0, double[] y0, double t) {
    }
            
    public void handleStep(StepInterpolator interpolator, boolean isLast) {
        double   t = interpolator.getCurrentTime();
        double[] y = interpolator.getInterpolatedState();
        System.out.println(t + &quot; &quot; + y[0] + &quot; &quot; + y[1]);
    }
};
integrator.addStepHandler(stepHandler);
        </pre> 
</div> 
<p> <a href=""../apidocs/org/apache/commons/math3/ode/ContinuousOutputModel.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ContinuousOutputModel"" api=""ContinuousOutputModel"" kind=""class"">
    ContinuousOutputModel 
  </clt></a> is a special-purpose step handler that is able to store all steps and to provide transparent access to any intermediate result once the integration is over. An important feature of this class is that it implements the <tt>Serializable</tt> interface. This means that a complete continuous model of the integrated function throughout the integration range can be serialized and reused later (if stored into a persistent medium like a file system or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. </p> 
<p> Other default implementations of the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface are available for general needs (<a href=""../apidocs/org/apache/commons/math3/ode/sampling/DummyStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.DummyStepHandler"" api=""DummyStepHandler"" kind=""class"">
    DummyStepHandler 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a>) and custom implementations can be developed for specific needs. As an example, if an application is to be completely driven by the integration process, then most of the application code will be run inside a step handler specific to this application. </p> 
<p> Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient integrators use variable steps that are handled internally in order to control the integration error with respect to a specified accuracy (these integrators extend the <a href=""../apidocs/org/apache/commons/math3/ode/AdaptiveStepsizeIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"" api=""AdaptiveStepsizeIntegrator"" kind=""class"">
    AdaptiveStepsizeIntegrator 
  </clt></a> abstract class). In this case, the step handler which is called after each successful step shows up the variable stepsize. The <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves, however the user can specify it if he prefers to retain full control over the integration or if the automatic guess is wrong. </p>",StepHandler,class
,13.2 Continuous Output,"<h3>13.2 Continuous Output</h3> 
<p> The solution of the integration problem is provided by two means. The first one is aimed towards simple use: the state vector at the end of the integration process is copied in the y array of the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method, as shown by previous example. The second one should be used when more in-depth information is needed throughout the integration process. The user can register an object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface or a <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> object wrapping a user-specified object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface into the integrator before calling the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method. The user object will be called appropriately during the integration process, allowing the user to process intermediate results. The default step handler does nothing. Considering again the previous example, we want to print the trajectory of the point to check it really is a circle arc. We simply add the following before the call to integrator.integrate: </p> 
<div class=""source""> 
 <pre>
StepHandler stepHandler = new StepHandler() {
    public void init(double t0, double[] y0, double t) {
    }
            
    public void handleStep(StepInterpolator interpolator, boolean isLast) {
        double   t = interpolator.getCurrentTime();
        double[] y = interpolator.getInterpolatedState();
        System.out.println(t + &quot; &quot; + y[0] + &quot; &quot; + y[1]);
    }
};
integrator.addStepHandler(stepHandler);
        </pre> 
</div> 
<p> <a href=""../apidocs/org/apache/commons/math3/ode/ContinuousOutputModel.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ContinuousOutputModel"" api=""ContinuousOutputModel"" kind=""class"">
    ContinuousOutputModel 
  </clt></a> is a special-purpose step handler that is able to store all steps and to provide transparent access to any intermediate result once the integration is over. An important feature of this class is that it implements the <tt>Serializable</tt> interface. This means that a complete continuous model of the integrated function throughout the integration range can be serialized and reused later (if stored into a persistent medium like a file system or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. </p> 
<p> Other default implementations of the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface are available for general needs (<a href=""../apidocs/org/apache/commons/math3/ode/sampling/DummyStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.DummyStepHandler"" api=""DummyStepHandler"" kind=""class"">
    DummyStepHandler 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a>) and custom implementations can be developed for specific needs. As an example, if an application is to be completely driven by the integration process, then most of the application code will be run inside a step handler specific to this application. </p> 
<p> Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient integrators use variable steps that are handled internally in order to control the integration error with respect to a specified accuracy (these integrators extend the <a href=""../apidocs/org/apache/commons/math3/ode/AdaptiveStepsizeIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"" api=""AdaptiveStepsizeIntegrator"" kind=""class"">
    AdaptiveStepsizeIntegrator 
  </clt></a> abstract class). In this case, the step handler which is called after each successful step shows up the variable stepsize. The <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves, however the user can specify it if he prefers to retain full control over the integration or if the automatic guess is wrong. </p>",StepNormalizer,class
,13.2 Continuous Output,"<h3>13.2 Continuous Output</h3> 
<p> The solution of the integration problem is provided by two means. The first one is aimed towards simple use: the state vector at the end of the integration process is copied in the y array of the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method, as shown by previous example. The second one should be used when more in-depth information is needed throughout the integration process. The user can register an object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface or a <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> object wrapping a user-specified object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface into the integrator before calling the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method. The user object will be called appropriately during the integration process, allowing the user to process intermediate results. The default step handler does nothing. Considering again the previous example, we want to print the trajectory of the point to check it really is a circle arc. We simply add the following before the call to integrator.integrate: </p> 
<div class=""source""> 
 <pre>
StepHandler stepHandler = new StepHandler() {
    public void init(double t0, double[] y0, double t) {
    }
            
    public void handleStep(StepInterpolator interpolator, boolean isLast) {
        double   t = interpolator.getCurrentTime();
        double[] y = interpolator.getInterpolatedState();
        System.out.println(t + &quot; &quot; + y[0] + &quot; &quot; + y[1]);
    }
};
integrator.addStepHandler(stepHandler);
        </pre> 
</div> 
<p> <a href=""../apidocs/org/apache/commons/math3/ode/ContinuousOutputModel.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ContinuousOutputModel"" api=""ContinuousOutputModel"" kind=""class"">
    ContinuousOutputModel 
  </clt></a> is a special-purpose step handler that is able to store all steps and to provide transparent access to any intermediate result once the integration is over. An important feature of this class is that it implements the <tt>Serializable</tt> interface. This means that a complete continuous model of the integrated function throughout the integration range can be serialized and reused later (if stored into a persistent medium like a file system or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. </p> 
<p> Other default implementations of the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface are available for general needs (<a href=""../apidocs/org/apache/commons/math3/ode/sampling/DummyStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.DummyStepHandler"" api=""DummyStepHandler"" kind=""class"">
    DummyStepHandler 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a>) and custom implementations can be developed for specific needs. As an example, if an application is to be completely driven by the integration process, then most of the application code will be run inside a step handler specific to this application. </p> 
<p> Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient integrators use variable steps that are handled internally in order to control the integration error with respect to a specified accuracy (these integrators extend the <a href=""../apidocs/org/apache/commons/math3/ode/AdaptiveStepsizeIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"" api=""AdaptiveStepsizeIntegrator"" kind=""class"">
    AdaptiveStepsizeIntegrator 
  </clt></a> abstract class). In this case, the step handler which is called after each successful step shows up the variable stepsize. The <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves, however the user can specify it if he prefers to retain full control over the integration or if the automatic guess is wrong. </p>",FixedStepHandler,class
,13.2 Continuous Output,"<h3>13.2 Continuous Output</h3> 
<p> The solution of the integration problem is provided by two means. The first one is aimed towards simple use: the state vector at the end of the integration process is copied in the y array of the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method, as shown by previous example. The second one should be used when more in-depth information is needed throughout the integration process. The user can register an object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface or a <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> object wrapping a user-specified object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface into the integrator before calling the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method. The user object will be called appropriately during the integration process, allowing the user to process intermediate results. The default step handler does nothing. Considering again the previous example, we want to print the trajectory of the point to check it really is a circle arc. We simply add the following before the call to integrator.integrate: </p> 
<div class=""source""> 
 <pre>
StepHandler stepHandler = new StepHandler() {
    public void init(double t0, double[] y0, double t) {
    }
            
    public void handleStep(StepInterpolator interpolator, boolean isLast) {
        double   t = interpolator.getCurrentTime();
        double[] y = interpolator.getInterpolatedState();
        System.out.println(t + &quot; &quot; + y[0] + &quot; &quot; + y[1]);
    }
};
integrator.addStepHandler(stepHandler);
        </pre> 
</div> 
<p> <a href=""../apidocs/org/apache/commons/math3/ode/ContinuousOutputModel.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ContinuousOutputModel"" api=""ContinuousOutputModel"" kind=""class"">
    ContinuousOutputModel 
  </clt></a> is a special-purpose step handler that is able to store all steps and to provide transparent access to any intermediate result once the integration is over. An important feature of this class is that it implements the <tt>Serializable</tt> interface. This means that a complete continuous model of the integrated function throughout the integration range can be serialized and reused later (if stored into a persistent medium like a file system or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. </p> 
<p> Other default implementations of the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface are available for general needs (<a href=""../apidocs/org/apache/commons/math3/ode/sampling/DummyStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.DummyStepHandler"" api=""DummyStepHandler"" kind=""class"">
    DummyStepHandler 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a>) and custom implementations can be developed for specific needs. As an example, if an application is to be completely driven by the integration process, then most of the application code will be run inside a step handler specific to this application. </p> 
<p> Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient integrators use variable steps that are handled internally in order to control the integration error with respect to a specified accuracy (these integrators extend the <a href=""../apidocs/org/apache/commons/math3/ode/AdaptiveStepsizeIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"" api=""AdaptiveStepsizeIntegrator"" kind=""class"">
    AdaptiveStepsizeIntegrator 
  </clt></a> abstract class). In this case, the step handler which is called after each successful step shows up the variable stepsize. The <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves, however the user can specify it if he prefers to retain full control over the integration or if the automatic guess is wrong. </p>",ContinuousOutputModel,class
,13.2 Continuous Output,"<h3>13.2 Continuous Output</h3> 
<p> The solution of the integration problem is provided by two means. The first one is aimed towards simple use: the state vector at the end of the integration process is copied in the y array of the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method, as shown by previous example. The second one should be used when more in-depth information is needed throughout the integration process. The user can register an object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface or a <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> object wrapping a user-specified object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface into the integrator before calling the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method. The user object will be called appropriately during the integration process, allowing the user to process intermediate results. The default step handler does nothing. Considering again the previous example, we want to print the trajectory of the point to check it really is a circle arc. We simply add the following before the call to integrator.integrate: </p> 
<div class=""source""> 
 <pre>
StepHandler stepHandler = new StepHandler() {
    public void init(double t0, double[] y0, double t) {
    }
            
    public void handleStep(StepInterpolator interpolator, boolean isLast) {
        double   t = interpolator.getCurrentTime();
        double[] y = interpolator.getInterpolatedState();
        System.out.println(t + &quot; &quot; + y[0] + &quot; &quot; + y[1]);
    }
};
integrator.addStepHandler(stepHandler);
        </pre> 
</div> 
<p> <a href=""../apidocs/org/apache/commons/math3/ode/ContinuousOutputModel.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ContinuousOutputModel"" api=""ContinuousOutputModel"" kind=""class"">
    ContinuousOutputModel 
  </clt></a> is a special-purpose step handler that is able to store all steps and to provide transparent access to any intermediate result once the integration is over. An important feature of this class is that it implements the <tt>Serializable</tt> interface. This means that a complete continuous model of the integrated function throughout the integration range can be serialized and reused later (if stored into a persistent medium like a file system or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. </p> 
<p> Other default implementations of the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface are available for general needs (<a href=""../apidocs/org/apache/commons/math3/ode/sampling/DummyStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.DummyStepHandler"" api=""DummyStepHandler"" kind=""class"">
    DummyStepHandler 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a>) and custom implementations can be developed for specific needs. As an example, if an application is to be completely driven by the integration process, then most of the application code will be run inside a step handler specific to this application. </p> 
<p> Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient integrators use variable steps that are handled internally in order to control the integration error with respect to a specified accuracy (these integrators extend the <a href=""../apidocs/org/apache/commons/math3/ode/AdaptiveStepsizeIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"" api=""AdaptiveStepsizeIntegrator"" kind=""class"">
    AdaptiveStepsizeIntegrator 
  </clt></a> abstract class). In this case, the step handler which is called after each successful step shows up the variable stepsize. The <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves, however the user can specify it if he prefers to retain full control over the integration or if the automatic guess is wrong. </p>",DummyStepHandler,class
,13.2 Continuous Output,"<h3>13.2 Continuous Output</h3> 
<p> The solution of the integration problem is provided by two means. The first one is aimed towards simple use: the state vector at the end of the integration process is copied in the y array of the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method, as shown by previous example. The second one should be used when more in-depth information is needed throughout the integration process. The user can register an object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface or a <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> object wrapping a user-specified object implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface into the integrator before calling the <tt> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"" api=""integrate"" kind=""field"">
    FirstOrderIntegrator.integrate 
  </clt></tt> method. The user object will be called appropriately during the integration process, allowing the user to process intermediate results. The default step handler does nothing. Considering again the previous example, we want to print the trajectory of the point to check it really is a circle arc. We simply add the following before the call to integrator.integrate: </p> 
<div class=""source""> 
 <pre>
StepHandler stepHandler = new StepHandler() {
    public void init(double t0, double[] y0, double t) {
    }
            
    public void handleStep(StepInterpolator interpolator, boolean isLast) {
        double   t = interpolator.getCurrentTime();
        double[] y = interpolator.getInterpolatedState();
        System.out.println(t + &quot; &quot; + y[0] + &quot; &quot; + y[1]);
    }
};
integrator.addStepHandler(stepHandler);
        </pre> 
</div> 
<p> <a href=""../apidocs/org/apache/commons/math3/ode/ContinuousOutputModel.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ContinuousOutputModel"" api=""ContinuousOutputModel"" kind=""class"">
    ContinuousOutputModel 
  </clt></a> is a special-purpose step handler that is able to store all steps and to provide transparent access to any intermediate result once the integration is over. An important feature of this class is that it implements the <tt>Serializable</tt> interface. This means that a complete continuous model of the integrated function throughout the integration range can be serialized and reused later (if stored into a persistent medium like a file system or a database) or elsewhere (if sent to another application). Only the result of the integration is stored, there is no reference to the integrated problem by itself. </p> 
<p> Other default implementations of the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepHandler"" api=""StepHandler"" kind=""class"">
    StepHandler 
  </clt></a> interface are available for general needs (<a href=""../apidocs/org/apache/commons/math3/ode/sampling/DummyStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.DummyStepHandler"" api=""DummyStepHandler"" kind=""class"">
    DummyStepHandler 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a>) and custom implementations can be developed for specific needs. As an example, if an application is to be completely driven by the integration process, then most of the application code will be run inside a step handler specific to this application. </p> 
<p> Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient integrators use variable steps that are handled internally in order to control the integration error with respect to a specified accuracy (these integrators extend the <a href=""../apidocs/org/apache/commons/math3/ode/AdaptiveStepsizeIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"" api=""AdaptiveStepsizeIntegrator"" kind=""class"">
    AdaptiveStepsizeIntegrator 
  </clt></a> abstract class). In this case, the step handler which is called after each successful step shows up the variable stepsize. The <a href=""../apidocs/org/apache/commons/math3/ode/sampling/StepNormalizer.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.StepNormalizer"" api=""StepNormalizer"" kind=""class"">
    StepNormalizer 
  </clt></a> class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes implementing the <a href=""../apidocs/org/apache/commons/math3/ode/sampling/FixedStepHandler.html""> 
  <clt fqn=""org.apache.commons.math3.ode.sampling.FixedStepHandler"" api=""FixedStepHandler"" kind=""class"">
    FixedStepHandler 
  </clt></a> interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves, however the user can specify it if he prefers to retain full control over the integration or if the automatic guess is wrong. </p>",AdaptiveStepsizeIntegrator,class
,13.5 Derivatives,"<h3>13.5 Derivatives</h3> 
<p> If in addition to state y(t) the user needs to compute the sensitivity of the state to the initial state or some parameter of the ODE, he will use the classes and interfaces from the <a href=""../apidocs/org/apache/commons/math3/ode/jacobians/package-summary.html"">org.apache.commons.ode.jacobians</a> package instead of the top level ode package. These classes compute the jacobians dy(t)/dy<sub>0</sub> and dy(t)/dp where y<sub>0</sub> is the initial state and p is some ODE parameter. </p> 
<p> The classes and interfaces in this package mimic the behavior of the classes and interfaces of the top level ode package, only adding parameters arrays for the jacobians. The behavior of these classes is to create a compound state vector z containing both the state y(t) and its derivatives dy(t)/dy<sub>0</sub> and dy(t)/dp and to set up an extended problem by adding the equations for the jacobians automatically. These extended state and problems are then provided to a classical underlying integrator chosen by user. </p> 
<p> This behavior imply there will be a top level integrator knowing about state and jacobians and a low level integrator knowing only about compound state (which may be big). If the user wants to deal with the top level only, he will use the specialized step handler and event handler classes registered at top level. He can also register classical step handlers and event handlers, but in this case will see the big compound state. This state is guaranteed to contain the original state in the first elements, followed by the jacobian with respect to initial state (in row order), followed by the jacobian with respect to parameters (in row order). If for example the original state dimension is 6 and there are 3 parameters, the compound state will be a 60 elements array. The first 6 elements will be the original state, the next 36 elements will be the jacobian with respect to initial state, and the remaining 18 will be the jacobian with respect to parameters. Dealing with low level step handlers and event handlers is cumbersome if one really needs the jacobians in these methods, but it also prevents many data being copied back and forth between state and jacobians on one side and compound state on the other side. </p> 
<p> In order to compute dy(t)/dy<sub>0</sub> and dy(t/dp for any t, the algorithm needs not only the ODE function f such that y'=f(t,y) but also its local jacobians df(t, y, p)/dy and df(t, y, p)/dp. </p> 
<p> If the function f is too complex, the user can simply rely on internal differentiation using finite differences to compute these local jacobians. So rather than the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderDifferentialEquations"" api=""FirstOrderDifferentialEquations"" kind=""class"">
    FirstOrderDifferentialEquations 
  </clt></a> interface he will implement the <a href=""../apidocs/org/apache/commons/math3/ode/jacobians/ParameterizedODE.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ParameterizedODE"" api=""ParameterizedODE"" kind=""class"">
    ParameterizedODE 
  </clt></a> interface. Considering again our example where only ? is considered a parameter, we get: </p> 
<div class=""source""> 
 <pre>
public class BasicCircleODE implements ParameterizedODE {

    private double[] c;
    private double omega;

    public BasicCircleODE(double[] c, double omega) {
        this.c     = c;
        this.omega = omega;
    }

    public int getDimension() {
        return 2;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        yDot[0] = omega * (c[1] - y[1]);
        yDot[1] = omega * (y[0] - c[0]);
    }

    public int getParametersDimension() {
        // we are only interested in the omega parameter
        return 1;
    }

    public void setParameter(int i, double value) {
        omega = value;
    }

}
        </pre> 
</div> 
<p> This ODE is provided to the specialized integrator with two arrays specifying the step sizes to use for finite differences (one array for derivation with respect to state y, one array for derivation with respect to parameters p): </p> 
<div class=""source""> 
 <pre>
double[] hY = new double[] { 0.001, 0.001 };
double[] hP = new double[] { 1.0e-6 };
FirstOrderIntegratorWithJacobians integrator = new FirstOrderIntegratorWithJacobians(dp853, ode, hY, hP);
integrator.integrate(t0, y0, dy0dp, t, y, dydy0, dydp);
        </pre> 
</div> 
<p> If the function f is simple, the user can simply provide the local jacobians by himself. So rather than the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderDifferentialEquations"" api=""FirstOrderDifferentialEquations"" kind=""class"">
    FirstOrderDifferentialEquations 
  </clt></a> interface he will implement the <a href=""../apidocs/org/apache/commons/math3/ode/jacobians/ODEWithJacobians.html"">ODEWithJacobians</a> interface. Considering again our example where only ? is considered a parameter, we get: </p> 
<div class=""source""> 
 <pre>
public class EnhancedCircleODE implements ODEWithJacobians {

    private double[] c;
    private double omega;

    public EnhancedCircleODE(double[] c, double omega) {
        this.c     = c;
        this.omega = omega;
    }

    public int getDimension() {
        return 2;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        yDot[0] = omega * (c[1] - y[1]);
        yDot[1] = omega * (y[0] - c[0]);
    }

    public int getParametersDimension() {
        // we are only interested in the omega parameter
        return 1;
    }

    public void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP) {

        dFdY[0][0] = 0;
        dFdY[0][1] = -omega;
        dFdY[1][0] = omega;
        dFdY[1][1] = 0;

        dFdP[0][0] = 0;
        dFdP[0][1] = omega;
        dFdP[0][2] = c[1] - y[1];
        dFdP[1][0] = -omega;
        dFdP[1][1] = 0;
        dFdP[1][2] = y[0] - c[0];
 
    }

}
        </pre> 
</div> 
<p> This ODE is provided to the specialized integrator as is: </p> 
<div class=""source""> 
 <pre>
FirstOrderIntegratorWithJacobians integrator = new FirstOrderIntegratorWithJacobians(dp853, ode);
integrator.integrate(t0, y0, dy0dp, t, y, dydy0, dydp);
        </pre> 
</div>",FirstOrderDifferentialEquations,class
,13.5 Derivatives,"<h3>13.5 Derivatives</h3> 
<p> If in addition to state y(t) the user needs to compute the sensitivity of the state to the initial state or some parameter of the ODE, he will use the classes and interfaces from the <a href=""../apidocs/org/apache/commons/math3/ode/jacobians/package-summary.html"">org.apache.commons.ode.jacobians</a> package instead of the top level ode package. These classes compute the jacobians dy(t)/dy<sub>0</sub> and dy(t)/dp where y<sub>0</sub> is the initial state and p is some ODE parameter. </p> 
<p> The classes and interfaces in this package mimic the behavior of the classes and interfaces of the top level ode package, only adding parameters arrays for the jacobians. The behavior of these classes is to create a compound state vector z containing both the state y(t) and its derivatives dy(t)/dy<sub>0</sub> and dy(t)/dp and to set up an extended problem by adding the equations for the jacobians automatically. These extended state and problems are then provided to a classical underlying integrator chosen by user. </p> 
<p> This behavior imply there will be a top level integrator knowing about state and jacobians and a low level integrator knowing only about compound state (which may be big). If the user wants to deal with the top level only, he will use the specialized step handler and event handler classes registered at top level. He can also register classical step handlers and event handlers, but in this case will see the big compound state. This state is guaranteed to contain the original state in the first elements, followed by the jacobian with respect to initial state (in row order), followed by the jacobian with respect to parameters (in row order). If for example the original state dimension is 6 and there are 3 parameters, the compound state will be a 60 elements array. The first 6 elements will be the original state, the next 36 elements will be the jacobian with respect to initial state, and the remaining 18 will be the jacobian with respect to parameters. Dealing with low level step handlers and event handlers is cumbersome if one really needs the jacobians in these methods, but it also prevents many data being copied back and forth between state and jacobians on one side and compound state on the other side. </p> 
<p> In order to compute dy(t)/dy<sub>0</sub> and dy(t/dp for any t, the algorithm needs not only the ODE function f such that y'=f(t,y) but also its local jacobians df(t, y, p)/dy and df(t, y, p)/dp. </p> 
<p> If the function f is too complex, the user can simply rely on internal differentiation using finite differences to compute these local jacobians. So rather than the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderDifferentialEquations"" api=""FirstOrderDifferentialEquations"" kind=""class"">
    FirstOrderDifferentialEquations 
  </clt></a> interface he will implement the <a href=""../apidocs/org/apache/commons/math3/ode/jacobians/ParameterizedODE.html""> 
  <clt fqn=""org.apache.commons.math3.ode.ParameterizedODE"" api=""ParameterizedODE"" kind=""class"">
    ParameterizedODE 
  </clt></a> interface. Considering again our example where only ? is considered a parameter, we get: </p> 
<div class=""source""> 
 <pre>
public class BasicCircleODE implements ParameterizedODE {

    private double[] c;
    private double omega;

    public BasicCircleODE(double[] c, double omega) {
        this.c     = c;
        this.omega = omega;
    }

    public int getDimension() {
        return 2;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        yDot[0] = omega * (c[1] - y[1]);
        yDot[1] = omega * (y[0] - c[0]);
    }

    public int getParametersDimension() {
        // we are only interested in the omega parameter
        return 1;
    }

    public void setParameter(int i, double value) {
        omega = value;
    }

}
        </pre> 
</div> 
<p> This ODE is provided to the specialized integrator with two arrays specifying the step sizes to use for finite differences (one array for derivation with respect to state y, one array for derivation with respect to parameters p): </p> 
<div class=""source""> 
 <pre>
double[] hY = new double[] { 0.001, 0.001 };
double[] hP = new double[] { 1.0e-6 };
FirstOrderIntegratorWithJacobians integrator = new FirstOrderIntegratorWithJacobians(dp853, ode, hY, hP);
integrator.integrate(t0, y0, dy0dp, t, y, dydy0, dydp);
        </pre> 
</div> 
<p> If the function f is simple, the user can simply provide the local jacobians by himself. So rather than the <a href=""../apidocs/org/apache/commons/math3/ode/FirstOrderDifferentialEquations.html""> 
  <clt fqn=""org.apache.commons.math3.ode.FirstOrderDifferentialEquations"" api=""FirstOrderDifferentialEquations"" kind=""class"">
    FirstOrderDifferentialEquations 
  </clt></a> interface he will implement the <a href=""../apidocs/org/apache/commons/math3/ode/jacobians/ODEWithJacobians.html"">ODEWithJacobians</a> interface. Considering again our example where only ? is considered a parameter, we get: </p> 
<div class=""source""> 
 <pre>
public class EnhancedCircleODE implements ODEWithJacobians {

    private double[] c;
    private double omega;

    public EnhancedCircleODE(double[] c, double omega) {
        this.c     = c;
        this.omega = omega;
    }

    public int getDimension() {
        return 2;
    }

    public void computeDerivatives(double t, double[] y, double[] yDot) {
        yDot[0] = omega * (c[1] - y[1]);
        yDot[1] = omega * (y[0] - c[0]);
    }

    public int getParametersDimension() {
        // we are only interested in the omega parameter
        return 1;
    }

    public void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP) {

        dFdY[0][0] = 0;
        dFdY[0][1] = -omega;
        dFdY[1][0] = omega;
        dFdY[1][1] = 0;

        dFdP[0][0] = 0;
        dFdP[0][1] = omega;
        dFdP[0][2] = c[1] - y[1];
        dFdP[1][0] = -omega;
        dFdP[1][1] = 0;
        dFdP[1][2] = y[0] - c[0];
 
    }

}
        </pre> 
</div> 
<p> This ODE is provided to the specialized integrator as is: </p> 
<div class=""source""> 
 <pre>
FirstOrderIntegratorWithJacobians integrator = new FirstOrderIntegratorWithJacobians(dp853, ode);
integrator.integrate(t0, y0, dy0dp, t, y, dydy0, dydp);
        </pre> 
</div>",ParameterizedODE,class
,14.2 GA Framework,"<clt fqn=""org.apache.commons.math3.genetics.Fitness"" api=""Fitness"" kind=""unknown"">
  14.2 GA Framework GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA). Populations, consisting of Chromosomes are evolved by the GeneticAlgorithm until a StoppingCondition is reached. Evolution is determined by SelectionPolicy , MutationPolicy and Fitness. The GA itself is implemented by the evolve method of the GeneticAlgorithm class, which looks like this: public Population evolve(Population initial, StoppingCondition condition) { Population current = initial; while (!condition.isSatisfied(current)) { current = nextGeneration(current); } return current; } The nextGeneration method implements the following algorithm: Get nextGeneration population to fill from current generation, using its nextGeneration method Loop until new generation is filled: Apply configured SelectionPolicy to select a pair of parents from current With probability = getCrossoverRate(), apply configured CrossoverPolicy to parents With probability = getMutationRate(), apply configured MutationPolicy to each of the offspring Add offspring individually to nextGeneration, space permitting Return nextGeneration 
</clt>",Fitness,unknown
,15.2 Kalman Filter,"<h3>15.2 Kalman Filter</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/filter/KalmanFilter.html""> 
  <clt fqn=""org.apache.commons.math3.filter.KalmanFilter"" api=""KalmanFilter"" kind=""class"">
    KalmanFilter 
  </clt></a> provides a discrete-time filter to estimate a stochastic linear process.</p> 
<p>A Kalman filter is initialized with a <a href=""../apidocs/org/apache/commons/math3/filter/ProcessModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.ProcessModel"" api=""ProcessModel"" kind=""class"">
    ProcessModel 
  </clt></a> and a <a href=""../apidocs/org/apache/commons/math3/filter/MeasurementModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.MeasurementModel"" api=""MeasurementModel"" kind=""class"">
    MeasurementModel 
  </clt></a>, which contain the corresponding transformation and noise covariance matrices. The parameter names used in the respective models correspond to the following names commonly used in the mathematical literature: </p> 
<ul> 
 <li>A - state transition matrix</li> 
 <li>B - control input matrix</li> 
 <li>H - measurement matrix</li> 
 <li>Q - process noise covariance matrix</li> 
 <li>R - measurement noise covariance matrix</li> 
 <li>P - error covariance matrix</li> 
</ul> 
<dl> 
 <dt>
   Initialization 
 </dt> 
 <dd>
   The following code will create a Kalman filter using the provided DefaultMeasurementModel and DefaultProcessModel classes. To support dynamically changing process and measurement noises, simply implement your own models. 
  <div class=""source""> 
   <pre>
// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// no control input
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// Q = [ 0 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });
// R = [ 0 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });

ProcessModel pm
   = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);
 			</pre> 
  </div> 
 </dd> 
 <dt>
   Iteration 
 </dt> 
 <dd>
   The following code illustrates how to perform the predict/correct cycle: 
  <div class=""source""> 
   <pre>
for (;;) {
   // predict the state estimate one time-step ahead
   // optionally provide some control input
   filter.predict();

   // obtain measurement vector z
   RealVector z = getMeasurement();

   // correct the state estimate with the latest measurement
   filter.correct(z);
   
   double[] stateEstimate = filter.getStateEstimation();
   // do something with it
}
		  </pre> 
  </div> 
 </dd> 
 <dt>
   Constant Voltage Example 
 </dt> 
 <dd>
   The following example creates a Kalman filter for a static process: a system with a constant voltage as internal state. We observe this process with an artificially imposed measurement noise of 0.1V and assume an internal process noise of 1e-5V. 
  <div class=""source""> 
   <pre>
double constantVoltage = 10d;
double measurementNoise = 0.1d;
double processNoise = 1e-5d;

// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// B = null
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// x = [ 10 ]
RealVector x = new ArrayRealVector(new double[] { constantVoltage });
// Q = [ 1e-5 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });
// P = [ 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[] { 1d });
// R = [ 0.1 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);  

// process and measurement noise vectors
RealVector pNoise = new ArrayRealVector(1);
RealVector mNoise = new ArrayRealVector(1);

RandomGenerator rand = new JDKRandomGenerator();
// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict();

    // simulate the process
    pNoise.setEntry(0, processNoise * rand.nextGaussian());

    // x = A * x + p_noise
    x = A.operate(x).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double voltage = filter.getStateEstimation()[0];
}
          </pre> 
  </div> 
 </dd> 
 <dt>
   Increasing Speed Vehicle Example 
 </dt> 
 <dd>
   The following example creates a Kalman filter for a simple linear process: a vehicle driving along a street with a velocity increasing at a constant rate. The process state is modeled as (position, velocity) and we only observe the position. A measurement noise of 10m is imposed on the simulated measurement. 
  <div class=""source""> 
   <pre>
// discrete time interval
double dt = 0.1d;
// position measurement noise (meter)
double measurementNoise = 10d;
// acceleration noise (meter/sec^2)
double accelNoise = 0.2d;

// A = [ 1 dt ]
//     [ 0  1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[][] { { 1, dt }, { 0, 1 } });
// B = [ dt^2/2 ]
//     [ dt     ]
RealMatrix B = new Array2DRowRealMatrix(new double[][] { { Math.pow(dt, 2d) / 2d }, { dt } });
// H = [ 1 0 ]
RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } });
// x = [ 0 0 ]
RealVector x = new ArrayRealVector(new double[] { 0, 0 });

RealMatrix tmp = new Array2DRowRealMatrix(new double[][] {
    { Math.pow(dt, 4d) / 4d, Math.pow(dt, 3d) / 2d },
    { Math.pow(dt, 3d) / 2d, Math.pow(dt, 2d) } });
// Q = [ dt^4/4 dt^3/2 ]
//     [ dt^3/2 dt^2   ]
RealMatrix Q = tmp.scalarMultiply(Math.pow(accelNoise, 2));
// P0 = [ 1 1 ]
//      [ 1 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } });
// R = [ measurementNoise^2 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { Math.pow(measurementNoise, 2) });

// constant control input, increase velocity by 0.1 m/s per cycle
RealVector u = new ArrayRealVector(new double[] { 0.1d });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);

RandomGenerator rand = new JDKRandomGenerator();

RealVector tmpPNoise = new ArrayRealVector(new double[] { Math.pow(dt, 2d) / 2d, dt });
RealVector mNoise = new ArrayRealVector(1);

// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict(u);

    // simulate the process
    RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian());

    // x = A * x + B * u + pNoise
    x = A.operate(x).add(B.operate(u)).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double position = filter.getStateEstimation()[0];
    double velocity = filter.getStateEstimation()[1];
}
          </pre> 
  </div> 
 </dd> 
</dl>",KalmanFilter,class
,15.2 Kalman Filter,"<h3>15.2 Kalman Filter</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/filter/KalmanFilter.html""> 
  <clt fqn=""org.apache.commons.math3.filter.KalmanFilter"" api=""KalmanFilter"" kind=""class"">
    KalmanFilter 
  </clt></a> provides a discrete-time filter to estimate a stochastic linear process.</p> 
<p>A Kalman filter is initialized with a <a href=""../apidocs/org/apache/commons/math3/filter/ProcessModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.ProcessModel"" api=""ProcessModel"" kind=""class"">
    ProcessModel 
  </clt></a> and a <a href=""../apidocs/org/apache/commons/math3/filter/MeasurementModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.MeasurementModel"" api=""MeasurementModel"" kind=""class"">
    MeasurementModel 
  </clt></a>, which contain the corresponding transformation and noise covariance matrices. The parameter names used in the respective models correspond to the following names commonly used in the mathematical literature: </p> 
<ul> 
 <li>A - state transition matrix</li> 
 <li>B - control input matrix</li> 
 <li>H - measurement matrix</li> 
 <li>Q - process noise covariance matrix</li> 
 <li>R - measurement noise covariance matrix</li> 
 <li>P - error covariance matrix</li> 
</ul> 
<dl> 
 <dt>
   Initialization 
 </dt> 
 <dd>
   The following code will create a Kalman filter using the provided DefaultMeasurementModel and DefaultProcessModel classes. To support dynamically changing process and measurement noises, simply implement your own models. 
  <div class=""source""> 
   <pre>
// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// no control input
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// Q = [ 0 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });
// R = [ 0 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });

ProcessModel pm
   = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);
 			</pre> 
  </div> 
 </dd> 
 <dt>
   Iteration 
 </dt> 
 <dd>
   The following code illustrates how to perform the predict/correct cycle: 
  <div class=""source""> 
   <pre>
for (;;) {
   // predict the state estimate one time-step ahead
   // optionally provide some control input
   filter.predict();

   // obtain measurement vector z
   RealVector z = getMeasurement();

   // correct the state estimate with the latest measurement
   filter.correct(z);
   
   double[] stateEstimate = filter.getStateEstimation();
   // do something with it
}
		  </pre> 
  </div> 
 </dd> 
 <dt>
   Constant Voltage Example 
 </dt> 
 <dd>
   The following example creates a Kalman filter for a static process: a system with a constant voltage as internal state. We observe this process with an artificially imposed measurement noise of 0.1V and assume an internal process noise of 1e-5V. 
  <div class=""source""> 
   <pre>
double constantVoltage = 10d;
double measurementNoise = 0.1d;
double processNoise = 1e-5d;

// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// B = null
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// x = [ 10 ]
RealVector x = new ArrayRealVector(new double[] { constantVoltage });
// Q = [ 1e-5 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });
// P = [ 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[] { 1d });
// R = [ 0.1 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);  

// process and measurement noise vectors
RealVector pNoise = new ArrayRealVector(1);
RealVector mNoise = new ArrayRealVector(1);

RandomGenerator rand = new JDKRandomGenerator();
// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict();

    // simulate the process
    pNoise.setEntry(0, processNoise * rand.nextGaussian());

    // x = A * x + p_noise
    x = A.operate(x).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double voltage = filter.getStateEstimation()[0];
}
          </pre> 
  </div> 
 </dd> 
 <dt>
   Increasing Speed Vehicle Example 
 </dt> 
 <dd>
   The following example creates a Kalman filter for a simple linear process: a vehicle driving along a street with a velocity increasing at a constant rate. The process state is modeled as (position, velocity) and we only observe the position. A measurement noise of 10m is imposed on the simulated measurement. 
  <div class=""source""> 
   <pre>
// discrete time interval
double dt = 0.1d;
// position measurement noise (meter)
double measurementNoise = 10d;
// acceleration noise (meter/sec^2)
double accelNoise = 0.2d;

// A = [ 1 dt ]
//     [ 0  1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[][] { { 1, dt }, { 0, 1 } });
// B = [ dt^2/2 ]
//     [ dt     ]
RealMatrix B = new Array2DRowRealMatrix(new double[][] { { Math.pow(dt, 2d) / 2d }, { dt } });
// H = [ 1 0 ]
RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } });
// x = [ 0 0 ]
RealVector x = new ArrayRealVector(new double[] { 0, 0 });

RealMatrix tmp = new Array2DRowRealMatrix(new double[][] {
    { Math.pow(dt, 4d) / 4d, Math.pow(dt, 3d) / 2d },
    { Math.pow(dt, 3d) / 2d, Math.pow(dt, 2d) } });
// Q = [ dt^4/4 dt^3/2 ]
//     [ dt^3/2 dt^2   ]
RealMatrix Q = tmp.scalarMultiply(Math.pow(accelNoise, 2));
// P0 = [ 1 1 ]
//      [ 1 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } });
// R = [ measurementNoise^2 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { Math.pow(measurementNoise, 2) });

// constant control input, increase velocity by 0.1 m/s per cycle
RealVector u = new ArrayRealVector(new double[] { 0.1d });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);

RandomGenerator rand = new JDKRandomGenerator();

RealVector tmpPNoise = new ArrayRealVector(new double[] { Math.pow(dt, 2d) / 2d, dt });
RealVector mNoise = new ArrayRealVector(1);

// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict(u);

    // simulate the process
    RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian());

    // x = A * x + B * u + pNoise
    x = A.operate(x).add(B.operate(u)).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double position = filter.getStateEstimation()[0];
    double velocity = filter.getStateEstimation()[1];
}
          </pre> 
  </div> 
 </dd> 
</dl>",ProcessModel,class
,15.2 Kalman Filter,"<h3>15.2 Kalman Filter</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/filter/KalmanFilter.html""> 
  <clt fqn=""org.apache.commons.math3.filter.KalmanFilter"" api=""KalmanFilter"" kind=""class"">
    KalmanFilter 
  </clt></a> provides a discrete-time filter to estimate a stochastic linear process.</p> 
<p>A Kalman filter is initialized with a <a href=""../apidocs/org/apache/commons/math3/filter/ProcessModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.ProcessModel"" api=""ProcessModel"" kind=""class"">
    ProcessModel 
  </clt></a> and a <a href=""../apidocs/org/apache/commons/math3/filter/MeasurementModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.MeasurementModel"" api=""MeasurementModel"" kind=""class"">
    MeasurementModel 
  </clt></a>, which contain the corresponding transformation and noise covariance matrices. The parameter names used in the respective models correspond to the following names commonly used in the mathematical literature: </p> 
<ul> 
 <li>A - state transition matrix</li> 
 <li>B - control input matrix</li> 
 <li>H - measurement matrix</li> 
 <li>Q - process noise covariance matrix</li> 
 <li>R - measurement noise covariance matrix</li> 
 <li>P - error covariance matrix</li> 
</ul> 
<dl> 
 <dt>
   Initialization 
 </dt> 
 <dd>
   The following code will create a Kalman filter using the provided DefaultMeasurementModel and DefaultProcessModel classes. To support dynamically changing process and measurement noises, simply implement your own models. 
  <div class=""source""> 
   <pre>
// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// no control input
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// Q = [ 0 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });
// R = [ 0 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });

ProcessModel pm
   = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);
 			</pre> 
  </div> 
 </dd> 
 <dt>
   Iteration 
 </dt> 
 <dd>
   The following code illustrates how to perform the predict/correct cycle: 
  <div class=""source""> 
   <pre>
for (;;) {
   // predict the state estimate one time-step ahead
   // optionally provide some control input
   filter.predict();

   // obtain measurement vector z
   RealVector z = getMeasurement();

   // correct the state estimate with the latest measurement
   filter.correct(z);
   
   double[] stateEstimate = filter.getStateEstimation();
   // do something with it
}
		  </pre> 
  </div> 
 </dd> 
 <dt>
   Constant Voltage Example 
 </dt> 
 <dd>
   The following example creates a Kalman filter for a static process: a system with a constant voltage as internal state. We observe this process with an artificially imposed measurement noise of 0.1V and assume an internal process noise of 1e-5V. 
  <div class=""source""> 
   <pre>
double constantVoltage = 10d;
double measurementNoise = 0.1d;
double processNoise = 1e-5d;

// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// B = null
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// x = [ 10 ]
RealVector x = new ArrayRealVector(new double[] { constantVoltage });
// Q = [ 1e-5 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });
// P = [ 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[] { 1d });
// R = [ 0.1 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);  

// process and measurement noise vectors
RealVector pNoise = new ArrayRealVector(1);
RealVector mNoise = new ArrayRealVector(1);

RandomGenerator rand = new JDKRandomGenerator();
// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict();

    // simulate the process
    pNoise.setEntry(0, processNoise * rand.nextGaussian());

    // x = A * x + p_noise
    x = A.operate(x).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double voltage = filter.getStateEstimation()[0];
}
          </pre> 
  </div> 
 </dd> 
 <dt>
   Increasing Speed Vehicle Example 
 </dt> 
 <dd>
   The following example creates a Kalman filter for a simple linear process: a vehicle driving along a street with a velocity increasing at a constant rate. The process state is modeled as (position, velocity) and we only observe the position. A measurement noise of 10m is imposed on the simulated measurement. 
  <div class=""source""> 
   <pre>
// discrete time interval
double dt = 0.1d;
// position measurement noise (meter)
double measurementNoise = 10d;
// acceleration noise (meter/sec^2)
double accelNoise = 0.2d;

// A = [ 1 dt ]
//     [ 0  1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[][] { { 1, dt }, { 0, 1 } });
// B = [ dt^2/2 ]
//     [ dt     ]
RealMatrix B = new Array2DRowRealMatrix(new double[][] { { Math.pow(dt, 2d) / 2d }, { dt } });
// H = [ 1 0 ]
RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } });
// x = [ 0 0 ]
RealVector x = new ArrayRealVector(new double[] { 0, 0 });

RealMatrix tmp = new Array2DRowRealMatrix(new double[][] {
    { Math.pow(dt, 4d) / 4d, Math.pow(dt, 3d) / 2d },
    { Math.pow(dt, 3d) / 2d, Math.pow(dt, 2d) } });
// Q = [ dt^4/4 dt^3/2 ]
//     [ dt^3/2 dt^2   ]
RealMatrix Q = tmp.scalarMultiply(Math.pow(accelNoise, 2));
// P0 = [ 1 1 ]
//      [ 1 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } });
// R = [ measurementNoise^2 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { Math.pow(measurementNoise, 2) });

// constant control input, increase velocity by 0.1 m/s per cycle
RealVector u = new ArrayRealVector(new double[] { 0.1d });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);

RandomGenerator rand = new JDKRandomGenerator();

RealVector tmpPNoise = new ArrayRealVector(new double[] { Math.pow(dt, 2d) / 2d, dt });
RealVector mNoise = new ArrayRealVector(1);

// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict(u);

    // simulate the process
    RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian());

    // x = A * x + B * u + pNoise
    x = A.operate(x).add(B.operate(u)).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double position = filter.getStateEstimation()[0];
    double velocity = filter.getStateEstimation()[1];
}
          </pre> 
  </div> 
 </dd> 
</dl>",MeasurementModel,class
,16.3 Hierarchies,"<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>",MathIllegalArgumentException,class
,16.3 Hierarchies,"<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>",MathIllegalStateException,class
,16.3 Hierarchies,"<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>",MathArithmeticException,class
,16.3 Hierarchies,"<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>",MathUnsupportedOperationException,class
,16.4 Features,"<h3>16.4 Features</h3> 
<ul> 
 <li>Localization <p> The detailed error messages (i.e. the string returned by the <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html#getLocalizedMessage()""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage"" api=""getLocalizedMessage"" kind=""class"">
      getLocalizedMessage 
    </clt></a> method) can be localized. However, besides the American/English default, French is the only language for which a translation resource is available. </p> </li> 
 <li>Exception &quot;context&quot; <p> Every exception generated by Commons Math implements the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider"" api=""ExceptionContextProvider"" kind=""class"">
      ExceptionContextProvider 
    </clt></a> interface. A call to the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html#getContext""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider.getContext"" api=""getContext"" kind=""class"">
      getContext 
    </clt></a> method will return the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContext.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext"" api=""ExceptionContext"" kind=""class"">
      ExceptionContext 
    </clt></a> instance stored in the exception, which the user can further customize by adding messages and/or any object. </p> </li> 
</ul>",getLocalizedMessage,class
,16.4 Features,"<h3>16.4 Features</h3> 
<ul> 
 <li>Localization <p> The detailed error messages (i.e. the string returned by the <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html#getLocalizedMessage()""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage"" api=""getLocalizedMessage"" kind=""class"">
      getLocalizedMessage 
    </clt></a> method) can be localized. However, besides the American/English default, French is the only language for which a translation resource is available. </p> </li> 
 <li>Exception &quot;context&quot; <p> Every exception generated by Commons Math implements the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider"" api=""ExceptionContextProvider"" kind=""class"">
      ExceptionContextProvider 
    </clt></a> interface. A call to the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html#getContext""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider.getContext"" api=""getContext"" kind=""class"">
      getContext 
    </clt></a> method will return the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContext.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext"" api=""ExceptionContext"" kind=""class"">
      ExceptionContext 
    </clt></a> instance stored in the exception, which the user can further customize by adding messages and/or any object. </p> </li> 
</ul>",ExceptionContextProvider,class
,16.4 Features,"<h3>16.4 Features</h3> 
<ul> 
 <li>Localization <p> The detailed error messages (i.e. the string returned by the <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html#getLocalizedMessage()""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage"" api=""getLocalizedMessage"" kind=""class"">
      getLocalizedMessage 
    </clt></a> method) can be localized. However, besides the American/English default, French is the only language for which a translation resource is available. </p> </li> 
 <li>Exception &quot;context&quot; <p> Every exception generated by Commons Math implements the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider"" api=""ExceptionContextProvider"" kind=""class"">
      ExceptionContextProvider 
    </clt></a> interface. A call to the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html#getContext""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider.getContext"" api=""getContext"" kind=""class"">
      getContext 
    </clt></a> method will return the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContext.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext"" api=""ExceptionContext"" kind=""class"">
      ExceptionContext 
    </clt></a> instance stored in the exception, which the user can further customize by adding messages and/or any object. </p> </li> 
</ul>",getContext,class
,16.4 Features,"<h3>16.4 Features</h3> 
<ul> 
 <li>Localization <p> The detailed error messages (i.e. the string returned by the <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html#getLocalizedMessage()""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage"" api=""getLocalizedMessage"" kind=""class"">
      getLocalizedMessage 
    </clt></a> method) can be localized. However, besides the American/English default, French is the only language for which a translation resource is available. </p> </li> 
 <li>Exception &quot;context&quot; <p> Every exception generated by Commons Math implements the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider"" api=""ExceptionContextProvider"" kind=""class"">
      ExceptionContextProvider 
    </clt></a> interface. A call to the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html#getContext""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider.getContext"" api=""getContext"" kind=""class"">
      getContext 
    </clt></a> method will return the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContext.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext"" api=""ExceptionContext"" kind=""class"">
      ExceptionContext 
    </clt></a> instance stored in the exception, which the user can further customize by adding messages and/or any object. </p> </li> 
</ul>",ExceptionContext,class
