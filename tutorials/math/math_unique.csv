"file_path";"xpath";"content";"sentence";"paragraph";"kind";"simple_name";"fqn"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[1]";"Fraction";"Fraction and";"Fraction and 
          BigFraction provide fraction number type that forms the basis for
          the fraction functionality found in Commons-Math. The former one can be
          used for fractions whose numerators and denominators are small enough
          to fit in an int (taking care of intermediate values) while the second
          class should be used when there is a risk the numerator and denominator
          grow very large.";"unknown";"Fraction";"org.apache.commons.math3.fraction.Fraction"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[2]";"BigFraction";"BigFraction provide fraction number type that forms the basis for";"Fraction and 
          BigFraction provide fraction number type that forms the basis for
          the fraction functionality found in Commons-Math. The former one can be
          used for fractions whose numerators and denominators are small enough
          to fit in an int (taking care of intermediate values) while the second
          class should be used when there is a risk the numerator and denominator
          grow very large.";"class";"BigFraction";"org.apache.commons.math3.fraction.BigFraction"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[2]/p[4]/tt[1]";"Fraction";"The Fraction class provides many unary and binary";"The Fraction class provides many unary and binary
          fraction operations.  These operations provide the means to add,
          subtract, multiple and, divide fractions along with other functions similar to the real number functions found in
          java.math.BigDecimal:";"unknown";"Fraction";"org.apache.commons.math3.fraction.Fraction"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/p[3]/a";"GoalType";"GoalType which has only two values: MAXIMIZE and MINIMIZE.";"The type of goal, i.e. minimization or maximization, is defined by the enumerated
        
        GoalType which has only two values: MAXIMIZE and MINIMIZE.";"class";"GoalType";"org.apache.commons.math3.optimization.GoalType"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[3]/p[1]/tt[1]";"Fraction";"Fraction instances can be converted to and from strings";"Fraction instances can be converted to and from strings
          using the
          FractionFormat class. FractionFormat is a
          java.text.Format extension and, as such, is used like other
          formatting objects (e.g. java.text.SimpleDateFormat):";"unknown";"Fraction";"org.apache.commons.math3.fraction.Fraction"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/p[3]/tt[1]";"MAXIMIZE";"GoalType which has only two values: MAXIMIZE and MINIMIZE.";"The type of goal, i.e. minimization or maximization, is defined by the enumerated
        
        GoalType which has only two values: MAXIMIZE and MINIMIZE.";"field";"MAXIMIZE";"org.apache.commons.math3.optimization.GoalType.MAXIMIZE"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[3]/p[1]/a";"FractionFormat";"FractionFormat class.";"Fraction instances can be converted to and from strings
          using the
          FractionFormat class. FractionFormat is a
          java.text.Format extension and, as such, is used like other
          formatting objects (e.g. java.text.SimpleDateFormat):";"class";"FractionFormat";"org.apache.commons.math3.fraction.FractionFormat"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[1]/p[3]/tt";"RandomGenerator";"a RandomGenerator instance as a parameter.";"Sections 2.2-2.6 below show how to use the commons math API to generate
     different kinds of random data.  The examples all use the default
     JDK-supplied PRNG.  PRNG pluggability is covered in 2.7.  The only 
     modification required to the examples to use alternative PRNGs is to
     replace the argumentless constructor calls with invocations including
     a RandomGenerator instance as a parameter.";"class";"RandomGenerator";"org.apache.commons.math3.random.RandomGenerator"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/p[3]/tt[2]";"MINIMIZE";"GoalType which has only two values: MAXIMIZE and MINIMIZE.";"The type of goal, i.e. minimization or maximization, is defined by the enumerated
        
        GoalType which has only two values: MAXIMIZE and MINIMIZE.";"field";"MINIMIZE";"org.apache.commons.math3.optimization.GoalType.MINIMIZE"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/p/a";"RandomData";"RandomData interface defines methods for generating random sequences";"The 
    RandomData interface defines methods for generating random sequences
    of numbers. The API contracts of these methods use the following concepts:";"class";"RandomData";"org.apache.commons.math3.random.RandomData"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[3]/p[1]/tt[2]";"FractionFormat";"FractionFormat is a";"Fraction instances can be converted to and from strings
          using the
          FractionFormat class. FractionFormat is a
          java.text.Format extension and, as such, is used like other
          formatting objects (e.g. java.text.SimpleDateFormat):";"class";"FractionFormat";"org.apache.commons.math3.fraction.FractionFormat"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/ul[2]/li[1]/a[1]";"UnivariateOptimizer";"UnivariateOptimizer for";"UnivariateOptimizer for 
              univariate real functions";"class";"UnivariateOptimizer";"org.apache.commons.math3.optim.univariate.UnivariateOptimizer"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[2]/p/a";"Erf";"Erf contains several useful functions involving the Error Function, Erf.";"Erf contains several useful functions involving the Error Function, Erf.";"unknown";"Erf";"org.apache.commons.math3.special.Erf"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/p/a/tt";"Gamma";"Gamma";"Gamma";"unknown";"Gamma";"org.apache.commons.math3.special.Gamma"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/ul[2]/li[2]/a[1]";"MultivariateOptimizer";"MultivariateOptimizer for";"MultivariateOptimizer for 
              multivariate real functions";"class";"MultivariateOptimizer";"org.apache.commons.math3.optimization.MultivariateOptimizer"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[1]/p/tt";"Gamma.gamma(x)";"Gamma.gamma(x) computes the Gamma function, Γ(x) (see MathWorld, DLMF).";"Gamma.gamma(x) computes the Gamma function, Γ(x) (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System.";"class";"Gamma";"org.apache.commons.math3.special.Gamma"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[1]/p/tt";"Gamma.gamma(x)";"Gamma.gamma(x) computes the Gamma function, Γ(x) (see MathWorld, DLMF).";"Gamma.gamma(x) computes the Gamma function, Γ(x) (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System.";"method";"gamma";"org.apache.commons.math3.special.Gamma.gamma"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[3]/p[2]/tt[2]";"FractionFormat";"a FractionFormat.";"To customize the formatting output, one or two
          java.text.NumberFormat instances can be used to construct
          a FractionFormat.  These number formats control the
          formatting of the numerator and denominator of the fraction:";"class";"FractionFormat";"org.apache.commons.math3.fraction.FractionFormat"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/ul[2]/li[3]/a[1]";"DifferentiableMultivariateOptimizer";"DifferentiableMultivariateOptimizer for";"DifferentiableMultivariateOptimizer for 
              differentiable multivariate real functions";"class";"DifferentiableMultivariateOptimizer";"org.apache.commons.math3.optimization.DifferentiableMultivariateOptimizer"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[1]/a[4]";"RandomDataImpl";"RandomDataImpl describes the algorithms used to generate";"There is no such thing as a single ""random number.""  What can be
    generated  are sequences of numbers that appear to be random.  When
    using the built-in JDK function Math.random(), sequences of 
    values generated follow the 
    
    Uniform Distribution, which means that the values are evenly spread
    over the interval  between 0 and 1, with no sub-interval having a greater
    probability of containing generated values than any other interval of the
    same length.  The mathematical concept of a
    
    probability distribution basically amounts to asserting that different
    ranges in the set  of possible values of a random variable have
    different probabilities of containing the value.  Commons Math supports
    generating random sequences from each of the distributions in the
    
    distributions package.
    The javadoc for the nextXxx methods in 
    
    RandomDataImpl describes the algorithms used to generate
    random deviates.";"class";"RandomDataImpl";"org.apache.commons.math3.random.RandomDataImpl"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[3]/p[3]/tt[1]";"FractionFormat";"FractionFormat.";"Formatting's inverse operation, parsing, can also be performed by
          FractionFormat.  To parse a fraction from a string,
          simply call the parse method:";"class";"FractionFormat";"org.apache.commons.math3.fraction.FractionFormat"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[2]/tt[1]";"RandomDataImpl";"nextSecureXxx methods in the RandomDataImpl implementation of";"It is possible for a sequence of numbers to appear random, but
    nonetheless to be predictable based on the algorithm used to generate the
    sequence. If in addition to randomness, strong unpredictability is
    required, it is best to use a  
    
    secure random number generator to generate values (or strings). The
    nextSecureXxx methods in the RandomDataImpl implementation of
    the RandomData interface use the JDK SecureRandom
    PRNG to generate cryptographically secure sequences.  The 
    setSecureAlgorithm method allows you to change the underlying
    PRNG. These methods are much slower than the corresponding
    ""non-secure"" versions, so they should only be used when cryptographic
    security is required.  The ISAACRandom class implements a fast
    cryptographically secure pseudorandom numbers generator.";"class";"RandomDataImpl";"org.apache.commons.math3.random.RandomDataImpl"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/ul[2]/li[4]/a[1]";"DifferentiableMultivariateVectorOptimizer";"DifferentiableMultivariateVectorOptimizer for";"DifferentiableMultivariateVectorOptimizer for 
              differentiable multivariate vectorial functions";"class";"DifferentiableMultivariateVectorOptimizer";"org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[2]/tt[2]";"RandomData";"the RandomData interface use the JDK SecureRandom";"It is possible for a sequence of numbers to appear random, but
    nonetheless to be predictable based on the algorithm used to generate the
    sequence. If in addition to randomness, strong unpredictability is
    required, it is best to use a  
    
    secure random number generator to generate values (or strings). The
    nextSecureXxx methods in the RandomDataImpl implementation of
    the RandomData interface use the JDK SecureRandom
    PRNG to generate cryptographically secure sequences.  The 
    setSecureAlgorithm method allows you to change the underlying
    PRNG. These methods are much slower than the corresponding
    ""non-secure"" versions, so they should only be used when cryptographic
    security is required.  The ISAACRandom class implements a fast
    cryptographically secure pseudorandom numbers generator.";"class";"RandomData";"org.apache.commons.math3.random.RandomData"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[2]/tt[4]";"setSecureAlgorithm";"setSecureAlgorithm method allows you to change the underlying";"It is possible for a sequence of numbers to appear random, but
    nonetheless to be predictable based on the algorithm used to generate the
    sequence. If in addition to randomness, strong unpredictability is
    required, it is best to use a  
    
    secure random number generator to generate values (or strings). The
    nextSecureXxx methods in the RandomDataImpl implementation of
    the RandomData interface use the JDK SecureRandom
    PRNG to generate cryptographically secure sequences.  The 
    setSecureAlgorithm method allows you to change the underlying
    PRNG. These methods are much slower than the corresponding
    ""non-secure"" versions, so they should only be used when cryptographic
    security is required.  The ISAACRandom class implements a fast
    cryptographically secure pseudorandom numbers generator.";"class";"setSecureAlgorithm";"org.apache.commons.math3.random.RandomDataImpl.setSecureAlgorithm"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[2]/tt[5]";"ISAACRandom";"The ISAACRandom class implements a fast";"It is possible for a sequence of numbers to appear random, but
    nonetheless to be predictable based on the algorithm used to generate the
    sequence. If in addition to randomness, strong unpredictability is
    required, it is best to use a  
    
    secure random number generator to generate values (or strings). The
    nextSecureXxx methods in the RandomDataImpl implementation of
    the RandomData interface use the JDK SecureRandom
    PRNG to generate cryptographically secure sequences.  The 
    setSecureAlgorithm method allows you to change the underlying
    PRNG. These methods are much slower than the corresponding
    ""non-secure"" versions, so they should only be used when cryptographic
    security is required.  The ISAACRandom class implements a fast
    cryptographically secure pseudorandom numbers generator.";"class";"ISAACRandom";"org.apache.commons.math3.random.ISAACRandom"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[3]/tt[1]";"RandomDataImpl";"By default, the implementation provided in RandomDataImpl";"By default, the implementation provided in RandomDataImpl
    uses the JDK-provided PRNG.  Like most other PRNGs, the JDK generator
    generates sequences of random numbers based on an initial ""seed value"".
    For the non-secure methods, starting with the same seed always produces the
    same sequence of values.  Secure sequences started with the same seeds will
    diverge. When a new RandomDataImpl is created, the underlying
    random number generators are not initialized.  The first
    call to a data generation method, or to a  reSeed() method
    initializes the appropriate generator.  If you do not explicitly seed the
    generator, it is by default seeded with the current time in milliseconds.
    Therefore, to generate sequences of random data values, you should always
    instantiate one  RandomDataImpl and use it
    repeatedly instead of creating new instances for subsequent values in the
    sequence.  For example, the following will generate a random sequence of 50
    long integers between 1 and 1,000,000, using the current time in
    milliseconds as the seed for the JDK PRNG:
    
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i < 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will not in general produce a good random sequence, since the
    PRNG is reseeded each time through the loop with the current time in
    milliseconds:
    
for (int i = 0; i < 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce the same random sequence each time it is
    executed:
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce a different random sequence each time it is
     executed. 
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i < 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}";"class";"RandomDataImpl";"org.apache.commons.math3.random.RandomDataImpl"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/p[5]/a[3]";"LeastSquaresConverter";"LeastSquaresConverter helper class.";"Despite there are only four types of supported optimizers, it is possible to optimize
        a transform a 
        non-differentiable multivariate vectorial function by converting it to a 
        non-differentiable multivariate real function thanks to the 
        LeastSquaresConverter helper class. The transformed function can be optimized using
        any implementation of the 
        MultivariateOptimizer interface.";"class";"LeastSquaresConverter";"org.apache.commons.math3.optimization.LeastSquaresConverter"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[3]/tt[2]";"RandomDataImpl";"When a new RandomDataImpl is created, the underlying";"By default, the implementation provided in RandomDataImpl
    uses the JDK-provided PRNG.  Like most other PRNGs, the JDK generator
    generates sequences of random numbers based on an initial ""seed value"".
    For the non-secure methods, starting with the same seed always produces the
    same sequence of values.  Secure sequences started with the same seeds will
    diverge. When a new RandomDataImpl is created, the underlying
    random number generators are not initialized.  The first
    call to a data generation method, or to a  reSeed() method
    initializes the appropriate generator.  If you do not explicitly seed the
    generator, it is by default seeded with the current time in milliseconds.
    Therefore, to generate sequences of random data values, you should always
    instantiate one  RandomDataImpl and use it
    repeatedly instead of creating new instances for subsequent values in the
    sequence.  For example, the following will generate a random sequence of 50
    long integers between 1 and 1,000,000, using the current time in
    milliseconds as the seed for the JDK PRNG:
    
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i < 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will not in general produce a good random sequence, since the
    PRNG is reseeded each time through the loop with the current time in
    milliseconds:
    
for (int i = 0; i < 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce the same random sequence each time it is
    executed:
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce a different random sequence each time it is
     executed. 
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i < 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}";"class";"RandomDataImpl";"org.apache.commons.math3.random.RandomDataImpl"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[1]/p[5]/a[4]";"MultivariateOptimizer";"MultivariateOptimizer interface.";"Despite there are only four types of supported optimizers, it is possible to optimize
        a transform a 
        non-differentiable multivariate vectorial function by converting it to a 
        non-differentiable multivariate real function thanks to the 
        LeastSquaresConverter helper class. The transformed function can be optimized using
        any implementation of the 
        MultivariateOptimizer interface.";"class";"MultivariateOptimizer";"org.apache.commons.math3.optimization.MultivariateOptimizer"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[2]/p[1]/a";"UnivariateOptimizer";"UnivariateOptimizer is used to find the minimal values of a univariate real-valued";"A 
          UnivariateOptimizer is used to find the minimal values of a univariate real-valued
          function f.";"class";"UnivariateOptimizer";"org.apache.commons.math3.optim.univariate.UnivariateOptimizer"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[3]/tt[4]";"RandomDataImpl";"instantiate one  RandomDataImpl and use it";"By default, the implementation provided in RandomDataImpl
    uses the JDK-provided PRNG.  Like most other PRNGs, the JDK generator
    generates sequences of random numbers based on an initial ""seed value"".
    For the non-secure methods, starting with the same seed always produces the
    same sequence of values.  Secure sequences started with the same seeds will
    diverge. When a new RandomDataImpl is created, the underlying
    random number generators are not initialized.  The first
    call to a data generation method, or to a  reSeed() method
    initializes the appropriate generator.  If you do not explicitly seed the
    generator, it is by default seeded with the current time in milliseconds.
    Therefore, to generate sequences of random data values, you should always
    instantiate one  RandomDataImpl and use it
    repeatedly instead of creating new instances for subsequent values in the
    sequence.  For example, the following will generate a random sequence of 50
    long integers between 1 and 1,000,000, using the current time in
    milliseconds as the seed for the JDK PRNG:
    
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i < 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will not in general produce a good random sequence, since the
    PRNG is reseeded each time through the loop with the current time in
    milliseconds:
    
for (int i = 0; i < 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce the same random sequence each time it is
    executed:
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce a different random sequence each time it is
     executed. 
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i < 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}";"class";"RandomDataImpl";"org.apache.commons.math3.random.RandomDataImpl"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[2]/p/tt";"Gamma.logGamma(x)";"Gamma.logGamma(x) computes the natural logarithm of the Gamma function, log Γ(x), for x > 0 (see MathWorld, DLMF).";"Gamma.logGamma(x) computes the natural logarithm of the Gamma function, log Γ(x), for x > 0 (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System.";"class";"Gamma";"org.apache.commons.math3.special.Gamma"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[2]/p/tt";"Gamma.logGamma(x)";"Gamma.logGamma(x) computes the natural logarithm of the Gamma function, log Γ(x), for x > 0 (see MathWorld, DLMF).";"Gamma.logGamma(x) computes the natural logarithm of the Gamma function, log Γ(x), for x > 0 (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System.";"method";"logGamma";"org.apache.commons.math3.special.Gamma.logGamma"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[3]/p[1]/a[1]";"UncorrelatedRandomVectorGenerator";"UncorrelatedRandomVectorGenerator class simplifies this";"Some algorithms require random vectors instead of random scalars. When the
    components of these vectors are uncorrelated, they may be generated simply
    one at a time and packed together in the vector. The 
    UncorrelatedRandomVectorGenerator class simplifies this
    process by setting the mean and deviation of each component once and
    generating complete vectors. When the components are correlated however,
    generating them is much more difficult. The 
    CorrelatedRandomVectorGenerator class provides this service. In this
    case, the user must set up a complete covariance matrix instead of a simple
    standard deviations vector. This matrix gathers both the variance and the
    correlation information of the probability law.";"class";"UncorrelatedRandomVectorGenerator";"org.apache.commons.math3.random.UncorrelatedRandomVectorGenerator"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[2]";"optimize";"finding algorithms is replaced by optimize methods.";"These algorithms usage is very similar to root-finding algorithms usage explained
          in the analysis package. The main difference is that the solve methods in root
          finding algorithms is replaced by optimize methods.";"unknown";"optimize";"org.apache.commons.math3.optim.univariate.UnivariateOptimizer.optimize"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[3]/p[1]/a[2]";"CorrelatedRandomVectorGenerator";"CorrelatedRandomVectorGenerator class provides this service.";"Some algorithms require random vectors instead of random scalars. When the
    components of these vectors are uncorrelated, they may be generated simply
    one at a time and packed together in the vector. The 
    UncorrelatedRandomVectorGenerator class simplifies this
    process by setting the mean and deviation of each component once and
    generating complete vectors. When the components are correlated however,
    generating them is much more difficult. The 
    CorrelatedRandomVectorGenerator class provides this service. In this
    case, the user must set up a complete covariance matrix instead of a simple
    standard deviations vector. This matrix gathers both the variance and the
    correlation information of the probability law.";"class";"CorrelatedRandomVectorGenerator";"org.apache.commons.math3.random.CorrelatedRandomVectorGenerator"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[3]/p[3]/a[1]";"UniformRandomGenerator";"UniformRandomGenerator";"In addition to multivariate normal distributions, correlated vectors from multivariate uniform
    distributions can be generated by creating a
    UniformRandomGenerator
    in place of the 
    GaussianRandomGenerator above.  More generally, any
    NormalizedRandomGenerator
    may be used.";"class";"UniformRandomGenerator";"org.apache.commons.math3.random.UniformRandomGenerator"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[3]/p[3]/tt";"GaussianRandomGenerator";"GaussianRandomGenerator above.";"In addition to multivariate normal distributions, correlated vectors from multivariate uniform
    distributions can be generated by creating a
    UniformRandomGenerator
    in place of the 
    GaussianRandomGenerator above.  More generally, any
    NormalizedRandomGenerator
    may be used.";"class";"GaussianRandomGenerator";"org.apache.commons.math3.random.GaussianRandomGenerator"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[3]/p/tt";"Gamma.regularizedGammaP(a, x)";"Gamma.regularizedGammaP(a, x) computes the value of the regularized Gamma function, P(a, x) (see MathWorld).";"Gamma.regularizedGammaP(a, x) computes the value of the regularized Gamma function, P(a, x) (see MathWorld).";"class";"Gamma";"org.apache.commons.math3.special.Gamma"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[3]/p[3]/a[2]";"NormalizedRandomGenerator";"NormalizedRandomGenerator";"In addition to multivariate normal distributions, correlated vectors from multivariate uniform
    distributions can be generated by creating a
    UniformRandomGenerator
    in place of the 
    GaussianRandomGenerator above.  More generally, any
    NormalizedRandomGenerator
    may be used.";"class";"NormalizedRandomGenerator";"org.apache.commons.math3.random.NormalizedRandomGenerator"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[3]/p/tt";"Gamma.regularizedGammaP(a, x)";"Gamma.regularizedGammaP(a, x) computes the value of the regularized Gamma function, P(a, x) (see MathWorld).";"Gamma.regularizedGammaP(a, x) computes the value of the regularized Gamma function, P(a, x) (see MathWorld).";"method";"regularizedGammaP";"org.apache.commons.math3.special.Gamma.regularizedGammaP"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[4]/p/tt[1]";"nextHexString";"The methods nextHexString and nextSecureHexString";"The methods nextHexString and nextSecureHexString
    can be used to generate random strings of hexadecimal characters.  Both
    of these methods produce sequences of strings with good dispersion
    properties.  The difference between the two methods is that the second is
    cryptographically secure.  Specifically, the implementation of 
    nextHexString(n) in RandomDataImpl uses the
    following simple algorithm to generate a string of n hex digits:";"class";"nextHexString";"org.apache.commons.math3.random.RandomDataImpl.nextHexString"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[4]/p/a";"Beta";"Beta contains several useful functions involving the Beta Function.";"Beta contains several useful functions involving the Beta Function.";"unknown";"Beta";"org.apache.commons.math3.special.Beta"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[4]/p/tt[2]";"nextSecureHexString";"The methods nextHexString and nextSecureHexString";"The methods nextHexString and nextSecureHexString
    can be used to generate random strings of hexadecimal characters.  Both
    of these methods produce sequences of strings with good dispersion
    properties.  The difference between the two methods is that the second is
    cryptographically secure.  Specifically, the implementation of 
    nextHexString(n) in RandomDataImpl uses the
    following simple algorithm to generate a string of n hex digits:";"class";"nextSecureHexString";"org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[4]/p[5]/a[1]";"MultivariateFunctionMappingAdapter";"MultivariateFunctionMappingAdapter and";"The first two simplex-based methods do not handle simple bounds constraints by themselves.
          However there are two adapters(
          MultivariateFunctionMappingAdapter and 
          MultivariateFunctionPenaltyAdapter) that can be used to wrap the user function in
          such a way the wrapped function is unbounded and can be used with these optimizers, despite
          the fact the underlying function is still bounded and will be called only with feasible
          points that fulfill the constraints. Note however that using these adapters are only a
          poor man solutions to simple bounds optimization constraints. Better solutions are to use an
          optimizer that directly supports simple bounds. Some caveats of the mapping adapter
          solution are that";"class";"MultivariateFunctionMappingAdapter";"org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[4]/div[1]/p/tt";"Beta.logBeta(a, b)";"Beta.logBeta(a, b) computes the value of the natural logarithm of the Beta function, log B(a, b).";"Beta.logBeta(a, b) computes the value of the natural logarithm of the Beta function, log B(a, b). (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System.";"class";"Beta";"org.apache.commons.math3.special.Beta"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[4]/div[1]/p/tt";"Beta.logBeta(a, b)";"Beta.logBeta(a, b) computes the value of the natural logarithm of the Beta function, log B(a, b).";"Beta.logBeta(a, b) computes the value of the natural logarithm of the Beta function, log B(a, b). (see MathWorld, DLMF). The accuracy of the Commons-Math implementation is assessed by comparaison with high precision values computed with the Maxima Computer Algebra System.";"method";"logBeta";"org.apache.commons.math3.special.Beta.logBeta"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[4]/p/tt[3]";"nextHexString(n)";"nextHexString(n) in RandomDataImpl uses the";"The methods nextHexString and nextSecureHexString
    can be used to generate random strings of hexadecimal characters.  Both
    of these methods produce sequences of strings with good dispersion
    properties.  The difference between the two methods is that the second is
    cryptographically secure.  Specifically, the implementation of 
    nextHexString(n) in RandomDataImpl uses the
    following simple algorithm to generate a string of n hex digits:";"method";"nextHexString";"org.apache.commons.math3.random.RandomDataImpl.nextHexString"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[4]/p[5]/a[2]";"MultivariateFunctionPenaltyAdapter";"MultivariateFunctionPenaltyAdapter) that can be used to wrap the user function in";"The first two simplex-based methods do not handle simple bounds constraints by themselves.
          However there are two adapters(
          MultivariateFunctionMappingAdapter and 
          MultivariateFunctionPenaltyAdapter) that can be used to wrap the user function in
          such a way the wrapped function is unbounded and can be used with these optimizers, despite
          the fact the underlying function is still bounded and will be called only with feasible
          points that fulfill the constraints. Note however that using these adapters are only a
          poor man solutions to simple bounds optimization constraints. Better solutions are to use an
          optimizer that directly supports simple bounds. Some caveats of the mapping adapter
          solution are that";"class";"MultivariateFunctionPenaltyAdapter";"org.apache.commons.math3.optimization.direct.MultivariateFunctionPenaltyAdapter"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[4]/p/tt[4]";"RandomDataImpl";"nextHexString(n) in RandomDataImpl uses the";"The methods nextHexString and nextSecureHexString
    can be used to generate random strings of hexadecimal characters.  Both
    of these methods produce sequences of strings with good dispersion
    properties.  The difference between the two methods is that the second is
    cryptographically secure.  Specifically, the implementation of 
    nextHexString(n) in RandomDataImpl uses the
    following simple algorithm to generate a string of n hex digits:";"class";"RandomDataImpl";"org.apache.commons.math3.random.RandomDataImpl"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[4]/tt[1]";"RandomDataImpl";"The RandomDataImpl implementation of the ""secure"" version,";"2.4 Random Strings
    
    The methods nextHexString and nextSecureHexString
    can be used to generate random strings of hexadecimal characters.  Both
    of these methods produce sequences of strings with good dispersion
    properties.  The difference between the two methods is that the second is
    cryptographically secure.  Specifically, the implementation of 
    nextHexString(n) in RandomDataImpl uses the
    following simple algorithm to generate a string of n hex digits:
    n/2+1 binary bytes are generated using the underlying Random
    Each binary byte is translated into 2 hex digits
    The RandomDataImpl implementation of the ""secure"" version, 
    nextSecureHexString generates hex characters in 40-byte
    ""chunks"" using a 3-step process:
    20 random bytes are generated using the underlying 
    SecureRandom.
    SHA-1 hash is applied to yield a 20-byte binary digest.
    Each byte of the binary digest is converted to 2 hex digits
    Similarly to the secure random number generation methods, 
    nextSecureHexString is much slower than
    the non-secure version.  It should be used only for applications such as 
    generating unique session or transaction ids where predictability of
    subsequent ids based on observation of previous values is a security
    concern.  If all that is needed is an even distribution of hex characters
    in the generated strings, the non-secure method should be used.";"class";"RandomDataImpl";"org.apache.commons.math3.random.RandomDataImpl"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[4]/tt[2]";"nextSecureHexString";"nextSecureHexString generates hex characters in 40-byte";"2.4 Random Strings
    
    The methods nextHexString and nextSecureHexString
    can be used to generate random strings of hexadecimal characters.  Both
    of these methods produce sequences of strings with good dispersion
    properties.  The difference between the two methods is that the second is
    cryptographically secure.  Specifically, the implementation of 
    nextHexString(n) in RandomDataImpl uses the
    following simple algorithm to generate a string of n hex digits:
    n/2+1 binary bytes are generated using the underlying Random
    Each binary byte is translated into 2 hex digits
    The RandomDataImpl implementation of the ""secure"" version, 
    nextSecureHexString generates hex characters in 40-byte
    ""chunks"" using a 3-step process:
    20 random bytes are generated using the underlying 
    SecureRandom.
    SHA-1 hash is applied to yield a 20-byte binary digest.
    Each byte of the binary digest is converted to 2 hex digits
    Similarly to the secure random number generation methods, 
    nextSecureHexString is much slower than
    the non-secure version.  It should be used only for applications such as 
    generating unique session or transaction ids where predictability of
    subsequent ids based on observation of previous values is a security
    concern.  If all that is needed is an even distribution of hex characters
    in the generated strings, the non-secure method should be used.";"class";"nextSecureHexString";"org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/p[5]/a";"DifferentiableMultivariateVectorFunction";"DifferentiableMultivariateVectorFunction interface.";"In order to solve a vectorial optimization problem, the user must provide it as
          an object implementing the 
          DifferentiableMultivariateVectorFunction interface. The object will be provided to
          the estimate method of the optimizer, along with the target and weight arrays,
          thus allowing the optimizer to compute the residuals at will. The last parameter to the
          estimate method is the point from which the optimizer will start its
          search for the optimal point.";"class";"DifferentiableMultivariateVectorFunction";"org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[4]/tt[3]";"nextSecureHexString";"nextSecureHexString is much slower than";"2.4 Random Strings
    
    The methods nextHexString and nextSecureHexString
    can be used to generate random strings of hexadecimal characters.  Both
    of these methods produce sequences of strings with good dispersion
    properties.  The difference between the two methods is that the second is
    cryptographically secure.  Specifically, the implementation of 
    nextHexString(n) in RandomDataImpl uses the
    following simple algorithm to generate a string of n hex digits:
    n/2+1 binary bytes are generated using the underlying Random
    Each binary byte is translated into 2 hex digits
    The RandomDataImpl implementation of the ""secure"" version, 
    nextSecureHexString generates hex characters in 40-byte
    ""chunks"" using a 3-step process:
    20 random bytes are generated using the underlying 
    SecureRandom.
    SHA-1 hash is applied to yield a 20-byte binary digest.
    Each byte of the binary digest is converted to 2 hex digits
    Similarly to the secure random number generation methods, 
    nextSecureHexString is much slower than
    the non-secure version.  It should be used only for applications such as 
    generating unique session or transaction ids where predictability of
    subsequent ids based on observation of previous values is a security
    concern.  If all that is needed is an even distribution of hex characters
    in the generated strings, the non-secure method should be used.";"class";"nextSecureHexString";"org.apache.commons.math3.random.RandomDataImpl.nextSecureHexString"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[1]/tt[1]";"nextSample";"nextSample method in the RandomData interface.";"To select a random sample of objects in a collection, you can use the
    nextSample method in the RandomData interface.
    Specifically,  if c is a collection containing at least 
    k objects, and randomData is a 
    RandomData instance randomData.nextSample(c, k)
    will return an object[] array of length k
    consisting of elements randomly selected from the collection.  If 
    c contains duplicate references, there may be duplicate
    references in the returned array; otherwise returned elements will be
    unique -- i.e., the sampling is without replacement among the object
    references in the collection.";"class";"nextSample";"org.apache.commons.math3.random.RandomData.nextSample"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[1]/tt[2]";"RandomData";"nextSample method in the RandomData interface.";"To select a random sample of objects in a collection, you can use the
    nextSample method in the RandomData interface.
    Specifically,  if c is a collection containing at least 
    k objects, and randomData is a 
    RandomData instance randomData.nextSample(c, k)
    will return an object[] array of length k
    consisting of elements randomly selected from the collection.  If 
    c contains duplicate references, there may be duplicate
    references in the returned array; otherwise returned elements will be
    unique -- i.e., the sampling is without replacement among the object
    references in the collection.";"class";"RandomData";"org.apache.commons.math3.random.RandomData"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/dl/dd/p[1]/a";"DifferentiableMultivariateVectorFunction";"First we need to implement the interface DifferentiableMultivariateVectorFunction.";"First we need to implement the interface DifferentiableMultivariateVectorFunction.
This requires the implementation of the method signatures:";"class";"DifferentiableMultivariateVectorFunction";"org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[1]/tt[5]";"randomData";"k objects, and randomData is a";"To select a random sample of objects in a collection, you can use the
    nextSample method in the RandomData interface.
    Specifically,  if c is a collection containing at least 
    k objects, and randomData is a 
    RandomData instance randomData.nextSample(c, k)
    will return an object[] array of length k
    consisting of elements randomly selected from the collection.  If 
    c contains duplicate references, there may be duplicate
    references in the returned array; otherwise returned elements will be
    unique -- i.e., the sampling is without replacement among the object
    references in the collection.";"class";"randomData";"org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[2]";"Fraction";"9.2 Fraction Numbers";"9.2 Fraction Numbers";"class";"Fraction";"org.apache.commons.math3.fraction.Fraction"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/dl/dd/p[2]/tt";"MultivariateMatrixFunction";"We'll tackle the implementation of the MultivariateMatrixFunction jacobian() method first.";"We'll tackle the implementation of the MultivariateMatrixFunction jacobian() method first.  You may wish to familiarize yourself with what a  Jacobian Matrix is.
In this case the Jacobian is the partial derivative of the function with respect
to the parameters a, b and c.  These derivatives are computed as follows:";"class";"MultivariateMatrixFunction";"org.apache.commons.math3.analysis.MultivariateMatrixFunction"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[1]/tt[6]";"RandomData";"RandomData instance randomData.";"To select a random sample of objects in a collection, you can use the
    nextSample method in the RandomData interface.
    Specifically,  if c is a collection containing at least 
    k objects, and randomData is a 
    RandomData instance randomData.nextSample(c, k)
    will return an object[] array of length k
    consisting of elements randomly selected from the collection.  If 
    c contains duplicate references, there may be duplicate
    references in the returned array; otherwise returned elements will be
    unique -- i.e., the sampling is without replacement among the object
    references in the collection.";"class";"RandomData";"org.apache.commons.math3.random.RandomData"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/dl/dd/p[2]/tt";"jacobian()";"We'll tackle the implementation of the MultivariateMatrixFunction jacobian() method first.";"We'll tackle the implementation of the MultivariateMatrixFunction jacobian() method first.  You may wish to familiarize yourself with what a  Jacobian Matrix is.
In this case the Jacobian is the partial derivative of the function with respect
to the parameters a, b and c.  These derivatives are computed as follows:";"method";"jacobian";"org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction.jacobian"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[3]";"Fraction";"9.3 Fraction Formatting and Parsing";"9.3 Fraction Formatting and Parsing";"class";"Fraction";"org.apache.commons.math3.fraction.Fraction"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[1]/tt[7]";"randomData.nextSample(c, k)";"RandomData instance randomData.nextSample(c, k)";"To select a random sample of objects in a collection, you can use the
    nextSample method in the RandomData interface.
    Specifically,  if c is a collection containing at least 
    k objects, and randomData is a 
    RandomData instance randomData.nextSample(c, k)
    will return an object[] array of length k
    consisting of elements randomly selected from the collection.  If 
    c contains duplicate references, there may be duplicate
    references in the returned array; otherwise returned elements will be
    unique -- i.e., the sampling is without replacement among the object
    references in the collection.";"method";"nextSample";"org.apache.commons.math3.random.RandomData.nextSample"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/dl/dd/p[4]/tt[1]";"MultivariateMatrixFunction";"The implementation of the MultivariateMatrixFunction jacobian() for this problem looks like this (The x";"The implementation of the MultivariateMatrixFunction jacobian() for this problem looks like this (The x
parameter is an ArrayList containing the independent values of the data set):";"class";"MultivariateMatrixFunction";"org.apache.commons.math3.analysis.MultivariateMatrixFunction"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/dl/dd/p[4]/tt[1]";"jacobian()";"The implementation of the MultivariateMatrixFunction jacobian() for this problem looks like this (The x";"The implementation of the MultivariateMatrixFunction jacobian() for this problem looks like this (The x
parameter is an ArrayList containing the independent values of the data set):";"method";"jacobian";"org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction.jacobian"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/dl/dd/p[6]/tt[1]";"value(double[] point)";"The implementation of the double[] value(double[] point) method, which returns";"The implementation of the double[] value(double[] point) method, which returns
 a double array containing the
values the objective function returns per given independent value
and the current set of variables or parameters,
can be seen below:";"method";"value";"org.apache.commons.math3.analysis.MultivariateMatrixFunction.value"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[1]";"randomData";"If randomData is a RandomData instance, and";"If randomData is a RandomData instance, and 
    n and k are integers with 
     k <= n,  then 
    randomData.nextPermutation(n, k) returns an int[]
    array of length k whose whose entries are selected randomly, 
    without repetition, from the integers 0 through
    n-1 (inclusive), i.e., 
    randomData.nextPermutation(n, k) returns a random
    permutation of  n taken k at a time.";"class";"randomData";"org.apache.commons.math3.distribution.AbstractRealDistribution.randomData"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[2]";"RandomData";"If randomData is a RandomData instance, and";"If randomData is a RandomData instance, and 
    n and k are integers with 
     k <= n,  then 
    randomData.nextPermutation(n, k) returns an int[]
    array of length k whose whose entries are selected randomly, 
    without repetition, from the integers 0 through
    n-1 (inclusive), i.e., 
    randomData.nextPermutation(n, k) returns a random
    permutation of  n taken k at a time.";"class";"RandomData";"org.apache.commons.math3.random.RandomData"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/p[6]/a[1]";"NonLinearConjugateGradientOptimizer";"NonLinearConjugateGradientOptimizer class provides a non-linear conjugate gradient algorithm";"In addition to least squares solving, the 
          NonLinearConjugateGradientOptimizer class provides a non-linear conjugate gradient algorithm
          to optimize 
          DifferentiableMultivariateFunction. Both the Fletcher-Reeves and the Polak-Ribière
          search direction update methods are supported. It is also possible to set up a preconditioner
          or to change the line-search algorithm of the inner loop if desired (the default one is a Brent
          solver).";"class";"NonLinearConjugateGradientOptimizer";"org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/p[6]/a[2]";"DifferentiableMultivariateFunction";"DifferentiableMultivariateFunction.";"In addition to least squares solving, the 
          NonLinearConjugateGradientOptimizer class provides a non-linear conjugate gradient algorithm
          to optimize 
          DifferentiableMultivariateFunction. Both the Fletcher-Reeves and the Polak-Ribière
          search direction update methods are supported. It is also possible to set up a preconditioner
          or to change the line-search algorithm of the inner loop if desired (the default one is a Brent
          solver).";"class";"DifferentiableMultivariateFunction";"org.apache.commons.math3.analysis.DifferentiableMultivariateFunction"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[6]";"randomData.nextPermutation(n, k)";"randomData.nextPermutation(n, k) returns an int[]";"If randomData is a RandomData instance, and 
    n and k are integers with 
     k <= n,  then 
    randomData.nextPermutation(n, k) returns an int[]
    array of length k whose whose entries are selected randomly, 
    without repetition, from the integers 0 through
    n-1 (inclusive), i.e., 
    randomData.nextPermutation(n, k) returns a random
    permutation of  n taken k at a time.";"method";"nextPermutation";"org.apache.commons.math3.random.RandomData.nextPermutation"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[5]/p[7]/a";"PowellOptimizer";"PowellOptimizer provides an optimization method for non-differentiable functions.";"The 
          PowellOptimizer provides an optimization method for non-differentiable functions.";"class";"PowellOptimizer";"org.apache.commons.math3.optimization.direct.PowellOptimizer"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[6]/p[3]/a[1]";"CurveFitter";"CurveFitter class provides curve fitting for general curves.";"The 
          CurveFitter class provides curve fitting for general curves. Users must
          provide their own implementation of the curve template as a class implementing
          the 
          ParametricUnivariateFunction interface and they must provide the initial guess of the
          parameters.";"class";"CurveFitter";"org.apache.commons.math3.fitting.CurveFitter"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[6]/p[3]/a[2]";"ParametricUnivariateFunction";"ParametricUnivariateFunction interface and they must provide the initial guess of the";"The 
          CurveFitter class provides curve fitting for general curves. Users must
          provide their own implementation of the curve template as a class implementing
          the 
          ParametricUnivariateFunction interface and they must provide the initial guess of the
          parameters.";"class";"ParametricUnivariateFunction";"org.apache.commons.math3.analysis.ParametricUnivariateFunction"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[6]/p[5]/a";"HarmonicFitter";"HarmonicFitter classes requires neither an implementation of the parametric real function";"The more specialized 
          HarmonicFitter classes requires neither an implementation of the parametric real function
          nor an initial guess as it is are able to compute them internally.";"class";"HarmonicFitter";"org.apache.commons.math3.fitting.HarmonicFitter"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[11]";"randomData.nextPermutation(n, k)";"randomData.nextPermutation(n, k) returns a random";"If randomData is a RandomData instance, and 
    n and k are integers with 
     k <= n,  then 
    randomData.nextPermutation(n, k) returns an int[]
    array of length k whose whose entries are selected randomly, 
    without repetition, from the integers 0 through
    n-1 (inclusive), i.e., 
    randomData.nextPermutation(n, k) returns a random
    permutation of  n taken k at a time.";"method";"nextPermutation";"org.apache.commons.math3.random.RandomData.nextPermutation"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[6]/p/tt";"ValueServer";"Using the ValueServer class, you can generate data based on";"Using the ValueServer class, you can generate data based on
    the values in an input file in one of two ways:";"class";"ValueServer";"org.apache.commons.math3.random.ValueServer"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[1]";"GeneticAlgorithm";"GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).";"GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).  
      
      Populations, consisting of 
      Chromosomes are evolved by the GeneticAlgorithm until a 
      
      StoppingCondition is reached. Evolution is determined by 
      SelectionPolicy, 
      MutationPolicy and 
      Fitness.";"class";"GeneticAlgorithm";"org.apache.commons.math3.genetics.GeneticAlgorithm"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[6]/dl/dd[2]/tt[1]";"getNext()";"has been estimated, getNext() returns random values whose";"When used in Digest Mode, the ValueServer reads the entire input file
      and estimates a probability density function based on data from the file.
      The estimation method is essentially the 
      
      Variable Kernel Method with Gaussian smoothing.  Once the density
      has been estimated, getNext() returns random values whose
      probability distribution matches the empirical distribution -- i.e., if
      you generate a large number of such values, their distribution should
      ""look like"" the distribution of the values in the input file.  The values
      are not stored in memory in this case either, so there is no limit to the
      size of the input file.  Here is an example:
      
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      
      See the javadoc for ValueServer and 
      EmpiricalDistribution for more details.  Note that 
      computeDistribution() opens and closes the input file
       by itself.";"method";"getNext";"org.apache.commons.math3.random.ValueServer.getNext"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[1]/tt";"GeneticAlgorithm";"Chromosomes are evolved by the GeneticAlgorithm until a";"GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).  
      
      Populations, consisting of 
      Chromosomes are evolved by the GeneticAlgorithm until a 
      
      StoppingCondition is reached. Evolution is determined by 
      SelectionPolicy, 
      MutationPolicy and 
      Fitness.";"class";"GeneticAlgorithm";"org.apache.commons.math3.genetics.GeneticAlgorithm"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[6]/dl/dd[2]/tt[2]";"ValueServer";"ValueServer vs = new ValueServer();";"When used in Digest Mode, the ValueServer reads the entire input file
      and estimates a probability density function based on data from the file.
      The estimation method is essentially the 
      
      Variable Kernel Method with Gaussian smoothing.  Once the density
      has been estimated, getNext() returns random values whose
      probability distribution matches the empirical distribution -- i.e., if
      you generate a large number of such values, their distribution should
      ""look like"" the distribution of the values in the input file.  The values
      are not stored in memory in this case either, so there is no limit to the
      size of the input file.  Here is an example:
      
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      
      See the javadoc for ValueServer and 
      EmpiricalDistribution for more details.  Note that 
      computeDistribution() opens and closes the input file
       by itself.";"class";"ValueServer";"org.apache.commons.math3.random.ValueServer"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[4]";"StoppingCondition";"StoppingCondition is reached.";"GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).  
      
      Populations, consisting of 
      Chromosomes are evolved by the GeneticAlgorithm until a 
      
      StoppingCondition is reached. Evolution is determined by 
      SelectionPolicy, 
      MutationPolicy and 
      Fitness.";"class";"StoppingCondition";"org.apache.commons.math3.genetics.StoppingCondition"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[6]/dl/dd[2]/tt[3]";"EmpiricalDistribution";"EmpiricalDistribution for more details.";"When used in Digest Mode, the ValueServer reads the entire input file
      and estimates a probability density function based on data from the file.
      The estimation method is essentially the 
      
      Variable Kernel Method with Gaussian smoothing.  Once the density
      has been estimated, getNext() returns random values whose
      probability distribution matches the empirical distribution -- i.e., if
      you generate a large number of such values, their distribution should
      ""look like"" the distribution of the values in the input file.  The values
      are not stored in memory in this case either, so there is no limit to the
      size of the input file.  Here is an example:
      
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      
      See the javadoc for ValueServer and 
      EmpiricalDistribution for more details.  Note that 
      computeDistribution() opens and closes the input file
       by itself.";"class";"EmpiricalDistribution";"org.apache.commons.math3.random.EmpiricalDistribution"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[5]";"SelectionPolicy";"SelectionPolicy,";"GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).  
      
      Populations, consisting of 
      Chromosomes are evolved by the GeneticAlgorithm until a 
      
      StoppingCondition is reached. Evolution is determined by 
      SelectionPolicy, 
      MutationPolicy and 
      Fitness.";"class";"SelectionPolicy";"org.apache.commons.math3.genetics.SelectionPolicy"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[6]";"MutationPolicy";"MutationPolicy and";"GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).  
      
      Populations, consisting of 
      Chromosomes are evolved by the GeneticAlgorithm until a 
      
      StoppingCondition is reached. Evolution is determined by 
      SelectionPolicy, 
      MutationPolicy and 
      Fitness.";"class";"MutationPolicy";"org.apache.commons.math3.genetics.MutationPolicy"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[7]";"Fitness";"Fitness.";"GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).  
      
      Populations, consisting of 
      Chromosomes are evolved by the GeneticAlgorithm until a 
      
      StoppingCondition is reached. Evolution is determined by 
      SelectionPolicy, 
      MutationPolicy and 
      Fitness.";"unknown";"Fitness";"org.apache.commons.math3.genetics.Fitness"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[1]/a[1]";"RandomGenerator";"RandomGenerator interface abstracts the public interface of";"To enable alternative PRNGs to be ""plugged in"" to the commons-math data
      generation utilities and to provide a generic means to replace 
      java.util.Random in applications, a random generator 
      adaptor framework has been added to commons-math.  The
      
      RandomGenerator interface abstracts the public interface of
      java.util.Random and any implementation of this
      interface can be used as the source of random data for the commons-math 
      data generation classes.  An abstract base class, 
      
      AbstractRandomGenerator is provided to make implementation easier.
      This class provides default implementations of ""derived"" data generation
      methods based on the primitive,  nextDouble().
      To support generic replacement of java.util.Random, the 
      
      RandomAdaptor class is provided, which extends
      java.util.Random and wraps and delegates calls to
      a RandomGenerator instance.";"class";"RandomGenerator";"org.apache.commons.math3.random.RandomGenerator"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[1]";"evolve";"The GA itself is implemented by the evolve method of the";"The GA itself is implemented by the evolve method of the
      GeneticAlgorithm class,
      which looks like this:";"unknown";"evolve";"org.apache.commons.math3.genetics.GeneticAlgorithm.evolve"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[1]/a[2]";"AbstractRandomGenerator";"AbstractRandomGenerator is provided to make implementation easier.";"To enable alternative PRNGs to be ""plugged in"" to the commons-math data
      generation utilities and to provide a generic means to replace 
      java.util.Random in applications, a random generator 
      adaptor framework has been added to commons-math.  The
      
      RandomGenerator interface abstracts the public interface of
      java.util.Random and any implementation of this
      interface can be used as the source of random data for the commons-math 
      data generation classes.  An abstract base class, 
      
      AbstractRandomGenerator is provided to make implementation easier.
      This class provides default implementations of ""derived"" data generation
      methods based on the primitive,  nextDouble().
      To support generic replacement of java.util.Random, the 
      
      RandomAdaptor class is provided, which extends
      java.util.Random and wraps and delegates calls to
      a RandomGenerator instance.";"class";"AbstractRandomGenerator";"org.apache.commons.math3.random.AbstractRandomGenerator"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[2]";"GeneticAlgorithm";"GeneticAlgorithm class,";"The GA itself is implemented by the evolve method of the
      GeneticAlgorithm class,
      which looks like this:";"class";"GeneticAlgorithm";"org.apache.commons.math3.genetics.GeneticAlgorithm"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/tt";"nextGeneration";"The nextGeneration method implements the following algorithm:";"14.2 GA Framework
      
      
      GeneticAlgorithm provides an execution framework for Genetic Algorithms (GA).  
      
      Populations, consisting of 
      Chromosomes are evolved by the GeneticAlgorithm until a 
      
      StoppingCondition is reached. Evolution is determined by 
      SelectionPolicy, 
      MutationPolicy and 
      Fitness.
      
      
      The GA itself is implemented by the evolve method of the
      GeneticAlgorithm class,
      which looks like this:
      public Population evolve(Population initial, StoppingCondition condition) {
    Population current = initial;
    while (!condition.isSatisfied(current)) {
        current = nextGeneration(current);
    }
    return current;
}
          
          The nextGeneration method implements the following algorithm:
          Get nextGeneration population to fill from current
             generation, using its nextGeneration method
          Loop until new generation is filled:
          Apply configured SelectionPolicy to select a pair of parents
                 from current
             With probability = 
                 
                 getCrossoverRate(), apply configured CrossoverPolicy to parents
             With probability = 
                 
                 getMutationRate(),
                 apply configured MutationPolicy to each of the offspring
             Add offspring individually to nextGeneration,
                 space permitting
          Return nextGeneration";"class";"nextGeneration";"org.apache.commons.math3.genetics.GeneticAlgorithm.nextGeneration"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/ol/ul/li[1]/tt[1]";"SelectionPolicy";"Apply configured SelectionPolicy to select a pair of parents";"Apply configured SelectionPolicy to select a pair of parents
                 from current";"class";"SelectionPolicy";"org.apache.commons.math3.genetics.SelectionPolicy"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[1]/a[3]";"RandomAdaptor";"RandomAdaptor class is provided, which extends";"To enable alternative PRNGs to be ""plugged in"" to the commons-math data
      generation utilities and to provide a generic means to replace 
      java.util.Random in applications, a random generator 
      adaptor framework has been added to commons-math.  The
      
      RandomGenerator interface abstracts the public interface of
      java.util.Random and any implementation of this
      interface can be used as the source of random data for the commons-math 
      data generation classes.  An abstract base class, 
      
      AbstractRandomGenerator is provided to make implementation easier.
      This class provides default implementations of ""derived"" data generation
      methods based on the primitive,  nextDouble().
      To support generic replacement of java.util.Random, the 
      
      RandomAdaptor class is provided, which extends
      java.util.Random and wraps and delegates calls to
      a RandomGenerator instance.";"class";"RandomAdaptor";"org.apache.commons.math3.random.RandomAdaptor"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[1]/tt[6]";"RandomGenerator";"a RandomGenerator instance.";"To enable alternative PRNGs to be ""plugged in"" to the commons-math data
      generation utilities and to provide a generic means to replace 
      java.util.Random in applications, a random generator 
      adaptor framework has been added to commons-math.  The
      
      RandomGenerator interface abstracts the public interface of
      java.util.Random and any implementation of this
      interface can be used as the source of random data for the commons-math 
      data generation classes.  An abstract base class, 
      
      AbstractRandomGenerator is provided to make implementation easier.
      This class provides default implementations of ""derived"" data generation
      methods based on the primitive,  nextDouble().
      To support generic replacement of java.util.Random, the 
      
      RandomAdaptor class is provided, which extends
      java.util.Random and wraps and delegates calls to
      a RandomGenerator instance.";"class";"RandomGenerator";"org.apache.commons.math3.random.RandomGenerator"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/ol/ul/li[2]/a";"getCrossoverRate()";"getCrossoverRate(), apply configured CrossoverPolicy to parents";"With probability = 
                 
                 getCrossoverRate(), apply configured CrossoverPolicy to parents";"method";"getCrossoverRate";"org.apache.commons.math3.genetics.GeneticAlgorithm.getCrossoverRate"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[2]/a";"RandomGenerator";"RandomGenerator interface:";"Commons-math provides by itself several implementations of the 
      RandomGenerator interface:";"class";"RandomGenerator";"org.apache.commons.math3.random.RandomGenerator"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/ol/ul/li[2]/tt";"CrossoverPolicy";"getCrossoverRate(), apply configured CrossoverPolicy to parents";"With probability = 
                 
                 getCrossoverRate(), apply configured CrossoverPolicy to parents";"class";"CrossoverPolicy";"org.apache.commons.math3.genetics.CrossoverPolicy"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[1]/a";"JDKRandomGenerator";"JDKRandomGenerator";"JDKRandomGenerator
            that extends the JDK provided generator";"class";"JDKRandomGenerator";"org.apache.commons.math3.random.JDKRandomGenerator"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/ol/ul/li[3]/a";"getMutationRate()";"getMutationRate(),";"With probability = 
                 
                 getMutationRate(),
                 apply configured MutationPolicy to each of the offspring";"method";"getMutationRate";"org.apache.commons.math3.genetics.GeneticAlgorithm.getMutationRate"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[2]/a";"AbstractRandomGenerator";"AbstractRandomGenerator as a helper for users generators";"AbstractRandomGenerator as a helper for users generators";"class";"AbstractRandomGenerator";"org.apache.commons.math3.random.AbstractRandomGenerator"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[2]/ol/ul/li[3]/tt";"MutationPolicy";"apply configured MutationPolicy to each of the offspring";"With probability = 
                 
                 getMutationRate(),
                 apply configured MutationPolicy to each of the offspring";"class";"MutationPolicy";"org.apache.commons.math3.genetics.MutationPolicy"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[3]/tt[1]";"GeneticAlgorithm";"GeneticAlgorithm ga = new GeneticAlgorithm(";"14.3 Implementation
      
      Here is an example GA execution:
      
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover<Integer>(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        
        The arguments to the GeneticAlgorithm constructor above are: Parametervalue in examplemeaningcrossoverPolicy
        OnePointCrossover
        A random crossover point is selected and the first part from each parent is copied to the corresponding
        child, and the second parts are copied crosswise.crossoverRate
        1
        Always apply crossovermutationPolicy
        RandomKeyMutation
        Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].mutationRate
        .1
        Apply mutation with probability 0.1 - that is, 10% of the time.selectionPolicy
        TournamentSelection
        Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing
        n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.
        The algorithm starts with an initial population of Chromosomes. and executes until 
        the specified StoppingCondition
        is reached.  In the example above, a
        FixedGenerationCount
        stopping condition is used, which means the algorithm proceeds through a fixed number of generations.";"class";"GeneticAlgorithm";"org.apache.commons.math3.genetics.GeneticAlgorithm"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/ul/li[1]/a";"MersenneTwister";"MersenneTwister";"MersenneTwister";"class";"MersenneTwister";"org.apache.commons.math3.random.MersenneTwister"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[3]/table/tr[2]/td[2]/a";"OnePointCrossover";"OnePointCrossover";"OnePointCrossover";"class";"OnePointCrossover";"org.apache.commons.math3.genetics.OnePointCrossover"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/ul/li[2]/a";"Well512a";"Well512a";"Well512a";"unknown";"Well512a";"org.apache.commons.math3.random.Well512a"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[3]/table/tr[4]/td[2]/a";"RandomKeyMutation";"RandomKeyMutation";"RandomKeyMutation";"class";"RandomKeyMutation";"org.apache.commons.math3.genetics.RandomKeyMutation"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/ul/li[3]/a";"Well1024a";"Well1024a";"Well1024a";"unknown";"Well1024a";"org.apache.commons.math3.random.Well1024a"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[3]/table/tr[6]/td[2]/a";"TournamentSelection";"TournamentSelection";"TournamentSelection";"class";"TournamentSelection";"org.apache.commons.math3.genetics.TournamentSelection"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/ul/li[4]/a";"Well19937a";"Well19937a";"Well19937a";"unknown";"Well19937a";"org.apache.commons.math3.random.Well19937a"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/ul/li[5]/a";"Well19937c";"Well19937c";"Well19937c";"unknown";"Well19937c";"org.apache.commons.math3.random.Well19937c"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[2]";"Erf";"5.2 Erf functions";"5.2 Erf functions";"class";"Erf";"org.apache.commons.math3.special.Erf"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/ul/li[6]/a";"Well44497a";"Well44497a";"Well44497a";"unknown";"Well44497a";"org.apache.commons.math3.random.Well44497a"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]";"Gamma";"5.3 Gamma functions";"5.3 Gamma functions";"class";"Gamma";"org.apache.commons.math3.special.Gamma"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[3]/a[1]";"StoppingCondition";"the specified StoppingCondition";"14.3 Implementation
      
      Here is an example GA execution:
      
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover<Integer>(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        
        The arguments to the GeneticAlgorithm constructor above are: Parametervalue in examplemeaningcrossoverPolicy
        OnePointCrossover
        A random crossover point is selected and the first part from each parent is copied to the corresponding
        child, and the second parts are copied crosswise.crossoverRate
        1
        Always apply crossovermutationPolicy
        RandomKeyMutation
        Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].mutationRate
        .1
        Apply mutation with probability 0.1 - that is, 10% of the time.selectionPolicy
        TournamentSelection
        Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing
        n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.
        The algorithm starts with an initial population of Chromosomes. and executes until 
        the specified StoppingCondition
        is reached.  In the example above, a
        FixedGenerationCount
        stopping condition is used, which means the algorithm proceeds through a fixed number of generations.";"class";"StoppingCondition";"org.apache.commons.math3.genetics.StoppingCondition"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/ul/li[7]/a";"Well44497b";"Well44497b";"Well44497b";"unknown";"Well44497b";"org.apache.commons.math3.random.Well44497b"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[2]";"Gamma";"Log Gamma";"Log Gamma";"class";"Gamma";"org.apache.commons.math3.special.Gamma"
"math/doc/manual3.1/math/userguide/genetics.html";"/html/body/div[4]/div/div/div[3]/a[2]";"FixedGenerationCount";"FixedGenerationCount";"14.3 Implementation
      
      Here is an example GA execution:
      
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover<Integer>(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        
        The arguments to the GeneticAlgorithm constructor above are: Parametervalue in examplemeaningcrossoverPolicy
        OnePointCrossover
        A random crossover point is selected and the first part from each parent is copied to the corresponding
        child, and the second parts are copied crosswise.crossoverRate
        1
        Always apply crossovermutationPolicy
        RandomKeyMutation
        Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].mutationRate
        .1
        Apply mutation with probability 0.1 - that is, 10% of the time.selectionPolicy
        TournamentSelection
        Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing
        n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.
        The algorithm starts with an initial population of Chromosomes. and executes until 
        the specified StoppingCondition
        is reached.  In the example above, a
        FixedGenerationCount
        stopping condition is used, which means the algorithm proceeds through a fixed number of generations.";"class";"FixedGenerationCount";"org.apache.commons.math3.genetics.FixedGenerationCount"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[3]/td[1]/a";"MersenneTwister";"MersenneTwister";"MersenneTwister";"class";"MersenneTwister";"org.apache.commons.math3.random.MersenneTwister"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[3]/div[3]";"Gamma";"Regularized Gamma";"Regularized Gamma";"class";"Gamma";"org.apache.commons.math3.special.Gamma"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[4]";"Beta";"5.4 Beta functions";"5.4 Beta functions";"class";"Beta";"org.apache.commons.math3.special.Beta"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[4]/td[1]/a";"JDKRandomGenerator";"JDKRandomGenerator";"JDKRandomGenerator";"class";"JDKRandomGenerator";"org.apache.commons.math3.random.JDKRandomGenerator"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[5]/td[1]/a";"Well512a";"Well512a";"Well512a";"unknown";"Well512a";"org.apache.commons.math3.random.Well512a"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[4]/div[1]";"Beta";"Log Beta";"Log Beta";"class";"Beta";"org.apache.commons.math3.special.Beta"
"math/doc/manual3.1/math/userguide/special.html";"/html/body/div[4]/div/div/div[4]/div[2]";"Beta";"Regularized Beta";"Regularized Beta";"class";"Beta";"org.apache.commons.math3.special.Beta"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[6]/td[1]/a";"Well1024a";"Well1024a";"Well1024a";"unknown";"Well1024a";"org.apache.commons.math3.random.Well1024a"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[7]/td[1]/a";"Well19937a";"Well19937a";"Well19937a";"unknown";"Well19937a";"org.apache.commons.math3.random.Well19937a"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[8]/td[1]/a";"Well19937c";"Well19937c";"Well19937c";"unknown";"Well19937c";"org.apache.commons.math3.random.Well19937c"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[9]/td[1]/a";"Well44497a";"Well44497a";"Well44497a";"unknown";"Well44497a";"org.apache.commons.math3.random.Well44497a"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/table/tr[10]/td[1]/a";"Well44497b";"Well44497b";"Well44497b";"unknown";"Well44497b";"org.apache.commons.math3.random.Well44497b"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[9]/a[1]";"Well19937c";"So for most simulation problems, the better generators like Well19937c and Well44497b are probably very good choices.";"So for most simulation problems, the better generators like Well19937c and Well44497b are probably very good choices.";"unknown";"Well19937c";"org.apache.commons.math3.random.Well19937c"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[9]/a[2]";"Well44497b";"So for most simulation problems, the better generators like Well19937c and Well44497b are probably very good choices.";"So for most simulation problems, the better generators like Well19937c and Well44497b are probably very good choices.";"unknown";"Well44497b";"org.apache.commons.math3.random.Well44497b"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/dl/dd[1]/tt";"AbstractRandomGenerator";"as the source of randomness, extend AbstractRandomGenerator";"To create a RandomGenerator using the RngPack Mersenne Twister PRNG
       as the source of randomness, extend AbstractRandomGenerator
       overriding the derived methods that the RngPack implementation provides:
       
import edu.cornell.lassp.houle.RngPack.RanMT;
/**
 * AbstractRandomGenerator based on RngPack RanMT generator.
 */
public class RngPackGenerator extends AbstractRandomGenerator {
    
    private RanMT random = new RanMT();
    
    public void setSeed(long seed) {
       random = new RanMT(seed);
    }
    
    public double nextDouble() {
        return random.raw();
    }
    
    public double nextGaussian() {
        return random.gaussian();
    }
    
    public int nextInt(int n) {
        return random.choose(n);
    }
    
    public boolean nextBoolean() {
        return random.coin();
    }
}";"class";"AbstractRandomGenerator";"org.apache.commons.math3.random.AbstractRandomGenerator"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/dl/dt[2]/tt[2]";"RandomData";"Random in RandomData";"Use the Mersenne Twister RandomGenerator in place of 
      java.util.Random in RandomData";"class";"RandomData";"org.apache.commons.math3.random.RandomData"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[3]/ul/li[1]/a[2]/tt";"MathIllegalArgumentException";"MathIllegalArgumentException";"MathIllegalArgumentException";"class";"MathIllegalArgumentException";"org.apache.commons.math3.exception.MathIllegalArgumentException"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[3]/ul/li[2]/a[2]/tt";"MathIllegalStateException";"MathIllegalStateException";"MathIllegalStateException";"class";"MathIllegalStateException";"org.apache.commons.math3.exception.MathIllegalStateException"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[3]/ul/li[3]/a[2]/tt";"MathArithmeticException";"MathArithmeticException";"MathArithmeticException";"class";"MathArithmeticException";"org.apache.commons.math3.exception.MathArithmeticException"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[3]/ul/li[4]/a[2]/tt";"MathUnsupportedOperationException";"MathUnsupportedOperationException";"MathUnsupportedOperationException";"class";"MathUnsupportedOperationException";"org.apache.commons.math3.exception.MathUnsupportedOperationException"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[4]/ul/li[1]/p/a";"getLocalizedMessage";"getLocalizedMessage method) can be localized.";"The detailed error messages (i.e. the string returned by the
              
                getLocalizedMessage method) can be localized.
              However, besides the American/English default, French is the only language
              for which a translation resource is available.";"class";"getLocalizedMessage";"org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage"
"math/doc/manual3.1/math/userguide/filter.html";"/html/body/div[4]/div/div/div[2]/p[1]/a";"KalmanFilter";"KalmanFilter provides a discrete-time filter to estimate";"KalmanFilter provides a discrete-time filter to estimate
          a stochastic linear process.";"class";"KalmanFilter";"org.apache.commons.math3.filter.KalmanFilter"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[4]/ul/li[2]/p/a[1]";"ExceptionContextProvider";"ExceptionContextProvider interface.";"Every exception generated by Commons Math implements the
              
                ExceptionContextProvider interface. A call to the
              
                getContext method will return the
              
                ExceptionContext instance stored in the exception, which the
              user can further customize by adding messages and/or any object.";"class";"ExceptionContextProvider";"org.apache.commons.math3.exception.util.ExceptionContextProvider"
"math/doc/manual3.1/math/userguide/filter.html";"/html/body/div[4]/div/div/div[2]/p[2]/a[1]";"ProcessModel";"ProcessModel and a";"A Kalman filter is initialized with a 
          ProcessModel and a 
          MeasurementModel, which contain the corresponding transformation and noise covariance matrices. 
          The parameter names used in the respective models correspond to the following names commonly used 
          in the mathematical literature:";"class";"ProcessModel";"org.apache.commons.math3.filter.ProcessModel"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[4]/ul/li[2]/p/a[2]";"getContext";"getContext method will return the";"Every exception generated by Commons Math implements the
              
                ExceptionContextProvider interface. A call to the
              
                getContext method will return the
              
                ExceptionContext instance stored in the exception, which the
              user can further customize by adding messages and/or any object.";"class";"getContext";"org.apache.commons.math3.exception.util.ExceptionContextProvider.getContext"
"math/doc/manual3.1/math/userguide/filter.html";"/html/body/div[4]/div/div/div[2]/p[2]/a[2]";"MeasurementModel";"MeasurementModel, which contain the corresponding transformation and noise covariance matrices.";"A Kalman filter is initialized with a 
          ProcessModel and a 
          MeasurementModel, which contain the corresponding transformation and noise covariance matrices. 
          The parameter names used in the respective models correspond to the following names commonly used 
          in the mathematical literature:";"class";"MeasurementModel";"org.apache.commons.math3.filter.MeasurementModel"
"math/doc/manual3.1/math/userguide/exceptions.html";"/html/body/div[4]/div/div/div[4]/ul/li[2]/p/a[3]";"ExceptionContext";"ExceptionContext instance stored in the exception, which the";"Every exception generated by Commons Math implements the
              
                ExceptionContextProvider interface. A call to the
              
                getContext method will return the
              
                ExceptionContext instance stored in the exception, which the
              user can further customize by adding messages and/or any object.";"class";"ExceptionContext";"org.apache.commons.math3.exception.util.ExceptionContext"
"math/doc/manual3.1/math/userguide/overview.html";"/html/body/div[4]/div/div/div[4]/p[2]/a[2]";"MathIllegalStateException";"MathIllegalStateException may be thrown.";"When the actual parameters provided to a method or the internal state of an object 
    make a computation meaningless, a
    
      IllegalArgumentException or
    
      MathIllegalStateException may be thrown. Exact conditions under which runtime
    exceptions (and any other exceptions) are thrown are specified in the javadoc method
    comments.
    In some cases, to be consistent with the 
      IEEE 754 standard for floating point arithmetic and with java.lang.Math, Commons Math
    methods return Double.NaN values. Conditions under which Double.NaN
    or other special values are returned are fully specified in the javadoc method comments.";"class";"MathIllegalStateException";"org.apache.commons.math3.exception.MathIllegalStateException"
"math/doc/manual3.1/math/userguide/overview.html";"/html/body/div[4]/div/div/div[4]/p[3]/a";"NullArgumentException";"NullArgumentException is raised for signalling the illegal argument.";"As of version 2.2, the policy for dealing with null references is as
    follows: When an argument is unexpectedly null, a
    
      NullArgumentException is raised for signalling the illegal argument. Note that this
    class does not inherit from the standard NullPointerException but is a subclass
    of MathIllegalArgumentException.
    No NullPointerException should be propagated from within Commons Math.";"class";"NullArgumentException";"org.apache.commons.math3.exception.NullArgumentException"
"math/doc/manual3.1/math/userguide/overview.html";"/html/body/div[4]/div/div/div[4]/p[3]/tt[2]";"MathIllegalArgumentException";"of MathIllegalArgumentException.";"As of version 2.2, the policy for dealing with null references is as
    follows: When an argument is unexpectedly null, a
    
      NullArgumentException is raised for signalling the illegal argument. Note that this
    class does not inherit from the standard NullPointerException but is a subclass
    of MathIllegalArgumentException.
    No NullPointerException should be propagated from within Commons Math.";"class";"MathIllegalArgumentException";"org.apache.commons.math3.exception.MathIllegalArgumentException"
"math/doc/manual3.1/math/userguide/transform.html";"/html/body/div[4]/div/div/ul/li[1]/a";"FastFourierTransformer";"FastFourierTransformer (produces Complex results)";"FastFourierTransformer (produces Complex results)";"class";"FastFourierTransformer";"org.apache.commons.math3.transform.FastFourierTransformer"
"math/doc/manual3.1/math/userguide/transform.html";"/html/body/div[4]/div/div/ul/li[1]/tt";"Complex";"FastFourierTransformer (produces Complex results)";"FastFourierTransformer (produces Complex results)";"unknown";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/transform.html";"/html/body/div[4]/div/div/ul/li[2]/a";"FastCosineTransformer";"FastCosineTransformer (produces real results)";"FastCosineTransformer (produces real results)";"class";"FastCosineTransformer";"org.apache.commons.math3.transform.FastCosineTransformer"
"math/doc/manual3.1/math/userguide/transform.html";"/html/body/div[4]/div/div/ul/li[3]/a";"FastSineTransformer";"FastSineTransformer (produces real results)";"FastSineTransformer (produces real results)";"class";"FastSineTransformer";"org.apache.commons.math3.transform.FastSineTransformer"
"math/doc/manual3.1/math/userguide/transform.html";"/html/body/div[4]/div/div/ul/li[4]/a";"FastHadamardTransformer";"FastHadamardTransformer (produces real results)";"FastHadamardTransformer (produces real results)";"class";"FastHadamardTransformer";"org.apache.commons.math3.transform.FastHadamardTransformer"
"math/doc/manual3.1/math/userguide/transform.html";"/html/body/div[4]/div/div";"Transform";"10 Transform methods";"10 Transform methods";"class";"Transform";"org.apache.commons.math3.geometry.partitioning.Transform"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[2]/p[1]/a";"DoubleArray";"DoubleArray.";"To maintain statistics based on a ""rolling"" window of values, a resizable 
    array implementation was developed and is provided for reuse in the 
    util package.  The core functionality provided is described in
    the documentation for the interface, 
    
    DoubleArray.  This interface adds one method,
    addElementRolling(double) to basic list accessors. 
    The addElementRolling method adds an element 
    (the actual parameter) to the end of the list and removes the first element
     in the list.";"class";"DoubleArray";"org.apache.commons.math3.util.DoubleArray"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[2]/p[2]/a[1]";"ResizableDoubleArray";"ResizableDoubleArray class provides a configurable, array-backed";"The 
    ResizableDoubleArray class provides a configurable, array-backed
    implementation of the DoubleArray interface.
    When addElementRolling is invoked, the underlying
    array is expanded if necessary, the new element is added to the end of the
    array and the ""usable window"" of the array is moved forward, so that
    the first element is effectively discarded, what was the second becomes the
    first, and so on.  To efficiently manage storage, two maintenance
    operations need to be periodically performed -- orphaned elements at the
    beginning of the array need to be reclaimed and space for new elements at
    the end needs to be created.  Both of these operations are handled
    automatically, with frequency / effect driven by the configuration
    properties expansionMode, expansionFactor and
    contractionCriteria.  See 
    
    ResizableDoubleArray
    for details.";"class";"ResizableDoubleArray";"org.apache.commons.math3.util.ResizableDoubleArray"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[1]";"DoubleArray";"implementation of the DoubleArray interface.";"The 
    ResizableDoubleArray class provides a configurable, array-backed
    implementation of the DoubleArray interface.
    When addElementRolling is invoked, the underlying
    array is expanded if necessary, the new element is added to the end of the
    array and the ""usable window"" of the array is moved forward, so that
    the first element is effectively discarded, what was the second becomes the
    first, and so on.  To efficiently manage storage, two maintenance
    operations need to be periodically performed -- orphaned elements at the
    beginning of the array need to be reclaimed and space for new elements at
    the end needs to be created.  Both of these operations are handled
    automatically, with frequency / effect driven by the configuration
    properties expansionMode, expansionFactor and
    contractionCriteria.  See 
    
    ResizableDoubleArray
    for details.";"class";"DoubleArray";"org.apache.commons.math3.util.DoubleArray"
"math/doc/manual3.1/math/userguide/distribution.html";"/html/body/div[4]/div/div/div[3]/p/a[4]";"IntegerDistribution";"IntegerDistribution interfaces serve as";"Since there are numerous distributions and Commons-Math only directly
        supports a handful, it may be necessary to extend the distribution
        framework to satisfy individual needs.  It is recommended that the
        Distribution,
        
        ContinuousDistribution,
        
        DiscreteDistribution, and 
        IntegerDistribution interfaces serve as
        base types for any extension.  These serve as the basis for all the
        distributions directly supported by Commons-Math and using those interfaces
        for implementation purposes will ensure any extension is compatible with the
        remainder of Commons-Math.  To aid in implementing a distribution extension,
        the 
        AbstractDistribution, 
        AbstractContinuousDistribution, and 
        AbstractIntegerDistribution provide implementation building blocks and
        offer basic distribution functionality.  By extending these abstract classes
        directly, much of the repetitive distribution implementation is already
        developed and should save time and effort in developing user-defined
        distributions.";"class";"IntegerDistribution";"org.apache.commons.math3.distribution.IntegerDistribution"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[2]/p[2]/a[2]";"ResizableDoubleArray";"ResizableDoubleArray";"The 
    ResizableDoubleArray class provides a configurable, array-backed
    implementation of the DoubleArray interface.
    When addElementRolling is invoked, the underlying
    array is expanded if necessary, the new element is added to the end of the
    array and the ""usable window"" of the array is moved forward, so that
    the first element is effectively discarded, what was the second becomes the
    first, and so on.  To efficiently manage storage, two maintenance
    operations need to be periodically performed -- orphaned elements at the
    beginning of the array need to be reclaimed and space for new elements at
    the end needs to be created.  Both of these operations are handled
    automatically, with frequency / effect driven by the configuration
    properties expansionMode, expansionFactor and
    contractionCriteria.  See 
    
    ResizableDoubleArray
    for details.";"class";"ResizableDoubleArray";"org.apache.commons.math3.util.ResizableDoubleArray"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[3]/p/a";"OpenIntToDoubleHashMap";"OpenIntToDoubleHashMap class provides a specialized hash map";"The 
    OpenIntToDoubleHashMap class provides a specialized hash map
    implementation for int/double. This implementation has a much smaller memory
    overhead than standard java.util.HashMap class. It uses open addressing
    and primitive arrays, which greatly reduces the number of intermediate objects and
    improve data locality.";"class";"OpenIntToDoubleHashMap";"org.apache.commons.math3.util.OpenIntToDoubleHashMap"
"math/doc/manual3.1/math/userguide/distribution.html";"/html/body/div[4]/div/div/div[3]/p/a[7]";"AbstractIntegerDistribution";"AbstractIntegerDistribution provide implementation building blocks and";"Since there are numerous distributions and Commons-Math only directly
        supports a handful, it may be necessary to extend the distribution
        framework to satisfy individual needs.  It is recommended that the
        Distribution,
        
        ContinuousDistribution,
        
        DiscreteDistribution, and 
        IntegerDistribution interfaces serve as
        base types for any extension.  These serve as the basis for all the
        distributions directly supported by Commons-Math and using those interfaces
        for implementation purposes will ensure any extension is compatible with the
        remainder of Commons-Math.  To aid in implementing a distribution extension,
        the 
        AbstractDistribution, 
        AbstractContinuousDistribution, and 
        AbstractIntegerDistribution provide implementation building blocks and
        offer basic distribution functionality.  By extending these abstract classes
        directly, much of the repetitive distribution implementation is already
        developed and should save time and effort in developing user-defined
        distributions.";"class";"AbstractIntegerDistribution";"org.apache.commons.math3.distribution.AbstractIntegerDistribution"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[4]/p[1]/a[1]";"ContinuedFraction";"ContinuedFraction class provides a generic way to create and evaluate";"The 
    ContinuedFraction class provides a generic way to create and evaluate
    continued fractions.  The easiest way to create a continued fraction is
    to subclass ContinuedFraction and override the
    getA and getB methods which return
    the continued fraction terms.  The precise definition of these terms is
    explained in 
    Continued Fraction, equation (1) from MathWorld.";"class";"ContinuedFraction";"org.apache.commons.math3.util.ContinuedFraction"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[1]/p[3]/a";"StepInterpolator";"StepInterpolator";"All integrators provide dense output. This means that besides computing the state vector
          at discrete times, they also provide a cheap mean to get both the state and its derivative
          between the time steps. They do so through classes extending the
          StepInterpolator
          abstract class, which are made available to the user at the end of each step.";"class";"StepInterpolator";"org.apache.commons.math3.ode.sampling.StepInterpolator"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[4]/p[1]/tt[1]";"ContinuedFraction";"to subclass ContinuedFraction and override the";"The 
    ContinuedFraction class provides a generic way to create and evaluate
    continued fractions.  The easiest way to create a continued fraction is
    to subclass ContinuedFraction and override the
    getA and getB methods which return
    the continued fraction terms.  The precise definition of these terms is
    explained in 
    Continued Fraction, equation (1) from MathWorld.";"class";"ContinuedFraction";"org.apache.commons.math3.util.ContinuedFraction"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[4]/p[1]/tt[2]";"getA";"getA and getB methods which return";"The 
    ContinuedFraction class provides a generic way to create and evaluate
    continued fractions.  The easiest way to create a continued fraction is
    to subclass ContinuedFraction and override the
    getA and getB methods which return
    the continued fraction terms.  The precise definition of these terms is
    explained in 
    Continued Fraction, equation (1) from MathWorld.";"unknown";"getA";"org.apache.commons.math3.util.ContinuedFraction.getA"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[1]/p[6]/a[1]";"FirstOrderDifferentialEquations";"FirstOrderDifferentialEquations";"The user should describe his problem in his own classes which should implement the
          FirstOrderDifferentialEquations
          interface. Then he should pass it to the integrator he prefers among all the classes that implement
          the FirstOrderIntegrator
          interface. The following example shows how to implement the simple two-dimensional problem:";"class";"FirstOrderDifferentialEquations";"org.apache.commons.math3.ode.FirstOrderDifferentialEquations"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[4]/p[1]/tt[3]";"getB";"getA and getB methods which return";"The 
    ContinuedFraction class provides a generic way to create and evaluate
    continued fractions.  The easiest way to create a continued fraction is
    to subclass ContinuedFraction and override the
    getA and getB methods which return
    the continued fraction terms.  The precise definition of these terms is
    explained in 
    Continued Fraction, equation (1) from MathWorld.";"unknown";"getB";"org.apache.commons.math3.util.ContinuedFraction.getB"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[1]/p[6]/a[2]";"FirstOrderIntegrator";"the FirstOrderIntegrator";"The user should describe his problem in his own classes which should implement the
          FirstOrderDifferentialEquations
          interface. Then he should pass it to the integrator he prefers among all the classes that implement
          the FirstOrderIntegrator
          interface. The following example shows how to implement the simple two-dimensional problem:";"class";"FirstOrderIntegrator";"org.apache.commons.math3.ode.FirstOrderIntegrator"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[1]/tt[1]";"FirstOrderIntegrator.integrate";"FirstOrderIntegrator.integrate method, as shown by previous example.";"The solution of the integration problem is provided by two means. The first one is aimed towards
          simple use: the state vector at the end of the integration process is copied in the y array of the
          FirstOrderIntegrator.integrate method, as shown by previous example. The second one
          should be used when more in-depth information is needed throughout the integration process. The user
          can register an object implementing the
          StepHandler interface or a
          StepNormalizer object wrapping
          a user-specified object implementing the
          FixedStepHandler interface
          into the integrator before calling the FirstOrderIntegrator.integrate method. The user object
          will be called appropriately during the integration process, allowing the user to process intermediate
          results. The default step handler does nothing. Considering again the previous example, we want to print the
          trajectory of the point to check it really is a circle arc. We simply add the following before the call
          to integrator.integrate:";"class";"FirstOrderIntegrator";"org.apache.commons.math3.ode.FirstOrderIntegrator"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[1]/tt[1]";"FirstOrderIntegrator.integrate";"FirstOrderIntegrator.integrate method, as shown by previous example.";"The solution of the integration problem is provided by two means. The first one is aimed towards
          simple use: the state vector at the end of the integration process is copied in the y array of the
          FirstOrderIntegrator.integrate method, as shown by previous example. The second one
          should be used when more in-depth information is needed throughout the integration process. The user
          can register an object implementing the
          StepHandler interface or a
          StepNormalizer object wrapping
          a user-specified object implementing the
          FixedStepHandler interface
          into the integrator before calling the FirstOrderIntegrator.integrate method. The user object
          will be called appropriately during the integration process, allowing the user to process intermediate
          results. The default step handler does nothing. Considering again the previous example, we want to print the
          trajectory of the point to check it really is a circle arc. We simply add the following before the call
          to integrator.integrate:";"field";"integrate";"org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/p/a";"ArithmeticUtils";"ArithmeticUtils";"A collection of reusable math functions is provided in the
    ArithmeticUtils
    utility class.  ArithmeticUtils currently includes methods to compute the following:";"class";"ArithmeticUtils";"org.apache.commons.math3.util.ArithmeticUtils"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[1]";"StepHandler";"StepHandler interface or a";"The solution of the integration problem is provided by two means. The first one is aimed towards
          simple use: the state vector at the end of the integration process is copied in the y array of the
          FirstOrderIntegrator.integrate method, as shown by previous example. The second one
          should be used when more in-depth information is needed throughout the integration process. The user
          can register an object implementing the
          StepHandler interface or a
          StepNormalizer object wrapping
          a user-specified object implementing the
          FixedStepHandler interface
          into the integrator before calling the FirstOrderIntegrator.integrate method. The user object
          will be called appropriately during the integration process, allowing the user to process intermediate
          results. The default step handler does nothing. Considering again the previous example, we want to print the
          trajectory of the point to check it really is a circle arc. We simply add the following before the call
          to integrator.integrate:";"class";"StepHandler";"org.apache.commons.math3.ode.sampling.StepHandler"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/ul/li[1]/tt[1]";"binomialCoefficient(int, int)";"binomialCoefficient(int, int) for small n, k; as a double,";"Binomial coefficients -- ""n choose k"" available as an (exact) long value,  
    binomialCoefficient(int, int) for small n, k; as a double,
    binomialCoefficientDouble(int, int) for larger values; and in
    a ""super-sized"" version, binomialCoefficientLog(int, int) 
    that returns the natural logarithm of the value.";"method";"binomialCoefficient";"org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficient"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[2]";"StepNormalizer";"StepNormalizer object wrapping";"The solution of the integration problem is provided by two means. The first one is aimed towards
          simple use: the state vector at the end of the integration process is copied in the y array of the
          FirstOrderIntegrator.integrate method, as shown by previous example. The second one
          should be used when more in-depth information is needed throughout the integration process. The user
          can register an object implementing the
          StepHandler interface or a
          StepNormalizer object wrapping
          a user-specified object implementing the
          FixedStepHandler interface
          into the integrator before calling the FirstOrderIntegrator.integrate method. The user object
          will be called appropriately during the integration process, allowing the user to process intermediate
          results. The default step handler does nothing. Considering again the previous example, we want to print the
          trajectory of the point to check it really is a circle arc. We simply add the following before the call
          to integrator.integrate:";"class";"StepNormalizer";"org.apache.commons.math3.ode.sampling.StepNormalizer"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/ul/li[1]/tt[2]";"binomialCoefficientDouble(int, int)";"binomialCoefficientDouble(int, int) for larger values; and in";"Binomial coefficients -- ""n choose k"" available as an (exact) long value,  
    binomialCoefficient(int, int) for small n, k; as a double,
    binomialCoefficientDouble(int, int) for larger values; and in
    a ""super-sized"" version, binomialCoefficientLog(int, int) 
    that returns the natural logarithm of the value.";"method";"binomialCoefficientDouble";"org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientDouble"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[3]";"FixedStepHandler";"FixedStepHandler interface";"The solution of the integration problem is provided by two means. The first one is aimed towards
          simple use: the state vector at the end of the integration process is copied in the y array of the
          FirstOrderIntegrator.integrate method, as shown by previous example. The second one
          should be used when more in-depth information is needed throughout the integration process. The user
          can register an object implementing the
          StepHandler interface or a
          StepNormalizer object wrapping
          a user-specified object implementing the
          FixedStepHandler interface
          into the integrator before calling the FirstOrderIntegrator.integrate method. The user object
          will be called appropriately during the integration process, allowing the user to process intermediate
          results. The default step handler does nothing. Considering again the previous example, we want to print the
          trajectory of the point to check it really is a circle arc. We simply add the following before the call
          to integrator.integrate:";"class";"FixedStepHandler";"org.apache.commons.math3.ode.sampling.FixedStepHandler"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/ul/li[1]/tt[3]";"binomialCoefficientLog(int, int)";"a ""super-sized"" version, binomialCoefficientLog(int, int)";"Binomial coefficients -- ""n choose k"" available as an (exact) long value,  
    binomialCoefficient(int, int) for small n, k; as a double,
    binomialCoefficientDouble(int, int) for larger values; and in
    a ""super-sized"" version, binomialCoefficientLog(int, int) 
    that returns the natural logarithm of the value.";"method";"binomialCoefficientLog";"org.apache.commons.math3.util.ArithmeticUtils.binomialCoefficientLog"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[1]/tt[2]";"FirstOrderIntegrator.integrate";"into the integrator before calling the FirstOrderIntegrator.integrate method.";"The solution of the integration problem is provided by two means. The first one is aimed towards
          simple use: the state vector at the end of the integration process is copied in the y array of the
          FirstOrderIntegrator.integrate method, as shown by previous example. The second one
          should be used when more in-depth information is needed throughout the integration process. The user
          can register an object implementing the
          StepHandler interface or a
          StepNormalizer object wrapping
          a user-specified object implementing the
          FixedStepHandler interface
          into the integrator before calling the FirstOrderIntegrator.integrate method. The user object
          will be called appropriately during the integration process, allowing the user to process intermediate
          results. The default step handler does nothing. Considering again the previous example, we want to print the
          trajectory of the point to check it really is a circle arc. We simply add the following before the call
          to integrator.integrate:";"class";"FirstOrderIntegrator";"org.apache.commons.math3.ode.FirstOrderIntegrator"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[1]/tt[2]";"FirstOrderIntegrator.integrate";"into the integrator before calling the FirstOrderIntegrator.integrate method.";"The solution of the integration problem is provided by two means. The first one is aimed towards
          simple use: the state vector at the end of the integration process is copied in the y array of the
          FirstOrderIntegrator.integrate method, as shown by previous example. The second one
          should be used when more in-depth information is needed throughout the integration process. The user
          can register an object implementing the
          StepHandler interface or a
          StepNormalizer object wrapping
          a user-specified object implementing the
          FixedStepHandler interface
          into the integrator before calling the FirstOrderIntegrator.integrate method. The user object
          will be called appropriately during the integration process, allowing the user to process intermediate
          results. The default step handler does nothing. Considering again the previous example, we want to print the
          trajectory of the point to check it really is a circle arc. We simply add the following before the call
          to integrator.integrate:";"field";"integrate";"org.apache.commons.math3.ode.FirstOrderIntegrator.integrate"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/ul/li[2]/tt";"stirlingS2(int, int)";"stirlingS2(int, int) for small n, k.";"Stirling numbers of the second kind -- S(n,k) as an exact long value
    stirlingS2(int, int) for small n, k.";"method";"stirlingS2";"org.apache.commons.math3.util.ArithmeticUtils.stirlingS2"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/ul/li[3]/tt[1]";"factorial(int)";"values, factorial(int);  doubles,";"Factorials -- like binomial coefficients, these are available as exact long
    values, factorial(int);  doubles, 
    factorialDouble(int); or logs, factorialLog(int).";"method";"factorial";"org.apache.commons.math3.util.ArithmeticUtils.factorial"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[2]/a";"ContinuousOutputModel";"ContinuousOutputModel";"ContinuousOutputModel
          is a special-purpose step handler that is able to store all steps and to provide transparent access to
          any intermediate result once the integration is over. An important feature of this class is that it
          implements the Serializable interface. This means that a complete continuous model of the
          integrated function throughout the integration range can be serialized and reused later (if stored into
          a persistent medium like a file system or a database) or elsewhere (if sent to another application).
          Only the result of the integration is stored, there is no reference to the integrated problem by itself.";"class";"ContinuousOutputModel";"org.apache.commons.math3.ode.ContinuousOutputModel"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/ul/li[3]/tt[2]";"factorialDouble(int)";"factorialDouble(int); or logs, factorialLog(int).";"Factorials -- like binomial coefficients, these are available as exact long
    values, factorial(int);  doubles, 
    factorialDouble(int); or logs, factorialLog(int).";"method";"factorialDouble";"org.apache.commons.math3.util.ArithmeticUtils.factorialDouble"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[5]/ul/li[3]/tt[3]";"factorialLog(int)";"factorialDouble(int); or logs, factorialLog(int).";"Factorials -- like binomial coefficients, these are available as exact long
    values, factorial(int);  doubles, 
    factorialDouble(int); or logs, factorialLog(int).";"method";"factorialLog";"org.apache.commons.math3.util.ArithmeticUtils.factorialLog"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[1]";"StepHandler";"Other default implementations of the StepHandler";"Other default implementations of the StepHandler
          interface are available for general needs
          (DummyStepHandler,
          StepNormalizer) and custom
          implementations can be developed for specific needs. As an example, if an application is to be
          completely driven by the integration process, then most of the application code will be run inside a
          step handler specific to this application.";"class";"StepHandler";"org.apache.commons.math3.ode.sampling.StepHandler"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[2]";"DummyStepHandler";"(DummyStepHandler,";"Other default implementations of the StepHandler
          interface are available for general needs
          (DummyStepHandler,
          StepNormalizer) and custom
          implementations can be developed for specific needs. As an example, if an application is to be
          completely driven by the integration process, then most of the application code will be run inside a
          step handler specific to this application.";"class";"DummyStepHandler";"org.apache.commons.math3.ode.sampling.DummyStepHandler"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[3]";"StepNormalizer";"StepNormalizer) and custom";"Other default implementations of the StepHandler
          interface are available for general needs
          (DummyStepHandler,
          StepNormalizer) and custom
          implementations can be developed for specific needs. As an example, if an application is to be
          completely driven by the integration process, then most of the application code will be run inside a
          step handler specific to this application.";"class";"StepNormalizer";"org.apache.commons.math3.ode.sampling.StepNormalizer"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[4]/a[1]";"AdaptiveStepsizeIntegrator";"AdaptiveStepsizeIntegrator";"Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient
          integrators use variable steps that are handled internally in order to control the integration error
          with respect to a specified accuracy (these integrators extend the
          AdaptiveStepsizeIntegrator
          abstract class). In this case, the step handler which is called after each successful step shows up
          the variable stepsize. The StepNormalizer
          class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes
          implementing the FixedStepHandler
          interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves,
          however the user can specify it if he prefers to retain full control over the integration or if the
          automatic guess is wrong.";"class";"AdaptiveStepsizeIntegrator";"org.apache.commons.math3.ode.nonstiff.AdaptiveStepsizeIntegrator"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[4]/a[2]";"StepNormalizer";"The StepNormalizer";"Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient
          integrators use variable steps that are handled internally in order to control the integration error
          with respect to a specified accuracy (these integrators extend the
          AdaptiveStepsizeIntegrator
          abstract class). In this case, the step handler which is called after each successful step shows up
          the variable stepsize. The StepNormalizer
          class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes
          implementing the FixedStepHandler
          interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves,
          however the user can specify it if he prefers to retain full control over the integration or if the
          automatic guess is wrong.";"class";"StepNormalizer";"org.apache.commons.math3.ode.sampling.StepNormalizer"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[2]/p[4]/a[3]";"FixedStepHandler";"implementing the FixedStepHandler";"Some integrators (the simple ones) use fixed steps that are set at creation time. The more efficient
          integrators use variable steps that are handled internally in order to control the integration error
          with respect to a specified accuracy (these integrators extend the
          AdaptiveStepsizeIntegrator
          abstract class). In this case, the step handler which is called after each successful step shows up
          the variable stepsize. The StepNormalizer
          class can be used to convert the variable stepsize into a fixed stepsize that can be handled by classes
          implementing the FixedStepHandler
          interface. Adaptive stepsize integrators can automatically compute the initial stepsize by themselves,
          however the user can specify it if he prefers to retain full control over the integration or if the
          automatic guess is wrong.";"class";"FixedStepHandler";"org.apache.commons.math3.ode.sampling.FixedStepHandler"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[6]/p[2]/tt[3]";"FastMath.sin(x)";"methods as is (using FastMath.sin(x) or FastMath.";"FastMath is a drop-in replacement for both Math and StrictMath. This
        means that for any method in Math (say Math.sin(x) or
        Math.cbrt(y)), user can directly change the class and use the
        methods as is (using FastMath.sin(x) or FastMath.cbrt(y)
        in the previous example).";"class";"FastMath";"org.apache.commons.math3.util.FastMath"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[6]/p[2]/tt[3]";"FastMath.sin(x)";"methods as is (using FastMath.sin(x) or FastMath.";"FastMath is a drop-in replacement for both Math and StrictMath. This
        means that for any method in Math (say Math.sin(x) or
        Math.cbrt(y)), user can directly change the class and use the
        methods as is (using FastMath.sin(x) or FastMath.cbrt(y)
        in the previous example).";"method";"sin";"org.apache.commons.math3.util.FastMath.sin"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[6]/p[2]/tt[4]";"FastMath.cbrt(y)";"sin(x) or FastMath.cbrt(y)";"FastMath is a drop-in replacement for both Math and StrictMath. This
        means that for any method in Math (say Math.sin(x) or
        Math.cbrt(y)), user can directly change the class and use the
        methods as is (using FastMath.sin(x) or FastMath.cbrt(y)
        in the previous example).";"class";"FastMath";"org.apache.commons.math3.util.FastMath"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[6]/p[2]/tt[4]";"FastMath.cbrt(y)";"sin(x) or FastMath.cbrt(y)";"FastMath is a drop-in replacement for both Math and StrictMath. This
        means that for any method in Math (say Math.sin(x) or
        Math.cbrt(y)), user can directly change the class and use the
        methods as is (using FastMath.sin(x) or FastMath.cbrt(y)
        in the previous example).";"method";"cbrt";"org.apache.commons.math3.util.FastMath.cbrt"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[7]/a";"MultidimensionalCounter";"MultidimensionalCounter is a utility class that converts a set of indices";"6.7 Miscellaneous
  The 
    MultidimensionalCounter is a utility class that converts a set of indices
  (identifying points in a multidimensional space) to a single index (e.g. identifying
  a location in a one-dimensional array.";"class";"MultidimensionalCounter";"org.apache.commons.math3.util.MultidimensionalCounter"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[1]";"UnivariateStatistic";"UnivariateStatistic.";"The top level interface is
          
          UnivariateStatistic.
          This interface, implemented by all statistics, consists of
          evaluate() methods that take double[] arrays as arguments
          and return the value of the statistic.   This interface is extended by
          
          StorelessUnivariateStatistic, which adds increment(),
          getResult() and associated methods to support
          ""storageless"" implementations that maintain counters, sums or other
          state information as values are added using the increment()
          method.";"class";"UnivariateStatistic";"org.apache.commons.math3.stat.descriptive.UnivariateStatistic"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[2]";"StorelessUnivariateStatistic";"StorelessUnivariateStatistic, which adds increment(),";"The top level interface is
          
          UnivariateStatistic.
          This interface, implemented by all statistics, consists of
          evaluate() methods that take double[] arrays as arguments
          and return the value of the statistic.   This interface is extended by
          
          StorelessUnivariateStatistic, which adds increment(),
          getResult() and associated methods to support
          ""storageless"" implementations that maintain counters, sums or other
          state information as values are added using the increment()
          method.";"class";"StorelessUnivariateStatistic";"org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[1]";"FirstOrderDifferentialEquations";"So rather than the FirstOrderDifferentialEquations";"If the function f is too complex, the user can simply rely on internal differentiation
          using finite differences to compute these local jacobians. So rather than the FirstOrderDifferentialEquations
          interface he will implement the ParameterizedODE
          interface. Considering again our example where only ω is considered a parameter, we get:";"class";"FirstOrderDifferentialEquations";"org.apache.commons.math3.ode.FirstOrderDifferentialEquations"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[2]";"ParameterizedODE";"interface he will implement the ParameterizedODE";"If the function f is too complex, the user can simply rely on internal differentiation
          using finite differences to compute these local jacobians. So rather than the FirstOrderDifferentialEquations
          interface he will implement the ParameterizedODE
          interface. Considering again our example where only ω is considered a parameter, we get:";"class";"ParameterizedODE";"org.apache.commons.math3.ode.ParameterizedODE"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]/p[1]/a";"Complex";"Complex provides a complex number type that forms the basis for";"Complex provides a complex number type that forms the basis for
          the complex functionality found in commons-math.";"unknown";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[4]/a[1]";"AbstractUnivariateStatistic";"AbstractUnivariateStatistic and";"Abstract implementations of the top level interfaces are provided in
          
          AbstractUnivariateStatistic and
          
          AbstractStorelessUnivariateStatistic respectively.";"class";"AbstractUnivariateStatistic";"org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic"
"math/doc/manual3.1/math/userguide/ode.html";"/html/body/div[4]/div/div/div[5]/p[7]/a[1]";"FirstOrderDifferentialEquations";"So rather than the FirstOrderDifferentialEquations";"If the function f is simple, the user can simply provide the local jacobians
          by himself. So rather than the FirstOrderDifferentialEquations
          interface he will implement the ODEWithJacobians
          interface. Considering again our example where only ω is considered a parameter, we get:";"class";"FirstOrderDifferentialEquations";"org.apache.commons.math3.ode.FirstOrderDifferentialEquations"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[4]/a[2]";"AbstractStorelessUnivariateStatistic";"AbstractStorelessUnivariateStatistic respectively.";"Abstract implementations of the top level interfaces are provided in
          
          AbstractUnivariateStatistic and
          
          AbstractStorelessUnivariateStatistic respectively.";"class";"AbstractStorelessUnivariateStatistic";"org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[2]";"NaN";"handling infinite and NaN values.";"Complex functions and arithmetic operations are implemented in
           commons-math by applying standard computational formulas and
           following the rules for java.lang.Double arithmetic in 
           handling infinite and NaN values.  No attempt is made
           to comply with ANSII/IEC C99x Annex G or any other standard for
           Complex arithmetic.  See the class and method javadocs for the 
           
           Complex and
           
           ComplexUtils classes for details on computing formulas.";"class";"NaN";"org.apache.commons.math3.complex.Complex.NaN"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[5]/a[1]";"DescriptiveStatistics";"DescriptiveStatistics and";"Each statistic is implemented as a separate class, in one of the
          subpackages (moment, rank, summary) and each extends one of the abstract
          classes above (depending on whether or not value storage is required to
          compute the statistic). There are several ways to instantiate and use statistics.
          Statistics can be instantiated and used directly,  but it is generally more convenient
          (and efficient) to access them using the provided aggregates,
          
           DescriptiveStatistics and
           
           SummaryStatistics.";"class";"DescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]/p[2]/a[1]";"Complex";"Complex functions and arithmetic operations are implemented in";"Complex functions and arithmetic operations are implemented in
           commons-math by applying standard computational formulas and
           following the rules for java.lang.Double arithmetic in 
           handling infinite and NaN values.  No attempt is made
           to comply with ANSII/IEC C99x Annex G or any other standard for
           Complex arithmetic.  See the class and method javadocs for the 
           
           Complex and
           
           ComplexUtils classes for details on computing formulas.";"unknown";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]/p[2]/a[2]";"ComplexUtils";"ComplexUtils classes for details on computing formulas.";"Complex functions and arithmetic operations are implemented in
           commons-math by applying standard computational formulas and
           following the rules for java.lang.Double arithmetic in 
           handling infinite and NaN values.  No attempt is made
           to comply with ANSII/IEC C99x Annex G or any other standard for
           Complex arithmetic.  See the class and method javadocs for the 
           
           Complex and
           
           ComplexUtils classes for details on computing formulas.";"class";"ComplexUtils";"org.apache.commons.math3.complex.ComplexUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[5]/a[2]";"SummaryStatistics";"SummaryStatistics.";"Each statistic is implemented as a separate class, in one of the
          subpackages (moment, rank, summary) and each extends one of the abstract
          classes above (depending on whether or not value storage is required to
          compute the statistic). There are several ways to instantiate and use statistics.
          Statistics can be instantiated and used directly,  but it is generally more convenient
          (and efficient) to access them using the provided aggregates,
          
           DescriptiveStatistics and
           
           SummaryStatistics.";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[6]/tt";"DescriptiveStatistics";"DescriptiveStatistics maintains the input data in memory";"DescriptiveStatistics maintains the input data in memory
           and has the capability of producing ""rolling"" statistics computed from a
           ""window"" consisting of the most recently added values.";"class";"DescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]/p[4]/tt[1]";"polar2Complex";"using the polar2Complex method in";"Complex numbers may also be created from polar representations
          using the polar2Complex method in 
          ComplexUtils.";"unknown";"polar2Complex";"org.apache.commons.math3.complex.ComplexUtils.polar2Complex"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]/p[4]/tt[2]";"ComplexUtils";"ComplexUtils.";"Complex numbers may also be created from polar representations
          using the polar2Complex method in 
          ComplexUtils.";"class";"ComplexUtils";"org.apache.commons.math3.complex.ComplexUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[7]/tt";"SummaryStatistics";"SummaryStatistics does not store the input data values";"SummaryStatistics does not store the input data values
           in memory, so the statistics included in this aggregate are limited to those
           that can be computed in one pass through the data without access to
           the full array of values.";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]/p[5]/tt[1]";"Complex";"The Complex class provides basic unary and binary";"The Complex class provides basic unary and binary
          complex number operations.  These operations provide the means to add,
          subtract, multiply and divide complex numbers along with other
          complex number functions similar to the real number functions found in
          java.math.BigDecimal:";"unknown";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/table/tr[2]/td[1]/a";"DescriptiveStatistics";"DescriptiveStatistics";"DescriptiveStatistics";"class";"DescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/table/tr[3]/td[1]/a";"SummaryStatistics";"SummaryStatistics";"SummaryStatistics";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[3]/p/a[1]";"Complex";"Complex also provides implementations of serveral transcendental";"Complex also provides implementations of serveral transcendental
          functions involving complex number arguments.
          Prior to version 1.2, these functions were provided
          by 
          ComplexUtils in a way similar to the real number functions found in
          java.lang.Math, but this has been deprecated.
          These operations provide the means to compute the log, sine, tangent,
          and other complex values :";"unknown";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[9]/tt";"SummaryStatistics";"SummaryStatistics can be aggregated using";"SummaryStatistics can be aggregated using 
          
          AggregateSummaryStatistics.  This class can be used to concurrently
          gather statistics for multiple datasets as well as for a combined sample
          including all of the data.";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[3]/p/a[2]";"ComplexUtils";"ComplexUtils in a way similar to the real number functions found in";"Complex also provides implementations of serveral transcendental
          functions involving complex number arguments.
          Prior to version 1.2, these functions were provided
          by 
          ComplexUtils in a way similar to the real number functions found in
          java.lang.Math, but this has been deprecated.
          These operations provide the means to compute the log, sine, tangent,
          and other complex values :";"class";"ComplexUtils";"org.apache.commons.math3.complex.ComplexUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[9]/a";"AggregateSummaryStatistics";"AggregateSummaryStatistics.  This class can be used to concurrently";"SummaryStatistics can be aggregated using 
          
          AggregateSummaryStatistics.  This class can be used to concurrently
          gather statistics for multiple datasets as well as for a combined sample
          including all of the data.";"class";"AggregateSummaryStatistics";"org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[10]/tt[1]";"MultivariateSummaryStatistics";"MultivariateSummaryStatistics is similar to";"MultivariateSummaryStatistics is similar to
           SummaryStatistics but handles n-tuple values instead of
           scalar values. It can also compute the full covariance matrix for the
           input data.";"class";"MultivariateSummaryStatistics";"org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]/p[1]/tt[1]";"Complex";"Complex instances can be converted to and from strings";"Complex instances can be converted to and from strings
          using the
          ComplexFormat class.
          ComplexFormat is a java.text.Format
          extension and, as such, is used like other formatting objects (e.g.
          java.text.SimpleDateFormat):";"unknown";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[10]/tt[2]";"SummaryStatistics";"SummaryStatistics but handles n-tuple values instead of";"MultivariateSummaryStatistics is similar to
           SummaryStatistics but handles n-tuple values instead of
           scalar values. It can also compute the full covariance matrix for the
           input data.";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]/p[1]/a";"ComplexFormat";"ComplexFormat class.";"Complex instances can be converted to and from strings
          using the
          ComplexFormat class.
          ComplexFormat is a java.text.Format
          extension and, as such, is used like other formatting objects (e.g.
          java.text.SimpleDateFormat):";"class";"ComplexFormat";"org.apache.commons.math3.complex.ComplexFormat"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[11]/tt[1]";"DescriptiveStatistics";"Neither DescriptiveStatistics nor SummaryStatistics";"Neither DescriptiveStatistics nor SummaryStatistics
           is thread-safe.
           
           SynchronizedDescriptiveStatistics and
            
           SynchronizedSummaryStatistics, respectively, provide thread-safe
           versions for applications that require concurrent access to statistical
           aggregates by multiple threads.
            
           SynchronizedMultivariateSummaryStatistics provides thread-safe
           MultivariateSummaryStatistics.";"class";"DescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]/p[1]/tt[2]";"ComplexFormat";"ComplexFormat is a java.";"Complex instances can be converted to and from strings
          using the
          ComplexFormat class.
          ComplexFormat is a java.text.Format
          extension and, as such, is used like other formatting objects (e.g.
          java.text.SimpleDateFormat):";"class";"ComplexFormat";"org.apache.commons.math3.complex.ComplexFormat"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[11]/tt[2]";"SummaryStatistics";"Neither DescriptiveStatistics nor SummaryStatistics";"Neither DescriptiveStatistics nor SummaryStatistics
           is thread-safe.
           
           SynchronizedDescriptiveStatistics and
            
           SynchronizedSummaryStatistics, respectively, provide thread-safe
           versions for applications that require concurrent access to statistical
           aggregates by multiple threads.
            
           SynchronizedMultivariateSummaryStatistics provides thread-safe
           MultivariateSummaryStatistics.";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[11]/a[1]";"SynchronizedDescriptiveStatistics";"SynchronizedDescriptiveStatistics and";"Neither DescriptiveStatistics nor SummaryStatistics
           is thread-safe.
           
           SynchronizedDescriptiveStatistics and
            
           SynchronizedSummaryStatistics, respectively, provide thread-safe
           versions for applications that require concurrent access to statistical
           aggregates by multiple threads.
            
           SynchronizedMultivariateSummaryStatistics provides thread-safe
           MultivariateSummaryStatistics.";"class";"SynchronizedDescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[11]/a[2]";"SynchronizedSummaryStatistics";"SynchronizedSummaryStatistics, respectively, provide thread-safe";"Neither DescriptiveStatistics nor SummaryStatistics
           is thread-safe.
           
           SynchronizedDescriptiveStatistics and
            
           SynchronizedSummaryStatistics, respectively, provide thread-safe
           versions for applications that require concurrent access to statistical
           aggregates by multiple threads.
            
           SynchronizedMultivariateSummaryStatistics provides thread-safe
           MultivariateSummaryStatistics.";"class";"SynchronizedSummaryStatistics";"org.apache.commons.math3.stat.descriptive.SynchronizedSummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[11]/a[3]";"SynchronizedMultivariateSummaryStatistics";"SynchronizedMultivariateSummaryStatistics provides thread-safe";"Neither DescriptiveStatistics nor SummaryStatistics
           is thread-safe.
           
           SynchronizedDescriptiveStatistics and
            
           SynchronizedSummaryStatistics, respectively, provide thread-safe
           versions for applications that require concurrent access to statistical
           aggregates by multiple threads.
            
           SynchronizedMultivariateSummaryStatistics provides thread-safe
           MultivariateSummaryStatistics.";"class";"SynchronizedMultivariateSummaryStatistics";"org.apache.commons.math3.stat.descriptive.SynchronizedMultivariateSummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[11]/tt[3]";"MultivariateSummaryStatistics";"MultivariateSummaryStatistics.";"Neither DescriptiveStatistics nor SummaryStatistics
           is thread-safe.
           
           SynchronizedDescriptiveStatistics and
            
           SynchronizedSummaryStatistics, respectively, provide thread-safe
           versions for applications that require concurrent access to statistical
           aggregates by multiple threads.
            
           SynchronizedMultivariateSummaryStatistics provides thread-safe
           MultivariateSummaryStatistics.";"class";"MultivariateSummaryStatistics";"org.apache.commons.math3.stat.descriptive.MultivariateSummaryStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]/p[2]/tt[2]";"ComplexFormat";"a ComplexFormat.";"To customize the formatting output, one or two
          java.text.NumberFormat instances can be used to construct
          a ComplexFormat.  These number formats control the
          formatting of the real and imaginary values of the complex number:";"class";"ComplexFormat";"org.apache.commons.math3.complex.ComplexFormat"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]/p[3]/tt[1]";"ComplexFormat";"ComplexFormat is the text used for the imaginary";"Another formatting customization provided by
          ComplexFormat is the text used for the imaginary
          designation.  By default, the imaginary notation is ""i"" but, it can be
          manipulated using the setImaginaryCharacter method.";"class";"ComplexFormat";"org.apache.commons.math3.complex.ComplexFormat"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[12]/a";"StatUtils";"StatUtils, that provides static methods for computing statistics";"There is also a utility class,
          
          StatUtils, that provides static methods for computing statistics
          directly from double[] arrays.";"class";"StatUtils";"org.apache.commons.math3.stat.StatUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[1]/tt";"DescriptiveStatistics";"Using the DescriptiveStatistics aggregate";"Using the DescriptiveStatistics aggregate
          (values are stored in memory):
        
// Get a DescriptiveStatistics instance
DescriptiveStatistics stats = new DescriptiveStatistics();

// Add the data from the array
for( int i = 0; i < inputArray.length; i++) {
        stats.addValue(inputArray[i]);
}

// Compute some statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
double median = stats.getPercentile(50);";"class";"DescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]/p[4]/tt[1]";"ComplexFormat";"ComplexFormat.";"Formatting inverse operation, parsing, can also be performed by
          ComplexFormat.  Parse a complex number from a string,
          simply call the parse method:";"class";"ComplexFormat";"org.apache.commons.math3.complex.ComplexFormat"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[2]/tt";"SummaryStatistics";"Using the SummaryStatistics aggregate (values are";"Using the SummaryStatistics aggregate (values are
        not stored in memory):
       
// Get a SummaryStatistics instance
SummaryStatistics stats = new SummaryStatistics();

// Read data from an input stream,
// adding values and updating sums, counters, etc.
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
}
in.close();

// Compute the statistics
double mean = stats.getMean();
double std = stats.getStandardDeviation();
//double median = stats.getMedian(); <-- NOT AVAILABLE";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[3]/tt";"StatUtils";"Using the StatUtils utility class:";"Using the StatUtils utility class:
       
// Compute statistics directly from the array
// assume values is a double[] array
double mean = StatUtils.mean(values);
double std = StatUtils.variance(values);
double median = StatUtils.percentile(values, 50);

// Compute the mean of the first three values in the array
mean = StatUtils.mean(values, 0, 3);";"class";"StatUtils";"org.apache.commons.math3.stat.StatUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[4]/tt";"DescriptiveStatistics";"Use a DescriptiveStatistics instance with";"Use a DescriptiveStatistics instance with
        window size set to 100
        
// Create a DescriptiveStats instance and set the window size to 100
DescriptiveStatistics stats = new DescriptiveStatistics();
stats.setWindowSize(100);

// Read data from an input stream,
// displaying the mean of the most recent 100 observations
// after every 100 observations
long nLines = 0;
while (line != null) {
        line = in.readLine();
        stats.addValue(Double.parseDouble(line.trim()));
        if (nLines == 100) {
                nLines = 0;
                System.out.println(stats.getMean());
       }
}
in.close();";"class";"DescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[5]/tt";"SynchronizedDescriptiveStatistics";"Use a SynchronizedDescriptiveStatistics instance";"Use a SynchronizedDescriptiveStatistics instance
        
// Create a SynchronizedDescriptiveStatistics instance and
// use as any other DescriptiveStatistics instance
DescriptiveStatistics stats = new SynchronizedDescriptiveStatistics();";"class";"SynchronizedDescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/tt[1]";"AggregateSummaryStatistics";"There are two ways to do this using AggregateSummaryStatistics.";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"class";"AggregateSummaryStatistics";"org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/tt[2]";"AggregateSummaryStatistics";"The first is to use an AggregateSummaryStatistics instance";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"class";"AggregateSummaryStatistics";"org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/tt[3]";"SummaryStatistics";"to accumulate overall statistics contributed by SummaryStatistics";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/a[1]";"AggregateSummaryStatistics.createContributingStatistics()";"AggregateSummaryStatistics.createContributingStatistics():";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"class";"AggregateSummaryStatistics";"org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/a[1]";"AggregateSummaryStatistics.createContributingStatistics()";"AggregateSummaryStatistics.createContributingStatistics():";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"method";"createContributingStatistics";"org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.createContributingStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/tt[5]";"SummaryStatistics";"// and AggregatingSummaryStatistics for the subsamples";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/a[2]";"aggregate";"SummaryStatistics setOneStats = aggregate.";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"unknown";"aggregate";"org.apache.commons.math3.stat.descriptive.AggregateSummaryStatistics.aggregate"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[3]/p[1]/a";"Frequency";"Frequency";"Frequency
          provides a simple interface for maintaining counts and percentages of discrete
          values.";"unknown";"Frequency";"org.apache.commons.math3.stat.Frequency"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[4]/p[1]/a";"SimpleRegression";"SimpleRegression provides ordinary least squares regression with";"SimpleRegression provides ordinary least squares regression with
         one independent variable estimating the linear model:";"class";"SimpleRegression";"org.apache.commons.math3.stat.regression.SimpleRegression"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[4]/ul[1]/li[3]/a";"SimpleRegression(boolean)";"SimpleRegression(boolean) constructor.";"The intercept term may be suppressed by passing false to the
           
           SimpleRegression(boolean) constructor.  When the hasIntercept
           property is false, the model is estimated without a constant term and
           getIntercept() returns 0.";"method";"SimpleRegression";"org.apache.commons.math3.stat.regression.SimpleRegression.SimpleRegression"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[4]/ul[1]/li[3]/tt[2]";"hasIntercept";"When the hasIntercept";"The intercept term may be suppressed by passing false to the
           
           SimpleRegression(boolean) constructor.  When the hasIntercept
           property is false, the model is estimated without a constant term and
           getIntercept() returns 0.";"class";"hasIntercept";"org.apache.commons.math3.stat.regression.SimpleRegression.hasIntercept"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[4]/ul[1]/li[3]/tt[3]";"getIntercept()";"getIntercept() returns 0.";"The intercept term may be suppressed by passing false to the
           
           SimpleRegression(boolean) constructor.  When the hasIntercept
           property is false, the model is estimated without a constant term and
           getIntercept() returns 0.";"method";"getIntercept";"org.apache.commons.math3.stat.regression.SimpleRegression.getIntercept"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[1]/a[1]";"OLSMultipleLinearRegression";"OLSMultipleLinearRegression and";"OLSMultipleLinearRegression and
         
         GLSMultipleLinearRegression provide least squares regression to fit the linear model:";"class";"OLSMultipleLinearRegression";"org.apache.commons.math3.stat.regression.OLSMultipleLinearRegression"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[1]/a[2]";"GLSMultipleLinearRegression";"GLSMultipleLinearRegression provide least squares regression to fit the linear model:";"OLSMultipleLinearRegression and
         
         GLSMultipleLinearRegression provide least squares regression to fit the linear model:";"class";"GLSMultipleLinearRegression";"org.apache.commons.math3.stat.regression.GLSMultipleLinearRegression"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[4]/a[1]";"OLSMultipleLinearRegression";"OLSMultipleLinearRegression provides Ordinary Least Squares Regression, and";"OLSMultipleLinearRegression provides Ordinary Least Squares Regression, and 
          
          GLSMultipleLinearRegression implements Generalized Least Squares.  See the javadoc for these
          classes for details on the algorithms and forumlas used.";"class";"OLSMultipleLinearRegression";"org.apache.commons.math3.stat.regression.OLSMultipleLinearRegression"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div";"Complex";"7 Complex Numbers";"7 Complex Numbers";"class";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[4]/a[2]";"GLSMultipleLinearRegression";"GLSMultipleLinearRegression implements Generalized Least Squares.";"OLSMultipleLinearRegression provides Ordinary Least Squares Regression, and 
          
          GLSMultipleLinearRegression implements Generalized Least Squares.  See the javadoc for these
          classes for details on the algorithms and forumlas used.";"class";"GLSMultipleLinearRegression";"org.apache.commons.math3.stat.regression.GLSMultipleLinearRegression"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[1]";"AbstractMultipleLinearRegression";"AbstractMultipleLinearRegression#newSampleData(double[],int,int),";"Data for OLS models can be loaded in a single double[] array, consisting of concatenated rows of data, each containing
           the regressand (Y) value, followed by regressor values; or using a double[][] array with rows corresponding to
           observations. GLS models also require a double[][] array representing the covariance matrix of the error terms.  See
           
           AbstractMultipleLinearRegression#newSampleData(double[],int,int),  
           
           OLSMultipleLinearRegression#newSampleData(double[], double[][]) and 
           
           GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"class";"AbstractMultipleLinearRegression";"org.apache.commons.math3.stat.regression.AbstractMultipleLinearRegression"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[2]";"Complex";"7.2 Complex Numbers";"7.2 Complex Numbers";"class";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[2]";"OLSMultipleLinearRegression";"OLSMultipleLinearRegression#newSampleData(double[], double[][]) and";"Data for OLS models can be loaded in a single double[] array, consisting of concatenated rows of data, each containing
           the regressand (Y) value, followed by regressor values; or using a double[][] array with rows corresponding to
           observations. GLS models also require a double[][] array representing the covariance matrix of the error terms.  See
           
           AbstractMultipleLinearRegression#newSampleData(double[],int,int),  
           
           OLSMultipleLinearRegression#newSampleData(double[], double[][]) and 
           
           GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"class";"OLSMultipleLinearRegression";"org.apache.commons.math3.stat.regression.OLSMultipleLinearRegression"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[3]";"Complex";"7.3 Complex Transcendental Functions";"7.3 Complex Transcendental Functions";"class";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[3]";"GLSMultipleLinearRegression";"GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"Data for OLS models can be loaded in a single double[] array, consisting of concatenated rows of data, each containing
           the regressand (Y) value, followed by regressor values; or using a double[][] array with rows corresponding to
           observations. GLS models also require a double[][] array representing the covariance matrix of the error terms.  See
           
           AbstractMultipleLinearRegression#newSampleData(double[],int,int),  
           
           OLSMultipleLinearRegression#newSampleData(double[], double[][]) and 
           
           GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"class";"GLSMultipleLinearRegression";"org.apache.commons.math3.stat.regression.GLSMultipleLinearRegression"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]";"Complex";"7.4 Complex Formatting and Parsing";"7.4 Complex Formatting and Parsing";"class";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[1]/a[2]";"RankingAlgorithm";"RankingAlgorithm defines the interface for ranking.";"Some statistical algorithms require that input data be replaced by ranks.
         The 
         org.apache.commons.math3.stat.ranking package provides rank transformation.
         
         RankingAlgorithm defines the interface for ranking.  
         
         NaturalRanking provides an implementation that has two configuration options.";"class";"RankingAlgorithm";"org.apache.commons.math3.stat.ranking.RankingAlgorithm"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[1]/a[3]";"NaturalRanking";"NaturalRanking provides an implementation that has two configuration options.";"Some statistical algorithms require that input data be replaced by ranks.
         The 
         org.apache.commons.math3.stat.ranking package provides rank transformation.
         
         RankingAlgorithm defines the interface for ranking.  
         
         NaturalRanking provides an implementation that has two configuration options.";"class";"NaturalRanking";"org.apache.commons.math3.stat.ranking.NaturalRanking"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[3]/tt[1]";"NaNStrategy";"The default NaNStrategy is NaNStrategy.";"The default NaNStrategy is NaNStrategy.MAXIMAL.  This makes NaN
        values larger than any other value (including Double.POSITIVE_INFINITY). The
        default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied
        values the average of the ranks applicable to the sequence of ties.  See the 
        
        NaturalRanking for more examples and 
        TiesStrategy and NaNStrategy
        for details on these configuration options.";"class";"NaNStrategy";"org.apache.commons.math3.stat.ranking.NaNStrategy"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[1]";"Interval";"Interval and";"Interval and 
          IntervalsSet represent one dimensional regions. All classical set operations are available
          for intervals sets: union, intersection, symmetric difference (exclusive or), difference, complement,
          as well as region predicates (point inside/outside/on boundary, emptiness, other region contained).
          It is also possible to compute geometrical properties like size, barycenter or boundary size.
          Intervals sets can be built by constructive geometry (union, intersection ...) or from a boundary
          representation.";"unknown";"Interval";"org.apache.commons.math3.geometry.euclidean.oned.Interval"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[1]/a[2]";"IntervalsSet";"IntervalsSet represent one dimensional regions.";"Interval and 
          IntervalsSet represent one dimensional regions. All classical set operations are available
          for intervals sets: union, intersection, symmetric difference (exclusive or), difference, complement,
          as well as region predicates (point inside/outside/on boundary, emptiness, other region contained).
          It is also possible to compute geometrical properties like size, barycenter or boundary size.
          Intervals sets can be built by constructive geometry (union, intersection ...) or from a boundary
          representation.";"class";"IntervalsSet";"org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[2]/a";"PolygonsSet";"PolygonsSet represent two dimensional regions.";"PolygonsSet represent two dimensional regions. All classical set operations are available
          for polygons sets: union, intersection, symmetric difference (exclusive or), difference, complement,
          as well as region predicates (point inside/outside/on boundary, emptiness, other region contained).
          It is also possible to compute geometrical properties like size, barycenter or boundary size and
          to extract the vertices. Polygons sets can be built by constructive geometry (union, intersection ...)
          or from a boundary representation.";"class";"PolygonsSet";"org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[3]/a";"PolyhedronsSet";"PolyhedronsSet represent three dimensional regions.";"PolyhedronsSet represent three dimensional regions. All classical set operations are available
          for polyhedrons sets: union, intersection, symmetric difference (exclusive or), difference, complement,
          as well as region predicates (point inside/outside/on boundary, emptiness, other region contained).
          It is also possible to compute geometrical properties like size, barycenter or boundary size and
          to extract the vertices. Polyhedrons sets can be built by constructive geometry (union, intersection ...)
          or from a boundary representation.";"class";"PolyhedronsSet";"org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[4]/a";"Vector3D";"Vector3D provides a simple vector type.";"Vector3D provides a simple vector type. One important feature is
          that instances of this class are guaranteed
          to be immutable, this greatly simplifies modelling dynamical systems
          with changing states: once a vector has been computed, a reference to it
          is known to preserve its state as long as the reference itself is preserved.";"unknown";"Vector3D";"org.apache.commons.math3.geometry.euclidean.threed.Vector3D"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[3]/tt[4]";"TiesStrategy";"default TiesStrategy is TiesStrategy.";"The default NaNStrategy is NaNStrategy.MAXIMAL.  This makes NaN
        values larger than any other value (including Double.POSITIVE_INFINITY). The
        default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied
        values the average of the ranks applicable to the sequence of ties.  See the 
        
        NaturalRanking for more examples and 
        TiesStrategy and NaNStrategy
        for details on these configuration options.";"class";"TiesStrategy";"org.apache.commons.math3.stat.ranking.TiesStrategy"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[7]/a";"Vector3DFormat";"Vector3DFormat is a specialized format for formatting output or parsing";"Vector3DFormat is a specialized format for formatting output or parsing
          input with text representation of 3D vectors.";"class";"Vector3DFormat";"org.apache.commons.math3.geometry.euclidean.threed.Vector3DFormat"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[3]/tt[5]";"TiesStrategy.AVERAGE";"default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied";"The default NaNStrategy is NaNStrategy.MAXIMAL.  This makes NaN
        values larger than any other value (including Double.POSITIVE_INFINITY). The
        default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied
        values the average of the ranks applicable to the sequence of ties.  See the 
        
        NaturalRanking for more examples and 
        TiesStrategy and NaNStrategy
        for details on these configuration options.";"class";"TiesStrategy";"org.apache.commons.math3.stat.ranking.TiesStrategy"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[3]/tt[5]";"TiesStrategy.AVERAGE";"default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied";"The default NaNStrategy is NaNStrategy.MAXIMAL.  This makes NaN
        values larger than any other value (including Double.POSITIVE_INFINITY). The
        default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied
        values the average of the ranks applicable to the sequence of ties.  See the 
        
        NaturalRanking for more examples and 
        TiesStrategy and NaNStrategy
        for details on these configuration options.";"field";"AVERAGE";"org.apache.commons.math3.stat.ranking.TiesStrategy.AVERAGE"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[8]/a";"Rotation";"Rotation represents 3D rotations.";"Rotation represents 3D rotations.
          Rotation instances are also immutable objects, as Vector3D instances.";"unknown";"Rotation";"org.apache.commons.math3.geometry.euclidean.threed.Rotation"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[3]/a[1]";"NaturalRanking";"NaturalRanking for more examples and";"The default NaNStrategy is NaNStrategy.MAXIMAL.  This makes NaN
        values larger than any other value (including Double.POSITIVE_INFINITY). The
        default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied
        values the average of the ranks applicable to the sequence of ties.  See the 
        
        NaturalRanking for more examples and 
        TiesStrategy and NaNStrategy
        for details on these configuration options.";"class";"NaturalRanking";"org.apache.commons.math3.stat.ranking.NaturalRanking"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[9]/tt";"Rotation";"Rotations can be represented by several different mathematical";"Rotations can be represented by several different mathematical
          entities (matrices, axe and angle, Cardan or Euler angles,
          quaternions). This class presents a higher level abstraction, more
          user-oriented and hiding implementation details. Well, for the
          curious, we use quaternions for the internal representation. The user
          can build a rotation from any of these representations, and any of
          these representations can be retrieved from a Rotation
          instance (see the various constructors and getters). In addition, a
          rotation can also be built implicitely from a set of vectors and their
          image.";"unknown";"Rotation";"org.apache.commons.math3.geometry.euclidean.threed.Rotation"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[3]/a[2]";"TiesStrategy";"TiesStrategy and NaNStrategy";"The default NaNStrategy is NaNStrategy.MAXIMAL.  This makes NaN
        values larger than any other value (including Double.POSITIVE_INFINITY). The
        default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied
        values the average of the ranks applicable to the sequence of ties.  See the 
        
        NaturalRanking for more examples and 
        TiesStrategy and NaNStrategy
        for details on these configuration options.";"class";"TiesStrategy";"org.apache.commons.math3.stat.ranking.TiesStrategy"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[6]/p[3]/a[3]";"NaNStrategy";"The default NaNStrategy is NaNStrategy.";"The default NaNStrategy is NaNStrategy.MAXIMAL.  This makes NaN
        values larger than any other value (including Double.POSITIVE_INFINITY). The
        default TiesStrategy is TiesStrategy.AVERAGE, which assigns tied
        values the average of the ranks applicable to the sequence of ties.  See the 
        
        NaturalRanking for more examples and 
        TiesStrategy and NaNStrategy
        for details on these configuration options.";"class";"NaNStrategy";"org.apache.commons.math3.stat.ranking.NaNStrategy"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[13]/tt[4]";"applyInverseTo(Vector3D)";"applyInverseTo(Vector3D).";"These examples show that a rotation means what the user wants it to
          mean, so this class does not push the user towards one specific
          definition and hence does not provide methods like
          projectVectorIntoDestinationFrame or
          computeTransformedDirection. It provides simpler and more
          generic methods: applyTo(Vector3D) and
          applyInverseTo(Vector3D).";"method";"applyInverseTo";"org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyInverseTo"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/p[1]/a[2]";"Covariance";"Covariance computes covariances,";"The 
          org.apache.commons.math3.stat.correlation package computes covariances
          and correlations for pairs of arrays or columns of a matrix.
          
          Covariance computes covariances, 
          
          PearsonsCorrelation provides Pearson's Product-Moment correlation coefficients and
          
          SpearmansCorrelation computes Spearman's rank correlation.";"unknown";"Covariance";"org.apache.commons.math3.stat.correlation.Covariance"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/p[1]/a[3]";"PearsonsCorrelation";"PearsonsCorrelation provides Pearson's Product-Moment correlation coefficients and";"The 
          org.apache.commons.math3.stat.correlation package computes covariances
          and correlations for pairs of arrays or columns of a matrix.
          
          Covariance computes covariances, 
          
          PearsonsCorrelation provides Pearson's Product-Moment correlation coefficients and
          
          SpearmansCorrelation computes Spearman's rank correlation.";"class";"PearsonsCorrelation";"org.apache.commons.math3.stat.correlation.PearsonsCorrelation"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/p[1]/a[4]";"SpearmansCorrelation";"SpearmansCorrelation computes Spearman's rank correlation.";"The 
          org.apache.commons.math3.stat.correlation package computes covariances
          and correlations for pairs of arrays or columns of a matrix.
          
          Covariance computes covariances, 
          
          PearsonsCorrelation provides Pearson's Product-Moment correlation coefficients and
          
          SpearmansCorrelation computes Spearman's rank correlation.";"class";"SpearmansCorrelation";"org.apache.commons.math3.stat.correlation.SpearmansCorrelation"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[14]/tt[8]";"applyInverseTo(Rotation)";"applyInverseTo(Rotation).";"Since a rotation is basically a vectorial operator, several
          rotations can be composed together and the composite operation
          r = r1 o r2 (which means that for each
          vector u, r(u) = r1(r2(u)))
          is also a rotation. Hence we can consider that in addition to vectors, a
          rotation can be applied to other rotations as well (or to itself). With our
          previous notations, we would say we can apply r1 to
          r2 and the result we get is r =
          r1 o r2. For this purpose, the class
          provides the methods: applyTo(Rotation) and
          applyInverseTo(Rotation).";"method";"applyInverseTo";"org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyInverseTo"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/ul/li[1]/tt[7]";"n - 1.";"n in place of n - 1.  Whether or not covariances are";"Unbiased covariances are given by the formula cov(X, Y) = sum [(xi - E(X))(yi - E(Y))] / (n - 1)
            where E(X) is the mean of X and E(Y)
           is the mean of the Y values. Non-bias-corrected estimates use 
           n in place of n - 1.  Whether or not covariances are
           bias-corrected is determined by the optional parameter, ""biasCorrected,"" which
           defaults to true.";"unknown";"n";"org.apache.commons.math3.stat.descriptive.moment.FirstMoment.n"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/ul/li[2]/a";"PearsonsCorrelation";"PearsonsCorrelation computes correlations defined by the formula cor(X, Y) = sum[(xi - E(X))(yi - E(Y))] / [(n - 1)s(X)s(Y)]";"PearsonsCorrelation computes correlations defined by the formula cor(X, Y) = sum[(xi - E(X))(yi - E(Y))] / [(n - 1)s(X)s(Y)]
          where E(X) and E(Y) are means of X and Y
          and s(X), s(Y) are standard deviations.";"class";"PearsonsCorrelation";"org.apache.commons.math3.stat.correlation.PearsonsCorrelation"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/a[1]";"SpearmansCorrelation";"SpearmansCorrelation applies a rank transformation to the input data and computes Pearson's";"SpearmansCorrelation applies a rank transformation to the input data and computes Pearson's
          correlation on the ranked data.  The ranking algorithm is configurable. By default, 
          
          NaturalRanking with default strategies for handling ties and NaN values is used.";"class";"SpearmansCorrelation";"org.apache.commons.math3.stat.correlation.SpearmansCorrelation"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/ul/li[3]/a[2]";"NaturalRanking";"NaturalRanking with default strategies for handling ties and NaN values is used.";"SpearmansCorrelation applies a rank transformation to the input data and computes Pearson's
          correlation on the ranked data.  The ranking algorithm is configurable. By default, 
          
          NaturalRanking with default strategies for handling ties and NaN values is used.";"class";"NaturalRanking";"org.apache.commons.math3.stat.ranking.NaturalRanking"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/dl/dd[5]/tt[1]";"PearsonsCorrelation";"PearsonsCorrelation instance";"To compute standard errors and/or significances of correlation coefficients
          associated with Pearson's correlation coefficients, start by creating a
          PearsonsCorrelation instance
          
PearsonsCorrelation correlation = new PearsonsCorrelation(data);
          
          where data is either a rectangular array or a RealMatrix.
          Then the matrix of standard errors is
          
correlation.getCorrelationStandardErrors();
          
          The formula used to compute the standard error is SEr = ((1 - r2) / (n - 2))1/2
           where r is the estimated correlation coefficient and 
          n is the number of observations in the source dataset.p-values for the (2-sided) null hypotheses that elements of
          a correlation matrix are zero populate the RealMatrix returned by
          
correlation.getCorrelationPValues()
          
          getCorrelationPValues().getEntry(i,j) is the
          probability that a random variable distributed as tn-2 takes
           a value with absolute value greater than or equal to |rij|((n - 2) / (1 - rij2))1/2,
           where rij is the estimated correlation between the ith and jth
           columns of the source array or RealMatrix. This is sometimes referred to as the 
           significance of the coefficient.
           For example, if data is a RealMatrix with 2 columns and 10 rows, then 
           
new PearsonsCorrelation(data).getCorrelationPValues().getEntry(0,1)
           
           is the significance of the Pearson's correlation coefficient between the two columns
           of data.  If this value is less than .01, we can say that the correlation
           between the two columns of data is significant at the 99% level.";"class";"PearsonsCorrelation";"org.apache.commons.math3.stat.correlation.PearsonsCorrelation"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/dl/dd[5]/tt[3]";"RealMatrix";"where data is either a rectangular array or a RealMatrix.";"To compute standard errors and/or significances of correlation coefficients
          associated with Pearson's correlation coefficients, start by creating a
          PearsonsCorrelation instance
          
PearsonsCorrelation correlation = new PearsonsCorrelation(data);
          
          where data is either a rectangular array or a RealMatrix.
          Then the matrix of standard errors is
          
correlation.getCorrelationStandardErrors();
          
          The formula used to compute the standard error is SEr = ((1 - r2) / (n - 2))1/2
           where r is the estimated correlation coefficient and 
          n is the number of observations in the source dataset.p-values for the (2-sided) null hypotheses that elements of
          a correlation matrix are zero populate the RealMatrix returned by
          
correlation.getCorrelationPValues()
          
          getCorrelationPValues().getEntry(i,j) is the
          probability that a random variable distributed as tn-2 takes
           a value with absolute value greater than or equal to |rij|((n - 2) / (1 - rij2))1/2,
           where rij is the estimated correlation between the ith and jth
           columns of the source array or RealMatrix. This is sometimes referred to as the 
           significance of the coefficient.
           For example, if data is a RealMatrix with 2 columns and 10 rows, then 
           
new PearsonsCorrelation(data).getCorrelationPValues().getEntry(0,1)
           
           is the significance of the Pearson's correlation coefficient between the two columns
           of data.  If this value is less than .01, we can say that the correlation
           between the two columns of data is significant at the 99% level.";"class";"RealMatrix";"org.apache.commons.math3.linear.RealMatrix"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/dl/dd[5]/tt[7]";"getCorrelationPValues().getEntry(i,j)";"getCorrelationPValues().getEntry(i,j) is the";"To compute standard errors and/or significances of correlation coefficients
          associated with Pearson's correlation coefficients, start by creating a
          PearsonsCorrelation instance
          
PearsonsCorrelation correlation = new PearsonsCorrelation(data);
          
          where data is either a rectangular array or a RealMatrix.
          Then the matrix of standard errors is
          
correlation.getCorrelationStandardErrors();
          
          The formula used to compute the standard error is SEr = ((1 - r2) / (n - 2))1/2
           where r is the estimated correlation coefficient and 
          n is the number of observations in the source dataset.p-values for the (2-sided) null hypotheses that elements of
          a correlation matrix are zero populate the RealMatrix returned by
          
correlation.getCorrelationPValues()
          
          getCorrelationPValues().getEntry(i,j) is the
          probability that a random variable distributed as tn-2 takes
           a value with absolute value greater than or equal to |rij|((n - 2) / (1 - rij2))1/2,
           where rij is the estimated correlation between the ith and jth
           columns of the source array or RealMatrix. This is sometimes referred to as the 
           significance of the coefficient.
           For example, if data is a RealMatrix with 2 columns and 10 rows, then 
           
new PearsonsCorrelation(data).getCorrelationPValues().getEntry(0,1)
           
           is the significance of the Pearson's correlation coefficient between the two columns
           of data.  If this value is less than .01, we can say that the correlation
           between the two columns of data is significant at the 99% level.";"method";"getCorrelationPValues";"org.apache.commons.math3.stat.correlation.PearsonsCorrelation.getCorrelationPValues"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/dl/dd[5]/tt[7]";"getEntry(i,j)";"getCorrelationPValues().getEntry(i,j) is the";"To compute standard errors and/or significances of correlation coefficients
          associated with Pearson's correlation coefficients, start by creating a
          PearsonsCorrelation instance
          
PearsonsCorrelation correlation = new PearsonsCorrelation(data);
          
          where data is either a rectangular array or a RealMatrix.
          Then the matrix of standard errors is
          
correlation.getCorrelationStandardErrors();
          
          The formula used to compute the standard error is SEr = ((1 - r2) / (n - 2))1/2
           where r is the estimated correlation coefficient and 
          n is the number of observations in the source dataset.p-values for the (2-sided) null hypotheses that elements of
          a correlation matrix are zero populate the RealMatrix returned by
          
correlation.getCorrelationPValues()
          
          getCorrelationPValues().getEntry(i,j) is the
          probability that a random variable distributed as tn-2 takes
           a value with absolute value greater than or equal to |rij|((n - 2) / (1 - rij2))1/2,
           where rij is the estimated correlation between the ith and jth
           columns of the source array or RealMatrix. This is sometimes referred to as the 
           significance of the coefficient.
           For example, if data is a RealMatrix with 2 columns and 10 rows, then 
           
new PearsonsCorrelation(data).getCorrelationPValues().getEntry(0,1)
           
           is the significance of the Pearson's correlation coefficient between the two columns
           of data.  If this value is less than .01, we can say that the correlation
           between the two columns of data is significant at the 99% level.";"method";"getEntry";"org.apache.commons.math3.linear.RealMatrix.getEntry"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[3]";"Space";"11.3 Binary Space Partitioning";"11.3 Binary Space Partitioning";"class";"Space";"org.apache.commons.math3.geometry.Space"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/a[9]";"TTest";"TTest,";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"TTest";"org.apache.commons.math3.stat.inference.TTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/a[10]";"ChiSquareTest";"ChiSquareTest,";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"ChiSquareTest";"org.apache.commons.math3.stat.inference.ChiSquareTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/a[11]";"GTest";"GTest,";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"GTest";"org.apache.commons.math3.stat.inference.GTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/a[12]";"OneWayAnova";"OneWayAnova,";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"OneWayAnova";"org.apache.commons.math3.stat.inference.OneWayAnova"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/a[13]";"MannWhitneyUTest";"MannWhitneyUTest, and";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"MannWhitneyUTest";"org.apache.commons.math3.stat.inference.MannWhitneyUTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/a[14]";"WilcoxonSignedRankTest";"WilcoxonSignedRankTest.";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"WilcoxonSignedRankTest";"org.apache.commons.math3.stat.inference.WilcoxonSignedRankTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/a[15]";"TestUtils";"TestUtils class provides static methods to get test instances or";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"TestUtils";"org.apache.commons.math3.stat.inference.TestUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/tt[7]";"TestUtils";"static methods in TestUtils to execute tests.";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"TestUtils";"org.apache.commons.math3.stat.inference.TestUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/tt[8]";"TestUtils.getTTest()";", TestUtils.getTTest()";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"class";"TestUtils";"org.apache.commons.math3.stat.inference.TestUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/p[1]/tt[9]";"TTest()";"new TTest().";"The 
          org.apache.commons.math3.stat.inference package provides implementations for
          
          Student's t,
          
          Chi-Square, 
          G Test,
          
          One-Way ANOVA,
          
          Mann-Whitney U and
          
          Wilcoxon signed rank test statistics as well as
          
          p-values associated with t-,
          Chi-Square, G, One-Way ANOVA, Mann-Whitney U
          and Wilcoxon signed rank tests. The respective test classes are
          
          TTest,
          
          ChiSquareTest,
          
          GTest,
          
          OneWayAnova,
          
          MannWhitneyUTest, and
          
          WilcoxonSignedRankTest.          
          The 
          TestUtils class provides static methods to get test instances or
          to compute test statistics directly.  The examples below all use the
          static methods in TestUtils to execute tests.  To get
          test object instances, either use e.g., TestUtils.getTTest()
          or use the implementation constructors directly, e.g. new TTest().";"method";"TTest";"org.apache.commons.math3.stat.inference.TTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[2]/a";"StatisticalSummary";"StatisticalSummary  to a fixed value:";"To compare the mean of a dataset described by a
          
          StatisticalSummary  to a fixed value:
          
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i < observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));";"class";"StatisticalSummary";"org.apache.commons.math3.stat.descriptive.StatisticalSummary"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[5]/tt[5]";"TestUtils.pairedTTest(sample1, sample2)";"returned by TestUtils.pairedTTest(sample1, sample2)";"Example 1: Paired test evaluating
          the null hypothesis that the mean difference between corresponding
          (paired) elements of the double[] arrays
          sample1 and sample2 is zero.
          
          To compute the t-statistic:
          
TestUtils.pairedT(sample1, sample2);
          
           
           
           To compute the p-value:
           
TestUtils.pairedTTest(sample1, sample2);
           
           
           
           To perform a fixed significance level test with alpha = .05:
           
TestUtils.pairedTTest(sample1, sample2, .05);
           
           
           The last example will return true iff the p-value
           returned by TestUtils.pairedTTest(sample1, sample2)
           is less than .05";"class";"TestUtils";"org.apache.commons.math3.stat.inference.TestUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[5]/tt[5]";"TestUtils.pairedTTest(sample1, sample2)";"returned by TestUtils.pairedTTest(sample1, sample2)";"Example 1: Paired test evaluating
          the null hypothesis that the mean difference between corresponding
          (paired) elements of the double[] arrays
          sample1 and sample2 is zero.
          
          To compute the t-statistic:
          
TestUtils.pairedT(sample1, sample2);
          
           
           
           To compute the p-value:
           
TestUtils.pairedTTest(sample1, sample2);
           
           
           
           To perform a fixed significance level test with alpha = .05:
           
TestUtils.pairedTTest(sample1, sample2, .05);
           
           
           The last example will return true iff the p-value
           returned by TestUtils.pairedTTest(sample1, sample2)
           is less than .05";"method";"pairedTTest";"org.apache.commons.math3.stat.inference.TestUtils.pairedTTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[6]/tt";"StatisticalSummary";"StatisticalSummary instances, without assuming that";"Example 2:  unpaired, two-sided, two-sample t-test using
           StatisticalSummary instances, without assuming that
           subpopulation variances are equal.
           
           First create the StatisticalSummary instances.  Both
           DescriptiveStatistics and SummaryStatistics
           implement this interface.  Assume that summary1 and
           summary2 are SummaryStatistics instances,
           each of which has had at least 2 values added to the (virtual) dataset that
           it describes.  The sample sizes do not have to be the same -- all that is required
           is that both samples have at least 2 elements.
           
           Note: The SummaryStatistics class does
           not store the dataset that it describes in memory, but it does compute all
           statistics necessary to perform t-tests, so this method can be used to
           conduct t-tests with very large samples.  One-sample tests can also be
           performed this way.
           (See Descriptive statistics for details
           on the SummaryStatistics class.)
           
           
          To compute the t-statistic:
          
TestUtils.t(summary1, summary2);
          
           
           
           To compute the p-value:
           
TestUtils.tTest(sample1, sample2);
           
           
           
           To perform a fixed significance level test with alpha = .05:
           
TestUtils.tTest(sample1, sample2, .05);
           
           
           
           In each case above, the test does not assume that the subpopulation
           variances are equal.  To perform the tests under this assumption,
           replace ""t"" at the beginning of the method name with ""homoscedasticT""";"class";"StatisticalSummary";"org.apache.commons.math3.stat.descriptive.StatisticalSummary"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[6]/p[1]/tt[1]";"StatisticalSummary";"First create the StatisticalSummary instances.";"First create the StatisticalSummary instances.  Both
           DescriptiveStatistics and SummaryStatistics
           implement this interface.  Assume that summary1 and
           summary2 are SummaryStatistics instances,
           each of which has had at least 2 values added to the (virtual) dataset that
           it describes.  The sample sizes do not have to be the same -- all that is required
           is that both samples have at least 2 elements.";"class";"StatisticalSummary";"org.apache.commons.math3.stat.descriptive.StatisticalSummary"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[6]/p[1]/tt[2]";"DescriptiveStatistics";"DescriptiveStatistics and SummaryStatistics";"First create the StatisticalSummary instances.  Both
           DescriptiveStatistics and SummaryStatistics
           implement this interface.  Assume that summary1 and
           summary2 are SummaryStatistics instances,
           each of which has had at least 2 values added to the (virtual) dataset that
           it describes.  The sample sizes do not have to be the same -- all that is required
           is that both samples have at least 2 elements.";"class";"DescriptiveStatistics";"org.apache.commons.math3.stat.descriptive.DescriptiveStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[6]/p[1]/tt[3]";"SummaryStatistics";"DescriptiveStatistics and SummaryStatistics";"First create the StatisticalSummary instances.  Both
           DescriptiveStatistics and SummaryStatistics
           implement this interface.  Assume that summary1 and
           summary2 are SummaryStatistics instances,
           each of which has had at least 2 values added to the (virtual) dataset that
           it describes.  The sample sizes do not have to be the same -- all that is required
           is that both samples have at least 2 elements.";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[6]/p[1]/tt[6]";"SummaryStatistics";"summary2 are SummaryStatistics instances,";"First create the StatisticalSummary instances.  Both
           DescriptiveStatistics and SummaryStatistics
           implement this interface.  Assume that summary1 and
           summary2 are SummaryStatistics instances,
           each of which has had at least 2 values added to the (virtual) dataset that
           it describes.  The sample sizes do not have to be the same -- all that is required
           is that both samples have at least 2 elements.";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[6]/p[2]/tt[1]";"SummaryStatistics";"Note: The SummaryStatistics class does";"Note: The SummaryStatistics class does
           not store the dataset that it describes in memory, but it does compute all
           statistics necessary to perform t-tests, so this method can be used to
           conduct t-tests with very large samples.  One-sample tests can also be
           performed this way.
           (See Descriptive statistics for details
           on the SummaryStatistics class.)";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[6]/p[2]/tt[2]";"SummaryStatistics";"on the SummaryStatistics class.";"Note: The SummaryStatistics class does
           not store the dataset that it describes in memory, but it does compute all
           statistics necessary to perform t-tests, so this method can be used to
           conduct t-tests with very large samples.  One-sample tests can also be
           performed this way.
           (See Descriptive statistics for details
           on the SummaryStatistics class.)";"class";"SummaryStatistics";"org.apache.commons.math3.stat.descriptive.SummaryStatistics"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[13]/tt";"GTest";"root log likelihood ratio provided by the GTest class.";"G tests are an alternative to chi-square tests that are recommended
          when observed counts are small and / or incidence probabillities for 
          some cells are small. See Ted Dunning's paper,
          
          Accurate Methods for the Statistics of Surprise and Coincidence for
          background and an empirical analysis showing now chi-square
          statistics can be misldeading in the presence of low incidence probabilities.
          This paper also derives the formulas used in computing G statistics and the
          root log likelihood ratio provided by the GTest class.";"class";"GTest";"org.apache.commons.math3.stat.inference.GTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/tt[1]";"OneWayAnova";"using a OneWayAnova instance or TestUtils";"One-sample t tests
          To compare the mean of a double[] array to a fixed value:
          
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          
          The code above will display the t-statisitic associated with a one-sample
           t-test comparing the mean of the observed values against
           mu.
          
          To compare the mean of a dataset described by a
          
          StatisticalSummary  to a fixed value:
          
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i < observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));

           
           To compute the p-value associated with the null hypothesis that the mean
            of a set of values equals a point estimate, against the two-sided alternative that
            the mean is different from the target value:
            
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           
          The snippet above will display the p-value associated with the null
          hypothesis that the mean of the population from which the
          observed values are drawn equals mu.
          
          To perform the test using a fixed significance level, use:
          
TestUtils.tTest(mu, observed, alpha);
          
          where 0 < alpha < 0.5 is the significance level of
          the test.  The boolean value returned will be true iff the
          null hypothesis can be rejected with confidence 1 - alpha.
          To test, for example at the 95% level of confidence, use
          alpha = 0.05
          
          Two-Sample t-tests
          Example 1: Paired test evaluating
          the null hypothesis that the mean difference between corresponding
          (paired) elements of the double[] arrays
          sample1 and sample2 is zero.
          
          To compute the t-statistic:
          
TestUtils.pairedT(sample1, sample2);
          
           
           
           To compute the p-value:
           
TestUtils.pairedTTest(sample1, sample2);
           
           
           
           To perform a fixed significance level test with alpha = .05:
           
TestUtils.pairedTTest(sample1, sample2, .05);
           
           
           The last example will return true iff the p-value
           returned by TestUtils.pairedTTest(sample1, sample2)
           is less than .05
           
           Example 2:  unpaired, two-sided, two-sample t-test using
           StatisticalSummary instances, without assuming that
           subpopulation variances are equal.
           
           First create the StatisticalSummary instances.  Both
           DescriptiveStatistics and SummaryStatistics
           implement this interface.  Assume that summary1 and
           summary2 are SummaryStatistics instances,
           each of which has had at least 2 values added to the (virtual) dataset that
           it describes.  The sample sizes do not have to be the same -- all that is required
           is that both samples have at least 2 elements.
           
           Note: The SummaryStatistics class does
           not store the dataset that it describes in memory, but it does compute all
           statistics necessary to perform t-tests, so this method can be used to
           conduct t-tests with very large samples.  One-sample tests can also be
           performed this way.
           (See Descriptive statistics for details
           on the SummaryStatistics class.)
           
           
          To compute the t-statistic:
          
TestUtils.t(summary1, summary2);
          
           
           
           To compute the p-value:
           
TestUtils.tTest(sample1, sample2);
           
           
           
           To perform a fixed significance level test with alpha = .05:
           
TestUtils.tTest(sample1, sample2, .05);
           
           
           
           In each case above, the test does not assume that the subpopulation
           variances are equal.  To perform the tests under this assumption,
           replace ""t"" at the beginning of the method name with ""homoscedasticT""
           
           
           Chi-square tests
          To compute a chi-square statistic measuring the agreement between a
          long[] array of observed counts and a double[]
          array of expected counts, use:
          
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          
          the value displayed will be
          sum((expected[i] - observed[i])^2 / expected[i])
          
           To get the p-value associated with the null hypothesis that
          observed conforms to expected use:
          
TestUtils.chiSquareTest(expected, observed);
          
          
           To test the null hypothesis that observed conforms to
          expected with alpha siginficance level
          (equiv. 100 * (1-alpha)% confidence) where 
          0 < alpha < 1  use:
          
TestUtils.chiSquareTest(expected, observed, alpha);
          
          The boolean value returned will be true iff the null hypothesis
          can be rejected with confidence 1 - alpha.
          
          To compute a chi-square statistic statistic associated with a
          
          chi-square test of independence based on a two-dimensional (long[][])
          counts array viewed as a two-way table, use:
          
TestUtils.chiSquareTest(counts);
          
          The rows of the 2-way table are
          count[0], ... , count[count.length - 1]. 
          The chi-square statistic returned is
          sum((counts[i][j] - expected[i][j])^2/expected[i][j])
          where the sum is taken over all table entries and
          expected[i][j] is the product of the row and column sums at
          row i, column j divided by the total count.
          
          To compute the p-value associated with the null hypothesis that
          the classifications represented by the counts in the columns of the input 2-way
          table are independent of the rows, use:
          
 TestUtils.chiSquareTest(counts);
          
          
          To perform a chi-square test of independence with alpha
          siginficance level (equiv. 100 * (1-alpha)% confidence)
          where 0 < alpha < 1  use:
          
TestUtils.chiSquareTest(counts, alpha);
          
          The boolean value returned will be true iff the null
          hypothesis can be rejected with confidence 1 - alpha.
          
          G tests
          G tests are an alternative to chi-square tests that are recommended
          when observed counts are small and / or incidence probabillities for 
          some cells are small. See Ted Dunning's paper,
          
          Accurate Methods for the Statistics of Surprise and Coincidence for
          background and an empirical analysis showing now chi-square
          statistics can be misldeading in the presence of low incidence probabilities.
          This paper also derives the formulas used in computing G statistics and the
          root log likelihood ratio provided by the GTest class.
          
          To compute a G-test statistic measuring the agreement between a
          long[] array of observed counts and a double[]
          array of expected counts, use:
          
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          
          the value displayed will be
          2 * sum(observed[i]) * log(observed[i]/expected[i])
          
           To get the p-value associated with the null hypothesis that
          observed conforms to expected use:
          
TestUtils.gTest(expected, observed);
          
          
           To test the null hypothesis that observed conforms to
          expected with alpha siginficance level
          (equiv. 100 * (1-alpha)% confidence) where 
          0 < alpha < 1  use:
          
TestUtils.gTest(expected, observed, alpha);
          
          The boolean value returned will be true iff the null hypothesis
          can be rejected with confidence 1 - alpha.
          
          To evaluate the hypothesis that two sets of counts come from the
          same underlying distribution, use long[] arrays for the counts and
          gDataSetsComparison for the test statistic
          
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          
          
          For 2 x 2 designs, the rootLogLikelihoodRaio method
          computes the
          
          signed root log likelihood ratio.  For example, suppose that for two events
          A and B, the observed count of AB (both occurring) is 5, not A and B (B without A)
          is 1995, A not B is 0; and neither A nor B is 10000.  Then
          
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          
          returns the root log likelihood associated with the null hypothesis that A 
          and B are independent.
          
          One-Way Anova tests
          
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          
          Then you can compute ANOVA F- or p-values associated with the
          null hypothesis that the class means are all the same
          using a OneWayAnova instance or TestUtils
          methods:
          
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          
          To test perform a One-Way Anova test with signficance level set at 0.01
          (so the test will, assuming assumptions are met, reject the null
          hypothesis incorrectly only about one in 100 times), use
          
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis";"class";"OneWayAnova";"org.apache.commons.math3.stat.inference.OneWayAnova"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/tt[2]";"TestUtils";"TestUtils.";"One-sample t tests
          To compare the mean of a double[] array to a fixed value:
          
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.t(mu, observed));
          
          The code above will display the t-statisitic associated with a one-sample
           t-test comparing the mean of the observed values against
           mu.
          
          To compare the mean of a dataset described by a
          
          StatisticalSummary  to a fixed value:
          
double[] observed ={1d, 2d, 3d};
double mu = 2.5d;
SummaryStatistics sampleStats = new SummaryStatistics();
for (int i = 0; i < observed.length; i++) {
    sampleStats.addValue(observed[i]);
}
System.out.println(TestUtils.t(mu, observed));

           
           To compute the p-value associated with the null hypothesis that the mean
            of a set of values equals a point estimate, against the two-sided alternative that
            the mean is different from the target value:
            
double[] observed = {1d, 2d, 3d};
double mu = 2.5d;
System.out.println(TestUtils.tTest(mu, observed));
           
          The snippet above will display the p-value associated with the null
          hypothesis that the mean of the population from which the
          observed values are drawn equals mu.
          
          To perform the test using a fixed significance level, use:
          
TestUtils.tTest(mu, observed, alpha);
          
          where 0 < alpha < 0.5 is the significance level of
          the test.  The boolean value returned will be true iff the
          null hypothesis can be rejected with confidence 1 - alpha.
          To test, for example at the 95% level of confidence, use
          alpha = 0.05
          
          Two-Sample t-tests
          Example 1: Paired test evaluating
          the null hypothesis that the mean difference between corresponding
          (paired) elements of the double[] arrays
          sample1 and sample2 is zero.
          
          To compute the t-statistic:
          
TestUtils.pairedT(sample1, sample2);
          
           
           
           To compute the p-value:
           
TestUtils.pairedTTest(sample1, sample2);
           
           
           
           To perform a fixed significance level test with alpha = .05:
           
TestUtils.pairedTTest(sample1, sample2, .05);
           
           
           The last example will return true iff the p-value
           returned by TestUtils.pairedTTest(sample1, sample2)
           is less than .05
           
           Example 2:  unpaired, two-sided, two-sample t-test using
           StatisticalSummary instances, without assuming that
           subpopulation variances are equal.
           
           First create the StatisticalSummary instances.  Both
           DescriptiveStatistics and SummaryStatistics
           implement this interface.  Assume that summary1 and
           summary2 are SummaryStatistics instances,
           each of which has had at least 2 values added to the (virtual) dataset that
           it describes.  The sample sizes do not have to be the same -- all that is required
           is that both samples have at least 2 elements.
           
           Note: The SummaryStatistics class does
           not store the dataset that it describes in memory, but it does compute all
           statistics necessary to perform t-tests, so this method can be used to
           conduct t-tests with very large samples.  One-sample tests can also be
           performed this way.
           (See Descriptive statistics for details
           on the SummaryStatistics class.)
           
           
          To compute the t-statistic:
          
TestUtils.t(summary1, summary2);
          
           
           
           To compute the p-value:
           
TestUtils.tTest(sample1, sample2);
           
           
           
           To perform a fixed significance level test with alpha = .05:
           
TestUtils.tTest(sample1, sample2, .05);
           
           
           
           In each case above, the test does not assume that the subpopulation
           variances are equal.  To perform the tests under this assumption,
           replace ""t"" at the beginning of the method name with ""homoscedasticT""
           
           
           Chi-square tests
          To compute a chi-square statistic measuring the agreement between a
          long[] array of observed counts and a double[]
          array of expected counts, use:
          
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          
          the value displayed will be
          sum((expected[i] - observed[i])^2 / expected[i])
          
           To get the p-value associated with the null hypothesis that
          observed conforms to expected use:
          
TestUtils.chiSquareTest(expected, observed);
          
          
           To test the null hypothesis that observed conforms to
          expected with alpha siginficance level
          (equiv. 100 * (1-alpha)% confidence) where 
          0 < alpha < 1  use:
          
TestUtils.chiSquareTest(expected, observed, alpha);
          
          The boolean value returned will be true iff the null hypothesis
          can be rejected with confidence 1 - alpha.
          
          To compute a chi-square statistic statistic associated with a
          
          chi-square test of independence based on a two-dimensional (long[][])
          counts array viewed as a two-way table, use:
          
TestUtils.chiSquareTest(counts);
          
          The rows of the 2-way table are
          count[0], ... , count[count.length - 1]. 
          The chi-square statistic returned is
          sum((counts[i][j] - expected[i][j])^2/expected[i][j])
          where the sum is taken over all table entries and
          expected[i][j] is the product of the row and column sums at
          row i, column j divided by the total count.
          
          To compute the p-value associated with the null hypothesis that
          the classifications represented by the counts in the columns of the input 2-way
          table are independent of the rows, use:
          
 TestUtils.chiSquareTest(counts);
          
          
          To perform a chi-square test of independence with alpha
          siginficance level (equiv. 100 * (1-alpha)% confidence)
          where 0 < alpha < 1  use:
          
TestUtils.chiSquareTest(counts, alpha);
          
          The boolean value returned will be true iff the null
          hypothesis can be rejected with confidence 1 - alpha.
          
          G tests
          G tests are an alternative to chi-square tests that are recommended
          when observed counts are small and / or incidence probabillities for 
          some cells are small. See Ted Dunning's paper,
          
          Accurate Methods for the Statistics of Surprise and Coincidence for
          background and an empirical analysis showing now chi-square
          statistics can be misldeading in the presence of low incidence probabilities.
          This paper also derives the formulas used in computing G statistics and the
          root log likelihood ratio provided by the GTest class.
          
          To compute a G-test statistic measuring the agreement between a
          long[] array of observed counts and a double[]
          array of expected counts, use:
          
double[] expected = new double[]{0.54d, 0.40d, 0.05d, 0.01d};
long[] observed = new long[]{70, 79, 3, 4};
System.out.println(TestUtils.g(expected, observed));
          
          the value displayed will be
          2 * sum(observed[i]) * log(observed[i]/expected[i])
          
           To get the p-value associated with the null hypothesis that
          observed conforms to expected use:
          
TestUtils.gTest(expected, observed);
          
          
           To test the null hypothesis that observed conforms to
          expected with alpha siginficance level
          (equiv. 100 * (1-alpha)% confidence) where 
          0 < alpha < 1  use:
          
TestUtils.gTest(expected, observed, alpha);
          
          The boolean value returned will be true iff the null hypothesis
          can be rejected with confidence 1 - alpha.
          
          To evaluate the hypothesis that two sets of counts come from the
          same underlying distribution, use long[] arrays for the counts and
          gDataSetsComparison for the test statistic
          
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value
          
          
          For 2 x 2 designs, the rootLogLikelihoodRaio method
          computes the
          
          signed root log likelihood ratio.  For example, suppose that for two events
          A and B, the observed count of AB (both occurring) is 5, not A and B (B without A)
          is 1995, A not B is 0; and neither A nor B is 10000.  Then
          
new GTest().rootLogLikelihoodRatio(5, 1995, 0, 100000);
          
          returns the root log likelihood associated with the null hypothesis that A 
          and B are independent.
          
          One-Way Anova tests
          
double[] classA =
   {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };
double[] classB =
   {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };
double[] classC =
   {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };
List classes = new ArrayList();
classes.add(classA);
classes.add(classB);
classes.add(classC);
          
          Then you can compute ANOVA F- or p-values associated with the
          null hypothesis that the class means are all the same
          using a OneWayAnova instance or TestUtils
          methods:
          
double fStatistic = TestUtils.oneWayAnovaFValue(classes); // F-value
double pValue = TestUtils.oneWayAnovaPValue(classes);     // P-value
          
          To test perform a One-Way Anova test with signficance level set at 0.01
          (so the test will, assuming assumptions are met, reject the null
          hypothesis incorrectly only about one in 100 times), use
          
TestUtils.oneWayAnovaTest(classes, 0.01); // returns a boolean
                                          // true means reject null hypothesis";"class";"TestUtils";"org.apache.commons.math3.stat.inference.TestUtils"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[3]";"Frequency";"1.3 Frequency distributions";"1.3 Frequency distributions";"class";"Frequency";"org.apache.commons.math3.stat.Frequency"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]";"Covariance";"1.7 Covariance and correlation";"1.7 Covariance and correlation";"class";"Covariance";"org.apache.commons.math3.stat.correlation.Covariance"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[1]/a[1]";"UnivariateSolver";"UnivariateSolver,";"UnivariateSolver, 
          UnivariateDifferentiableSolver and 
          PolynomialSolver provide means to find roots of
          univariate real-valued functions,
          differentiable univariate real-valued functions,
          and polynomial functions respectively.
          A root is the value where the function takes the value 0.  Commons-Math
          includes implementations of the several root-finding algorithms:";"class";"UnivariateSolver";"org.apache.commons.math3.analysis.solvers.UnivariateSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[1]/a[2]";"UnivariateDifferentiableSolver";"UnivariateDifferentiableSolver and";"UnivariateSolver, 
          UnivariateDifferentiableSolver and 
          PolynomialSolver provide means to find roots of
          univariate real-valued functions,
          differentiable univariate real-valued functions,
          and polynomial functions respectively.
          A root is the value where the function takes the value 0.  Commons-Math
          includes implementations of the several root-finding algorithms:";"class";"UnivariateDifferentiableSolver";"org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[1]/a[3]";"PolynomialSolver";"PolynomialSolver provide means to find roots of";"UnivariateSolver, 
          UnivariateDifferentiableSolver and 
          PolynomialSolver provide means to find roots of
          univariate real-valued functions,
          differentiable univariate real-valued functions,
          and polynomial functions respectively.
          A root is the value where the function takes the value 0.  Commons-Math
          includes implementations of the several root-finding algorithms:";"class";"PolynomialSolver";"org.apache.commons.math3.analysis.solvers.PolynomialSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[4]/tt[7]";"ConvergenceException";"count is exceeded, non-convergence is assumed and a ConvergenceException";"In order to use the root-finding features, first a solver object must
          be created by calling its constructor, often providing relative and absolute
          accuracy. Using a solver object, roots of functions
          are easily found using the solve methods.  These methods takes
          a maximum iteration count maxEval, a function f,
          and either two domain values, min and max, or a
          startValue as parameters. If the maximal number of iterations
          count is exceeded, non-convergence is assumed and a ConvergenceException
          exception is thrown.  A suggested value is 100, which should be plenty, given that a
          bisection algorithm can't get any more accurate after 52 iterations because of the
          number of mantissa bits in a double precision floating point number. If a number of
          ill-conditioned problems is to be solved, this number can be decreased in order
          to avoid wasting time.
          Bracketed
          solvers also take an allowed solution
          enum parameter to specify which side of the final convergence interval should be
          selected as the root. It can be ANY_SIDE, LEFT_SIDE, RIGHT_SIDE,
          BELOW_SIDE or ABOVE_SIDE. Left and right are used to specify the root along
          the function parameter axis while below and above refer to the function value axis. The solve methods
          compute a value c such that:";"class";"ConvergenceException";"org.apache.commons.math3.exception.ConvergenceException"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[7]/tt";"BrentSolver";"The BrentSolver uses the Brent-Dekker algorithm which is";"The BrentSolver uses the Brent-Dekker algorithm which is
          fast and robust.  If there are multiple roots in the interval,
          or there is a large domain of indeterminacy, the
          algorithm will converge to a random root in the interval without
          indication that there are problems.  Interestingly, the examined text
          book implementations all disagree in details of the convergence
          criteria.  Also each implementation had problems for one of the test
          cases, so the expressions had to be fudged further. Don't expect to
          get exactly the same root values as for other implementations of this
          algorithm.";"class";"BrentSolver";"org.apache.commons.math3.analysis.solvers.BrentSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[8]/tt";"BracketingNthOrderBrentSolver";"The BracketingNthOrderBrentSolver uses an extension of the";"The BracketingNthOrderBrentSolver uses an extension of the
          Brent-Dekker algorithm which uses inverse nth order polynomial
          interpolation instead of inverse quadratic interpolation, and which allows
          selection of the side of the convergence interval for result bracketing.
          This is now the recommended algorithm for most users since it has the
          largest order, doesn't require derivatives, has guaranteed convergence
          and allows result bracket selection.";"class";"BracketingNthOrderBrentSolver";"org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[9]/tt";"SecantSolver";"The SecantSolver uses a straightforward secant";"The SecantSolver uses a straightforward secant
          algorithm which does not bracket the search and therefore does not
          guarantee convergence.  It may be faster than Brent on some well-behaved
          functions.";"class";"SecantSolver";"org.apache.commons.math3.analysis.solvers.SecantSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[10]/tt";"RegulaFalsiSolver";"The RegulaFalsiSolver is variation of secant preserving";"The RegulaFalsiSolver is variation of secant preserving
          bracketing, but then it may be slow, as one end point of the search interval
          will become fixed after and only the other end point will converge to the root,
          hence resulting in a search interval size that does not decrease to zero.";"class";"RegulaFalsiSolver";"org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[11]/tt[1]";"IllinoisSolver";"The IllinoisSolver and PegasusSolver are";"The IllinoisSolver and PegasusSolver are
          well-known variations of regula falsi that fix the problem of stuck
          end points by slightly weighting one endpoint to balance the interval
          at next iteration. Pegasus is often faster than Illinois. Pegasus may
          be the algorithm of choice for selecting a specific side of the convergence
          interval.";"class";"IllinoisSolver";"org.apache.commons.math3.analysis.solvers.IllinoisSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[11]/tt[2]";"PegasusSolver";"The IllinoisSolver and PegasusSolver are";"The IllinoisSolver and PegasusSolver are
          well-known variations of regula falsi that fix the problem of stuck
          end points by slightly weighting one endpoint to balance the interval
          at next iteration. Pegasus is often faster than Illinois. Pegasus may
          be the algorithm of choice for selecting a specific side of the convergence
          interval.";"class";"PegasusSolver";"org.apache.commons.math3.analysis.solvers.PegasusSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[12]/tt";"BisectionSolver";"The BisectionSolver is included for completeness and for";"The BisectionSolver is included for completeness and for
          establishing a fall back in cases of emergency.  The algorithm is
          simple, most likely bug free and guaranteed to converge even in very
          adverse circumstances which might cause other algorithms to
          malfunction.  The drawback is of course that it is also guaranteed
          to be slow.";"class";"BisectionSolver";"org.apache.commons.math3.analysis.solvers.BisectionSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[13]/tt";"UnivariateSolver";"The UnivariateSolver interface exposes many";"The UnivariateSolver interface exposes many
          properties to control the convergence of a solver.  The accuracy properties
          are set at solver instance creation and cannot be changed afterwards,
          there are only getters to retriveve their values, no setters are available.";"class";"UnivariateSolver";"org.apache.commons.math3.analysis.solvers.UnivariateSolver"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[1]/a[1]";"UnivariateInterpolator";"UnivariateInterpolator is used to find a univariate real-valued";"A 
          UnivariateInterpolator is used to find a univariate real-valued
          function f which for a given set of ordered pairs 
          (xi,yi) yields
          f(xi)=yi to the best accuracy possible. The result
          is provided as an object implementing the 
          UnivariateFunction interface. It can therefore be evaluated at any point,
          including point not belonging to the original set.
          Currently, only an interpolator for generating natural cubic splines and a polynomial
          interpolator are available.  There is no interpolator factory, mainly because the
          interpolation algorithm is more determined by the kind of the interpolated function
          rather than the set of points to interpolate.
          There aren't currently any accuracy controls either, as interpolation
          accuracy is in general determined by the algorithm.";"class";"UnivariateInterpolator";"org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[1]/a[2]";"UnivariateFunction";"UnivariateFunction interface.";"A 
          UnivariateInterpolator is used to find a univariate real-valued
          function f which for a given set of ordered pairs 
          (xi,yi) yields
          f(xi)=yi to the best accuracy possible. The result
          is provided as an object implementing the 
          UnivariateFunction interface. It can therefore be evaluated at any point,
          including point not belonging to the original set.
          Currently, only an interpolator for generating natural cubic splines and a polynomial
          interpolator are available.  There is no interpolator factory, mainly because the
          interpolation algorithm is more determined by the kind of the interpolated function
          rather than the set of points to interpolate.
          There aren't currently any accuracy controls either, as interpolation
          accuracy is in general determined by the algorithm.";"class";"UnivariateFunction";"org.apache.commons.math3.analysis.UnivariateFunction"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[7]/a[2]";"HermiteInterpolator";"The HermiteInterpolator";"Hermite interpolation
          is an interpolation method that can use derivatives in addition to function values at sample points. The HermiteInterpolator
          class implements this method for vector-valued functions. The sampling points can have any spacing (there are
          no requirements for a regular grid) and some points may provide derivatives while others don't provide them
          (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example:";"class";"HermiteInterpolator";"org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[8]/a[1]";"BivariateGridInterpolator";"BivariateGridInterpolator is used to find a bivariate real-valued";"A 
          BivariateGridInterpolator is used to find a bivariate real-valued
          function f which for a given set of tuples
          (xi,yj,fij)
          yields f(xi,yj)=fij to the best accuracy
          possible. The result is provided as an object implementing the
          
          BivariateFunction interface. It can therefore be evaluated at any point,
          including a point not belonging to the original set.
          The arrays xi and yj must be
          sorted in increasing order in order to define a two-dimensional grid.";"class";"BivariateGridInterpolator";"org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[8]/a[2]";"BivariateFunction";"BivariateFunction interface.";"A 
          BivariateGridInterpolator is used to find a bivariate real-valued
          function f which for a given set of tuples
          (xi,yj,fij)
          yields f(xi,yj)=fij to the best accuracy
          possible. The result is provided as an object implementing the
          
          BivariateFunction interface. It can therefore be evaluated at any point,
          including a point not belonging to the original set.
          The arrays xi and yj must be
          sorted in increasing order in order to define a two-dimensional grid.";"class";"BivariateFunction";"org.apache.commons.math3.analysis.BivariateFunction"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[9]/a[2]";"BicubicSplineInterpolator";"BicubicSplineInterpolator computes a";"In bicubic interpolation,
          the interpolation function is a 3rd-degree polynomial of two variables. The coefficients
          are computed from the function values sampled on a grid, as well as the values of the
          partial derivatives of the function at those grid points.
          From two-dimensional data sampled on a grid, the
          
          BicubicSplineInterpolator computes a
          
          bicubic interpolating function.
          Prior to computing an interpolating function, the
          
          SmoothingPolynomialBicubicSplineInterpolator class performs smoothing of
          the data by computing the polynomial that best fits each of the one-dimensional
          curves along each of the coordinate axes.";"class";"BicubicSplineInterpolator";"org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[9]/a[4]";"SmoothingPolynomialBicubicSplineInterpolator";"SmoothingPolynomialBicubicSplineInterpolator class performs smoothing of";"In bicubic interpolation,
          the interpolation function is a 3rd-degree polynomial of two variables. The coefficients
          are computed from the function values sampled on a grid, as well as the values of the
          partial derivatives of the function at those grid points.
          From two-dimensional data sampled on a grid, the
          
          BicubicSplineInterpolator computes a
          
          bicubic interpolating function.
          Prior to computing an interpolating function, the
          
          SmoothingPolynomialBicubicSplineInterpolator class performs smoothing of
          the data by computing the polynomial that best fits each of the one-dimensional
          curves along each of the coordinate axes.";"class";"SmoothingPolynomialBicubicSplineInterpolator";"org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[10]/a[1]";"TrivariateGridInterpolator";"TrivariateGridInterpolator is used to find a trivariate real-valued";"A 
          TrivariateGridInterpolator is used to find a trivariate real-valued
          function f which for a given set of tuples
          (xi,yj,zk,
          fijk)
          yields f(xi,yj,zk)=fijk
          to the best accuracy possible. The result is provided as an object implementing the
          
          TrivariateFunction interface. It can therefore be evaluated at any point,
          including a point not belonging to the original set.
          The arrays xi, yj and
          zk must be sorted in increasing order in order to define
          a three-dimensional grid.";"class";"TrivariateGridInterpolator";"org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[10]/a[2]";"TrivariateFunction";"TrivariateFunction interface.";"A 
          TrivariateGridInterpolator is used to find a trivariate real-valued
          function f which for a given set of tuples
          (xi,yj,zk,
          fijk)
          yields f(xi,yj,zk)=fijk
          to the best accuracy possible. The result is provided as an object implementing the
          
          TrivariateFunction interface. It can therefore be evaluated at any point,
          including a point not belonging to the original set.
          The arrays xi, yj and
          zk must be sorted in increasing order in order to define
          a three-dimensional grid.";"class";"TrivariateFunction";"org.apache.commons.math3.analysis.TrivariateFunction"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[4]/p[11]/a[2]";"TricubicSplineInterpolator";"TricubicSplineInterpolator computes a";"In tricubic interpolation,
          the interpolation function is a 3rd-degree polynomial of three variables. The coefficients
          are computed from the function values sampled on a grid, as well as the values of the
          partial derivatives of the function at those grid points.
          From three-dimensional data sampled on a grid, the
          
          TricubicSplineInterpolator computes a
          
          tricubic interpolating function.";"class";"TricubicSplineInterpolator";"org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[5]/p/a[1]";"UnivariateIntegrator";"UnivariateIntegrator provides the means to numerically integrate";"A 
          UnivariateIntegrator provides the means to numerically integrate
          
          univariate real-valued functions.
          Commons-Math includes implementations of the following integration algorithms:";"class";"UnivariateIntegrator";"org.apache.commons.math3.analysis.integration.UnivariateIntegrator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[6]/p[2]/a[1]";"PolynomialFunction";"PolynomialFunction class is the most general one, using traditional";"The 
          PolynomialFunction class is the most general one, using traditional
          coefficients arrays. The
          
          PolynomialsUtils utility class provides static factory methods to build
          Chebyshev, Hermite, Jacobi, Laguerre and Legendre polynomials. Coefficients are
          computed using exact fractions so these factory methods can build polynomials
          up to any degree.";"class";"PolynomialFunction";"org.apache.commons.math3.analysis.polynomials.PolynomialFunction"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[6]/p[2]/a[2]";"PolynomialsUtils";"PolynomialsUtils utility class provides static factory methods to build";"The 
          PolynomialFunction class is the most general one, using traditional
          coefficients arrays. The
          
          PolynomialsUtils utility class provides static factory methods to build
          Chebyshev, Hermite, Jacobi, Laguerre and Legendre polynomials. Coefficients are
          computed using exact fractions so these factory methods can build polynomials
          up to any degree.";"class";"PolynomialsUtils";"org.apache.commons.math3.analysis.polynomials.PolynomialsUtils"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[2]/a[1]";"DerivativeStructure";"DerivativeStructure which holds the value and the differentials of a function.";"The core class is 
          DerivativeStructure which holds the value and the differentials of a function. This class
          handles some arbitrary number of free parameters and arbitrary derivation order. It is used
          both as the input and the output type for the 
          UnivariateDifferentiableFunction interface. Any differentiable function should implement this
          interface.";"class";"DerivativeStructure";"org.apache.commons.math3.analysis.differentiation.DerivativeStructure"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[2]/a[2]";"UnivariateDifferentiableFunction";"UnivariateDifferentiableFunction interface.";"The core class is 
          DerivativeStructure which holds the value and the differentials of a function. This class
          handles some arbitrary number of free parameters and arbitrary derivation order. It is used
          both as the input and the output type for the 
          UnivariateDifferentiableFunction interface. Any differentiable function should implement this
          interface.";"class";"UnivariateDifferentiableFunction";"org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[3]/a[1]";"DerivativeStructure";"DerivativeStructure class is that it can be used almost as a number (i.";"The main idea behind the 
          DerivativeStructure class is that it can be used almost as a number (i.e. it can be added,
          multiplied, its square root can be extracted or its cosine computed... However, in addition to
          computed the value itself when doing these computations, the partial derivatives are also computed
          alongside. This is an extension of what is sometimes called Rall's numbers. This extension is
          described in Dan Kalman's paper Doubly Recursive
          Multivariate Automatic Differentiation, Mathematics Magazine, vol. 75, no. 3, June 2002.
          Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's
          derivative structures hold all partial derivatives up to any specified order, with respect to any
          number of free parameters. Rall's numbers therefore can be seen as derivative structures for order
          one derivative and one free parameter, and primitive real numbers can be seen as derivative structures
          with zero order derivative and no free parameters.";"class";"DerivativeStructure";"org.apache.commons.math3.analysis.differentiation.DerivativeStructure"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[4]/a";"DerivativeStructure";"DerivativeStructure so it will drive the function to compute all derivatives up to order 3 for";"The workflow of computation of a derivatives of an expression y=f(x) is the following
          one. First we configure an input parameter x of type 
          DerivativeStructure so it will drive the function to compute all derivatives up to order 3 for
          example. Then we compute y=f(x) normally by passing this parameter to the f function.At
          the end, we extract from y the value and the derivatives we want. As we have specified
          3rd order when we built x, we can retrieve the derivatives up to 3rd
          order from y. The following example shows that (the 0 parameter in the DerivativeStructure
          constructor will be explained in the next paragraph):";"class";"DerivativeStructure";"org.apache.commons.math3.analysis.differentiation.DerivativeStructure"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[6]/tt[5]";"z.getPartialDerivative(1)";"if we call z.getPartialDerivative(1), we will not get the first derivative of g";"When we compute y from this setting, what we really do is chain f after the
         identity function, so the net result is that the derivatives are computed with respect to the indexed
         free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the
         identity function x. Going one step further, if we compute z = g(y), we will also compute
         z as a function of the initial free parameter. The very important consequence is that
         if we call z.getPartialDerivative(1), we will not get the first derivative of g
         with respect to y, but with respect to the free parameter p0: the derivatives
         of g and f will be chained together automatically, without user intervention.";"method";"getPartialDerivative";"org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[8]/tt[19]";"getPartialDerivative";"getPartialDerivative is a variable arguments method which take as arguments the derivation";"This design also allow a very interesting feature which can be explained with the following example.
         Suppose we have a two arguments function f and a one argument function g. If
         we compute g(f(x, y)) with x and y be two variables, we
         want to be able to compute the partial derivatives dg/dx, dg/dy,
         d2g/dx2 d2g/dxdy d2g/dy2. This does make sense since we combined
         the two functions, and it does make sense despite g is a one argument function only. In order to do
         this, we simply set up x as an identity function of an implicit free parameter
         p0 and y as an identity function of a different implicit free parameter
         p1 and compute everything directly. In order to be able to combine everything, however,
         both x and y must be built with the appropriate dimensions, so they will both
         be declared to handle two free parameters, but x will depend only on parameter 0 while
         y will depend on parameter 1. Here is how we do this (note that
         getPartialDerivative is a variable arguments method which take as arguments the derivation
         order with respect to all free parameters, i.e. the first argument is derivation order with respect to
         free parameter 0 and the second argument is derivation order with respect to free parameter 1):";"class";"getPartialDerivative";"org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[9]/a[1]";"UnivariateDifferentiableFunction";"UnivariateDifferentiableFunction interface.";"There are several ways a user can create an implementation of the 
          UnivariateDifferentiableFunction interface. The first method is to simply write it directly using
          the appropriate methods from 
          DerivativeStructure to compute addition, subtraction, sine, cosine... This is often quite
          straigthforward and there is no need to remember the rules for differentiation: the user code only
          represent the function itself, the differentials will be computed automatically under the hood. The
          second method is to write a classical UnivariateFunction and to
          pass it to an existing implementation of the 
          UnivariateFunctionDifferentiator interface to retrieve a differentiated version of the same function.
          The first method is more suited to small functions for which user already control all the underlying code.
          The second method is more suited to either large functions that would be cumbersome to write using the
          
          DerivativeStructure API, or functions for which user does not have control to the full underlying code
          (for example functions that call external libraries).";"class";"UnivariateDifferentiableFunction";"org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[9]/a[2]";"DerivativeStructure";"DerivativeStructure to compute addition, subtraction, sine, cosine.";"There are several ways a user can create an implementation of the 
          UnivariateDifferentiableFunction interface. The first method is to simply write it directly using
          the appropriate methods from 
          DerivativeStructure to compute addition, subtraction, sine, cosine... This is often quite
          straigthforward and there is no need to remember the rules for differentiation: the user code only
          represent the function itself, the differentials will be computed automatically under the hood. The
          second method is to write a classical UnivariateFunction and to
          pass it to an existing implementation of the 
          UnivariateFunctionDifferentiator interface to retrieve a differentiated version of the same function.
          The first method is more suited to small functions for which user already control all the underlying code.
          The second method is more suited to either large functions that would be cumbersome to write using the
          
          DerivativeStructure API, or functions for which user does not have control to the full underlying code
          (for example functions that call external libraries).";"class";"DerivativeStructure";"org.apache.commons.math3.analysis.differentiation.DerivativeStructure"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[9]/a[3]";"UnivariateFunction";"second method is to write a classical UnivariateFunction and to";"There are several ways a user can create an implementation of the 
          UnivariateDifferentiableFunction interface. The first method is to simply write it directly using
          the appropriate methods from 
          DerivativeStructure to compute addition, subtraction, sine, cosine... This is often quite
          straigthforward and there is no need to remember the rules for differentiation: the user code only
          represent the function itself, the differentials will be computed automatically under the hood. The
          second method is to write a classical UnivariateFunction and to
          pass it to an existing implementation of the 
          UnivariateFunctionDifferentiator interface to retrieve a differentiated version of the same function.
          The first method is more suited to small functions for which user already control all the underlying code.
          The second method is more suited to either large functions that would be cumbersome to write using the
          
          DerivativeStructure API, or functions for which user does not have control to the full underlying code
          (for example functions that call external libraries).";"class";"UnivariateFunction";"org.apache.commons.math3.analysis.UnivariateFunction"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[9]/a[4]";"UnivariateFunctionDifferentiator";"UnivariateFunctionDifferentiator interface to retrieve a differentiated version of the same function.";"There are several ways a user can create an implementation of the 
          UnivariateDifferentiableFunction interface. The first method is to simply write it directly using
          the appropriate methods from 
          DerivativeStructure to compute addition, subtraction, sine, cosine... This is often quite
          straigthforward and there is no need to remember the rules for differentiation: the user code only
          represent the function itself, the differentials will be computed automatically under the hood. The
          second method is to write a classical UnivariateFunction and to
          pass it to an existing implementation of the 
          UnivariateFunctionDifferentiator interface to retrieve a differentiated version of the same function.
          The first method is more suited to small functions for which user already control all the underlying code.
          The second method is more suited to either large functions that would be cumbersome to write using the
          
          DerivativeStructure API, or functions for which user does not have control to the full underlying code
          (for example functions that call external libraries).";"class";"UnivariateFunctionDifferentiator";"org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[9]/a[5]";"DerivativeStructure";"DerivativeStructure API, or functions for which user does not have control to the full underlying code";"There are several ways a user can create an implementation of the 
          UnivariateDifferentiableFunction interface. The first method is to simply write it directly using
          the appropriate methods from 
          DerivativeStructure to compute addition, subtraction, sine, cosine... This is often quite
          straigthforward and there is no need to remember the rules for differentiation: the user code only
          represent the function itself, the differentials will be computed automatically under the hood. The
          second method is to write a classical UnivariateFunction and to
          pass it to an existing implementation of the 
          UnivariateFunctionDifferentiator interface to retrieve a differentiated version of the same function.
          The first method is more suited to small functions for which user already control all the underlying code.
          The second method is more suited to either large functions that would be cumbersome to write using the
          
          DerivativeStructure API, or functions for which user does not have control to the full underlying code
          (for example functions that call external libraries).";"class";"DerivativeStructure";"org.apache.commons.math3.analysis.differentiation.DerivativeStructure"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[10]/a[1]";"UnivariateFunctionDifferentiator";"UnivariateFunctionDifferentiator interface:";"Apache Commons Math provides one implementation of the 
          UnivariateFunctionDifferentiator interface: 
          FiniteDifferencesDifferentiator. This class creates a wrapper that will call the user-provided function
          on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries
          if the variable is not defined on the whole real line. It is possible to use more points than strictly
          required by the derivation order (for example one can specify an 8-points scheme to compute first
          derivative only). However, one must be aware that tuning the parameters for finite differences is
          highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead
          to huge errors. Finite differences are also not well suited to compute high order derivatives.";"class";"UnivariateFunctionDifferentiator";"org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[10]/a[2]";"FiniteDifferencesDifferentiator";"FiniteDifferencesDifferentiator.";"Apache Commons Math provides one implementation of the 
          UnivariateFunctionDifferentiator interface: 
          FiniteDifferencesDifferentiator. This class creates a wrapper that will call the user-provided function
          on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries
          if the variable is not defined on the whole real line. It is possible to use more points than strictly
          required by the derivation order (for example one can specify an 8-points scheme to compute first
          derivative only). However, one must be aware that tuning the parameters for finite differences is
          highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead
          to huge errors. Finite differences are also not well suited to compute high order derivatives.";"class";"FiniteDifferencesDifferentiator";"org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[7]/p[11]/a[1]";"UnivariateFunctionDifferentiator";"UnivariateFunctionDifferentiator interface is under development in the related project";"Another implementation of the 
          UnivariateFunctionDifferentiator interface is under development in the related project
          Apache Commons Nabla. This implementation uses
          automatic code analysis and generation at binary level. However, at time of writing
          (end 2012), this project is not yet suitable for production use.";"class";"UnivariateFunctionDifferentiator";"org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[2]/p[1]/a";"RealMatrix";"RealMatrix interface represents a matrix with real numbers as";"The 
          RealMatrix interface represents a matrix with real numbers as 
          entries.  The following basic matrix operations are supported:";"class";"RealMatrix";"org.apache.commons.math3.linear.RealMatrix"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[1]";"Array2DRowRealMatrix";"Array2DRowRealMatrix and";"The three main implementations of the interface are 
        Array2DRowRealMatrix and 
        BlockRealMatrix for dense matrices (the second one being more suited to
        dimensions above 50 or 100) and 
        SparseRealMatrix for sparse matrices.";"class";"Array2DRowRealMatrix";"org.apache.commons.math3.linear.Array2DRowRealMatrix"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[2]";"BlockRealMatrix";"BlockRealMatrix for dense matrices (the second one being more suited to";"The three main implementations of the interface are 
        Array2DRowRealMatrix and 
        BlockRealMatrix for dense matrices (the second one being more suited to
        dimensions above 50 or 100) and 
        SparseRealMatrix for sparse matrices.";"class";"BlockRealMatrix";"org.apache.commons.math3.linear.BlockRealMatrix"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[2]/p[3]/a[3]";"SparseRealMatrix";"SparseRealMatrix for sparse matrices.";"The three main implementations of the interface are 
        Array2DRowRealMatrix and 
        BlockRealMatrix for dense matrices (the second one being more suited to
        dimensions above 50 or 100) and 
        SparseRealMatrix for sparse matrices.";"class";"SparseRealMatrix";"org.apache.commons.math3.linear.SparseRealMatrix"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[3]/p[1]/a";"RealVector";"RealVector interface represents a vector with real numbers as";"The 
          RealVector interface represents a vector with real numbers as 
          entries.  The following basic matrix operations are supported:";"class";"RealVector";"org.apache.commons.math3.linear.RealVector"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[3]/p[2]/a";"RealVectorFormat";"RealVectorFormat class handles input/output of vectors in a customizable";"The 
          RealVectorFormat class handles input/output of vectors in a customizable
          textual format.";"class";"RealVectorFormat";"org.apache.commons.math3.linear.RealVectorFormat"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/p[1]/a";"DecompositionSolver";"The solve() methods of the DecompositionSolver";"The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.";"class";"DecompositionSolver";"org.apache.commons.math3.linear.DecompositionSolver"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/p[1]/tt[2]";"RealMatrix";"A RealMatrix instance is";"The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.";"class";"RealMatrix";"org.apache.commons.math3.linear.RealMatrix"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/tt[1]";"RealVector";"Next create a RealVector array to represent the constant";"3.4 Solving linear systems
        
          The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.
        
        
          For example, to solve the linear system
          
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          
          Start by decomposing the coefficient matrix A (in this case using LU decomposition)
          and build a solver
          
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          
          Next create a RealVector array to represent the constant
          vector B and use solve(RealVector) to solve the system
          
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          
          The solution vector will contain values for x
          (solution.getEntry(0)), y (solution.getEntry(1)), 
          and z (solution.getEntry(2)) that solve the system.
        
        
          Each type of decomposition has its specific semantics and constraints on
          the coefficient matrix as shown in the following table. For algorithms that
          solve AX=B in least squares sense the value returned for X is such that the
          residual AX-B has minimal norm. If an exact solution exist (i.e. if for some
          X the residual AX-B is exactly 0), then this exact solution is also the solution
          in least square sense. This implies that algorithms suited for least squares
          problems can also be used to solve exact problems, but the reverse is not true. 
        
        
          Decomposition algorithmsNamecoefficients matrixproblem typeLUsquareexact solution onlyCholeskysymmetric positive definiteexact solution onlyQRanyleast squares solutioneigen decompositionsquareexact solution onlySVDanyleast squares solution
          It is possible to use a simple array of double instead of a RealVector.
          In this case, the solution will be provided also as an array of double.
        
        
          It is possible to solve multiple systems with the same coefficient matrix 
          in one method call.  To do this, create a matrix whose column vectors correspond 
          to the constant vectors for the systems to be solved and use solve(RealMatrix),
          which returns a matrix with column vectors representing the solutions.";"class";"RealVector";"org.apache.commons.math3.linear.RealVector"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/tt[2]";"solve(RealVector)";"vector B and use solve(RealVector) to solve the system";"3.4 Solving linear systems
        
          The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.
        
        
          For example, to solve the linear system
          
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          
          Start by decomposing the coefficient matrix A (in this case using LU decomposition)
          and build a solver
          
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          
          Next create a RealVector array to represent the constant
          vector B and use solve(RealVector) to solve the system
          
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          
          The solution vector will contain values for x
          (solution.getEntry(0)), y (solution.getEntry(1)), 
          and z (solution.getEntry(2)) that solve the system.
        
        
          Each type of decomposition has its specific semantics and constraints on
          the coefficient matrix as shown in the following table. For algorithms that
          solve AX=B in least squares sense the value returned for X is such that the
          residual AX-B has minimal norm. If an exact solution exist (i.e. if for some
          X the residual AX-B is exactly 0), then this exact solution is also the solution
          in least square sense. This implies that algorithms suited for least squares
          problems can also be used to solve exact problems, but the reverse is not true. 
        
        
          Decomposition algorithmsNamecoefficients matrixproblem typeLUsquareexact solution onlyCholeskysymmetric positive definiteexact solution onlyQRanyleast squares solutioneigen decompositionsquareexact solution onlySVDanyleast squares solution
          It is possible to use a simple array of double instead of a RealVector.
          In this case, the solution will be provided also as an array of double.
        
        
          It is possible to solve multiple systems with the same coefficient matrix 
          in one method call.  To do this, create a matrix whose column vectors correspond 
          to the constant vectors for the systems to be solved and use solve(RealMatrix),
          which returns a matrix with column vectors representing the solutions.";"method";"solve";"org.apache.commons.math3.linear.DecompositionSolver.solve"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/tt[4]";"solution.getEntry(0)";"(solution.getEntry(0)), y (solution.";"3.4 Solving linear systems
        
          The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.
        
        
          For example, to solve the linear system
          
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          
          Start by decomposing the coefficient matrix A (in this case using LU decomposition)
          and build a solver
          
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          
          Next create a RealVector array to represent the constant
          vector B and use solve(RealVector) to solve the system
          
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          
          The solution vector will contain values for x
          (solution.getEntry(0)), y (solution.getEntry(1)), 
          and z (solution.getEntry(2)) that solve the system.
        
        
          Each type of decomposition has its specific semantics and constraints on
          the coefficient matrix as shown in the following table. For algorithms that
          solve AX=B in least squares sense the value returned for X is such that the
          residual AX-B has minimal norm. If an exact solution exist (i.e. if for some
          X the residual AX-B is exactly 0), then this exact solution is also the solution
          in least square sense. This implies that algorithms suited for least squares
          problems can also be used to solve exact problems, but the reverse is not true. 
        
        
          Decomposition algorithmsNamecoefficients matrixproblem typeLUsquareexact solution onlyCholeskysymmetric positive definiteexact solution onlyQRanyleast squares solutioneigen decompositionsquareexact solution onlySVDanyleast squares solution
          It is possible to use a simple array of double instead of a RealVector.
          In this case, the solution will be provided also as an array of double.
        
        
          It is possible to solve multiple systems with the same coefficient matrix 
          in one method call.  To do this, create a matrix whose column vectors correspond 
          to the constant vectors for the systems to be solved and use solve(RealMatrix),
          which returns a matrix with column vectors representing the solutions.";"method";"getEntry";"org.apache.commons.math3.linear.RealVector.getEntry"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/tt[5]";"solution.getEntry(1)";"getEntry(0)), y (solution.getEntry(1)),";"3.4 Solving linear systems
        
          The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.
        
        
          For example, to solve the linear system
          
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          
          Start by decomposing the coefficient matrix A (in this case using LU decomposition)
          and build a solver
          
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          
          Next create a RealVector array to represent the constant
          vector B and use solve(RealVector) to solve the system
          
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          
          The solution vector will contain values for x
          (solution.getEntry(0)), y (solution.getEntry(1)), 
          and z (solution.getEntry(2)) that solve the system.
        
        
          Each type of decomposition has its specific semantics and constraints on
          the coefficient matrix as shown in the following table. For algorithms that
          solve AX=B in least squares sense the value returned for X is such that the
          residual AX-B has minimal norm. If an exact solution exist (i.e. if for some
          X the residual AX-B is exactly 0), then this exact solution is also the solution
          in least square sense. This implies that algorithms suited for least squares
          problems can also be used to solve exact problems, but the reverse is not true. 
        
        
          Decomposition algorithmsNamecoefficients matrixproblem typeLUsquareexact solution onlyCholeskysymmetric positive definiteexact solution onlyQRanyleast squares solutioneigen decompositionsquareexact solution onlySVDanyleast squares solution
          It is possible to use a simple array of double instead of a RealVector.
          In this case, the solution will be provided also as an array of double.
        
        
          It is possible to solve multiple systems with the same coefficient matrix 
          in one method call.  To do this, create a matrix whose column vectors correspond 
          to the constant vectors for the systems to be solved and use solve(RealMatrix),
          which returns a matrix with column vectors representing the solutions.";"method";"getEntry";"org.apache.commons.math3.linear.RealVector.getEntry"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/tt[6]";"solution.getEntry(2)";"and z (solution.getEntry(2)) that solve the system.";"3.4 Solving linear systems
        
          The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.
        
        
          For example, to solve the linear system
          
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          
          Start by decomposing the coefficient matrix A (in this case using LU decomposition)
          and build a solver
          
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          
          Next create a RealVector array to represent the constant
          vector B and use solve(RealVector) to solve the system
          
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          
          The solution vector will contain values for x
          (solution.getEntry(0)), y (solution.getEntry(1)), 
          and z (solution.getEntry(2)) that solve the system.
        
        
          Each type of decomposition has its specific semantics and constraints on
          the coefficient matrix as shown in the following table. For algorithms that
          solve AX=B in least squares sense the value returned for X is such that the
          residual AX-B has minimal norm. If an exact solution exist (i.e. if for some
          X the residual AX-B is exactly 0), then this exact solution is also the solution
          in least square sense. This implies that algorithms suited for least squares
          problems can also be used to solve exact problems, but the reverse is not true. 
        
        
          Decomposition algorithmsNamecoefficients matrixproblem typeLUsquareexact solution onlyCholeskysymmetric positive definiteexact solution onlyQRanyleast squares solutioneigen decompositionsquareexact solution onlySVDanyleast squares solution
          It is possible to use a simple array of double instead of a RealVector.
          In this case, the solution will be provided also as an array of double.
        
        
          It is possible to solve multiple systems with the same coefficient matrix 
          in one method call.  To do this, create a matrix whose column vectors correspond 
          to the constant vectors for the systems to be solved and use solve(RealMatrix),
          which returns a matrix with column vectors representing the solutions.";"method";"getEntry";"org.apache.commons.math3.linear.RealVector.getEntry"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/p[5]/tt";"RealVector";"It is possible to use a simple array of double instead of a RealVector.";"It is possible to use a simple array of double instead of a RealVector.
          In this case, the solution will be provided also as an array of double.";"class";"RealVector";"org.apache.commons.math3.linear.RealVector"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/p[6]/tt";"solve(RealMatrix)";"to the constant vectors for the systems to be solved and use solve(RealMatrix),";"It is possible to solve multiple systems with the same coefficient matrix 
          in one method call.  To do this, create a matrix whose column vectors correspond 
          to the constant vectors for the systems to be solved and use solve(RealMatrix),
          which returns a matrix with column vectors representing the solutions.";"method";"solve";"org.apache.commons.math3.linear.DecompositionSolver.solve"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[5]";"getD()";"getV(), getD() and getVT() methods of the";"The getEigenvalue(), getEigenvalues(), getEigenVector(),
          getV(), getD() and getVT() methods of the
          EigenDecomposition interface support solving eigenproblems of the form
          AX = lambda X where lambda is a real scalar.";"method";"getD";"org.apache.commons.math3.linear.EigenDecomposition.getD"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[7]";"EigenDecomposition";"EigenDecomposition interface support solving eigenproblems of the form";"The getEigenvalue(), getEigenvalues(), getEigenVector(),
          getV(), getD() and getVT() methods of the
          EigenDecomposition interface support solving eigenproblems of the form
          AX = lambda X where lambda is a real scalar.";"class";"EigenDecomposition";"org.apache.commons.math3.linear.EigenDecomposition"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[3]/tt[1]";"getSingularValues()";"The getSingularValues(), getU(), getS() and";"The getSingularValues(), getU(), getS() and
        getV() methods of the SingularValueDecomposition interface
        allow to solve singular values problems of the form AXi = lambda Yi where lambda is a
        real scalar, and where the Xi and Yi vectors form orthogonal bases of their respective
        vector spaces (which may have different dimensions).";"method";"getSingularValues";"org.apache.commons.math3.linear.SingularValueDecomposition.getSingularValues"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[3]/tt[2]";"getU()";"The getSingularValues(), getU(), getS() and";"The getSingularValues(), getU(), getS() and
        getV() methods of the SingularValueDecomposition interface
        allow to solve singular values problems of the form AXi = lambda Yi where lambda is a
        real scalar, and where the Xi and Yi vectors form orthogonal bases of their respective
        vector spaces (which may have different dimensions).";"method";"getU";"org.apache.commons.math3.linear.SingularValueDecomposition.getU"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[3]/tt[3]";"getS()";"The getSingularValues(), getU(), getS() and";"The getSingularValues(), getU(), getS() and
        getV() methods of the SingularValueDecomposition interface
        allow to solve singular values problems of the form AXi = lambda Yi where lambda is a
        real scalar, and where the Xi and Yi vectors form orthogonal bases of their respective
        vector spaces (which may have different dimensions).";"method";"getS";"org.apache.commons.math3.linear.SingularValueDecomposition.getS"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[3]/tt[5]";"SingularValueDecomposition";"getV() methods of the SingularValueDecomposition interface";"The getSingularValues(), getU(), getS() and
        getV() methods of the SingularValueDecomposition interface
        allow to solve singular values problems of the form AXi = lambda Yi where lambda is a
        real scalar, and where the Xi and Yi vectors form orthogonal bases of their respective
        vector spaces (which may have different dimensions).";"class";"SingularValueDecomposition";"org.apache.commons.math3.linear.SingularValueDecomposition"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[6]/ul/li[1]/a";"Complex";"Complex";"Complex";"unknown";"Complex";"org.apache.commons.math3.complex.Complex"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[6]/ul/li[2]/a";"Fraction";"Fraction";"Fraction";"unknown";"Fraction";"org.apache.commons.math3.fraction.Fraction"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[6]/ul/li[3]/a";"BigFraction";"BigFraction";"BigFraction";"class";"BigFraction";"org.apache.commons.math3.fraction.BigFraction"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[6]/ul/li[4]/a";"BigReal";"BigReal";"BigReal";"class";"BigReal";"org.apache.commons.math3.util.BigReal"
"math/doc/manual3.1/math/userguide/fraction.html";"/html/body/div[4]/div/div/div[3]/p[3]/tt[2]";"parse";"To parse a fraction from a string,";"Formatting's inverse operation, parsing, can also be performed by
          FractionFormat.  To parse a fraction from a string,
          simply call the parse method:";"unknown";"parse";"org.apache.commons.math3.fraction.FractionFormat.parse"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[2]/dl/dd[3]/tt[3]";"reSeed()";"call to a data generation method, or to a  reSeed() method";"By default, the implementation provided in RandomDataImpl
    uses the JDK-provided PRNG.  Like most other PRNGs, the JDK generator
    generates sequences of random numbers based on an initial ""seed value"".
    For the non-secure methods, starting with the same seed always produces the
    same sequence of values.  Secure sequences started with the same seeds will
    diverge. When a new RandomDataImpl is created, the underlying
    random number generators are not initialized.  The first
    call to a data generation method, or to a  reSeed() method
    initializes the appropriate generator.  If you do not explicitly seed the
    generator, it is by default seeded with the current time in milliseconds.
    Therefore, to generate sequences of random data values, you should always
    instantiate one  RandomDataImpl and use it
    repeatedly instead of creating new instances for subsequent values in the
    sequence.  For example, the following will generate a random sequence of 50
    long integers between 1 and 1,000,000, using the current time in
    milliseconds as the seed for the JDK PRNG:
    
RandomData randomData = new RandomDataImpl(); 
for (int i = 0; i < 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will not in general produce a good random sequence, since the
    PRNG is reseeded each time through the loop with the current time in
    milliseconds:
    
for (int i = 0; i < 1000; i++) {
    RandomDataImpl randomData = new RandomDataImpl(); 
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce the same random sequence each time it is
    executed:
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeed(1000);
for (int i = 0; i = 1000; i++) {
    value = randomData.nextLong(1, 1000000);
}
    
    The following will produce a different random sequence each time it is
     executed. 
    
RandomData randomData = new RandomDataImpl(); 
randomData.reSeedSecure(1000);
for (int i = 0; i < 1000; i++) {
    value = randomData.nextSecureLong(1, 1000000);
}";"method";"reSeed";"org.apache.commons.math3.random.RandomDataImpl.reSeed"
"math/doc/manual3.1/math/userguide/optimization.html";"/html/body/div[4]/div/div/div[6]/p[2]/tt";"fit";"For all provided curve fitters, the operating principle is the same.";"For all provided curve fitters, the operating principle is the same. Users must first
          create an instance of the fitter, then add the observed points and once the complete
          sample of observed points has been added they must call the fit method
          which will compute the parameters that best fit the sample. A weight is associated
          with each observed point, this allows to take into account uncertainty on some points
          when they come from loosy measurements for example. If no such information exist and
          all points should be treated the same, it is safe to put 1.0 as the weight for all points.";"unknown";"fit";"org.apache.commons.math3.fitting.CurveFitter.fit"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[6]/dl/dd[2]/tt[4]";"computeDistribution()";"computeDistribution() opens and closes the input file";"When used in Digest Mode, the ValueServer reads the entire input file
      and estimates a probability density function based on data from the file.
      The estimation method is essentially the 
      
      Variable Kernel Method with Gaussian smoothing.  Once the density
      has been estimated, getNext() returns random values whose
      probability distribution matches the empirical distribution -- i.e., if
      you generate a large number of such values, their distribution should
      ""look like"" the distribution of the values in the input file.  The values
      are not stored in memory in this case either, so there is no limit to the
      size of the input file.  Here is an example:
      
      ValueServer vs = new ValueServer();
      vs.setValuesFileURL(url); 
      vs.setMode(ValueServer.DIGEST_MODE);
      vs.computeDistribution(500); //Read file and estimate distribution using 500 bins
      double value = vs.getNext();
      // ...Generate and use more values...
      
      See the javadoc for ValueServer and 
      EmpiricalDistribution for more details.  Note that 
      computeDistribution() opens and closes the input file
       by itself.";"method";"computeDistribution";"org.apache.commons.math3.random.ValueServer.computeDistribution"
"math/doc/manual3.1/math/userguide/random.html";"/html/body/div[4]/div/div/div[7]/p[1]/tt[3]";"nextDouble()";"methods based on the primitive,  nextDouble().";"To enable alternative PRNGs to be ""plugged in"" to the commons-math data
      generation utilities and to provide a generic means to replace 
      java.util.Random in applications, a random generator 
      adaptor framework has been added to commons-math.  The
      
      RandomGenerator interface abstracts the public interface of
      java.util.Random and any implementation of this
      interface can be used as the source of random data for the commons-math 
      data generation classes.  An abstract base class, 
      
      AbstractRandomGenerator is provided to make implementation easier.
      This class provides default implementations of ""derived"" data generation
      methods based on the primitive,  nextDouble().
      To support generic replacement of java.util.Random, the 
      
      RandomAdaptor class is provided, which extends
      java.util.Random and wraps and delegates calls to
      a RandomGenerator instance.";"method";"nextDouble";"org.apache.commons.math3.random.AbstractRandomGenerator.nextDouble"
"math/doc/manual3.1/math/userguide/distribution.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[1]";"cumulativeProbability";"using the cumulativeProbability methods.";"Using a distribution object, PDF and CDF probabilities are easily computed
          using the cumulativeProbability methods.  For a distribution
          X, and a domain value, x,
          cumulativeProbability computes P(X <= x)
          (i.e. the lower tail probability of X).";"class";"cumulativeProbability";"org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"
"math/doc/manual3.1/math/userguide/distribution.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[4]";"cumulativeProbability";"cumulativeProbability computes P(X <= x)";"Using a distribution object, PDF and CDF probabilities are easily computed
          using the cumulativeProbability methods.  For a distribution
          X, and a domain value, x,
          cumulativeProbability computes P(X <= x)
          (i.e. the lower tail probability of X).";"class";"cumulativeProbability";"org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[2]/p[1]/tt[2]";"addElementRolling(double)";"addElementRolling(double) to basic list accessors.";"To maintain statistics based on a ""rolling"" window of values, a resizable 
    array implementation was developed and is provided for reuse in the 
    util package.  The core functionality provided is described in
    the documentation for the interface, 
    
    DoubleArray.  This interface adds one method,
    addElementRolling(double) to basic list accessors. 
    The addElementRolling method adds an element 
    (the actual parameter) to the end of the list and removes the first element
     in the list.";"method";"addElementRolling";"org.apache.commons.math3.util.DoubleArray.addElementRolling"
"math/doc/manual3.1/math/userguide/distribution.html";"/html/body/div[4]/div/div/div[2]/p[3]/tt[1]";"inverseCumulativeProbability";"inverseCumulativeProbability methods.";"The inverse PDF and CDF values are just as easily computed using the
          inverseCumulativeProbability methods.  For a distribution X,
          and a probability, p, inverseCumulativeProbability
          computes the domain value x, such that:";"class";"inverseCumulativeProbability";"org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[2]/p[1]/tt[3]";"addElementRolling";"The addElementRolling method adds an element";"To maintain statistics based on a ""rolling"" window of values, a resizable 
    array implementation was developed and is provided for reuse in the 
    util package.  The core functionality provided is described in
    the documentation for the interface, 
    
    DoubleArray.  This interface adds one method,
    addElementRolling(double) to basic list accessors. 
    The addElementRolling method adds an element 
    (the actual parameter) to the end of the list and removes the first element
     in the list.";"class";"addElementRolling";"org.apache.commons.math3.util.DoubleArray.addElementRolling"
"math/doc/manual3.1/math/userguide/distribution.html";"/html/body/div[4]/div/div/div[2]/p[3]/tt[4]";"inverseCumulativeProbability";"and a probability, p, inverseCumulativeProbability";"The inverse PDF and CDF values are just as easily computed using the
          inverseCumulativeProbability methods.  For a distribution X,
          and a probability, p, inverseCumulativeProbability
          computes the domain value x, such that:";"class";"inverseCumulativeProbability";"org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"
"math/doc/manual3.1/math/userguide/utilities.html";"/html/body/div[4]/div/div/div[2]/p[2]/tt[2]";"addElementRolling";"When addElementRolling is invoked, the underlying";"The 
    ResizableDoubleArray class provides a configurable, array-backed
    implementation of the DoubleArray interface.
    When addElementRolling is invoked, the underlying
    array is expanded if necessary, the new element is added to the end of the
    array and the ""usable window"" of the array is moved forward, so that
    the first element is effectively discarded, what was the second becomes the
    first, and so on.  To efficiently manage storage, two maintenance
    operations need to be periodically performed -- orphaned elements at the
    beginning of the array need to be reclaimed and space for new elements at
    the end needs to be created.  Both of these operations are handled
    automatically, with frequency / effect driven by the configuration
    properties expansionMode, expansionFactor and
    contractionCriteria.  See 
    
    ResizableDoubleArray
    for details.";"class";"addElementRolling";"org.apache.commons.math3.util.ResizableDoubleArray.addElementRolling"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[3]/tt[1]";"evaluate()";"evaluate() methods that take double[] arrays as arguments";"The top level interface is
          
          UnivariateStatistic.
          This interface, implemented by all statistics, consists of
          evaluate() methods that take double[] arrays as arguments
          and return the value of the statistic.   This interface is extended by
          
          StorelessUnivariateStatistic, which adds increment(),
          getResult() and associated methods to support
          ""storageless"" implementations that maintain counters, sums or other
          state information as values are added using the increment()
          method.";"method";"evaluate";"org.apache.commons.math3.stat.descriptive.UnivariateStatistic.evaluate"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[3]/tt[2]";"increment()";"StorelessUnivariateStatistic, which adds increment(),";"The top level interface is
          
          UnivariateStatistic.
          This interface, implemented by all statistics, consists of
          evaluate() methods that take double[] arrays as arguments
          and return the value of the statistic.   This interface is extended by
          
          StorelessUnivariateStatistic, which adds increment(),
          getResult() and associated methods to support
          ""storageless"" implementations that maintain counters, sums or other
          state information as values are added using the increment()
          method.";"method";"increment";"org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[3]/tt[3]";"getResult()";"getResult() and associated methods to support";"The top level interface is
          
          UnivariateStatistic.
          This interface, implemented by all statistics, consists of
          evaluate() methods that take double[] arrays as arguments
          and return the value of the statistic.   This interface is extended by
          
          StorelessUnivariateStatistic, which adds increment(),
          getResult() and associated methods to support
          ""storageless"" implementations that maintain counters, sums or other
          state information as values are added using the increment()
          method.";"method";"getResult";"org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.getResult"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/p[3]/tt[4]";"increment()";"state information as values are added using the increment()";"The top level interface is
          
          UnivariateStatistic.
          This interface, implemented by all statistics, consists of
          evaluate() methods that take double[] arrays as arguments
          and return the value of the statistic.   This interface is extended by
          
          StorelessUnivariateStatistic, which adds increment(),
          getResult() and associated methods to support
          ""storageless"" implementations that maintain counters, sums or other
          state information as values are added using the increment()
          method.";"method";"increment";"org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic.increment"
"math/doc/manual3.1/math/userguide/complex.html";"/html/body/div[4]/div/div/div[4]/p[4]/tt[2]";"parse";"simply call the parse method:";"Formatting inverse operation, parsing, can also be performed by
          ComplexFormat.  Parse a complex number from a string,
          simply call the parse method:";"unknown";"parse";"org.apache.commons.math3.complex.ComplexFormat.parse"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[2]/dl/dd[6]/tt[4]";"addValue";"addValue(3);";"There are two ways to do this using AggregateSummaryStatistics. 
        The first is to use an AggregateSummaryStatistics instance
        to accumulate overall statistics contributed by SummaryStatistics
        instances created using
        
        AggregateSummaryStatistics.createContributingStatistics():
        
// Create a AggregateSummaryStatistics instance to accumulate the overall statistics 
// and AggregatingSummaryStatistics for the subsamples
AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();
SummaryStatistics setOneStats = aggregate.createContributingStatistics();
SummaryStatistics setTwoStats = aggregate.createContributingStatistics();
// Add values to the subsample aggregates
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Full sample data is reported by the aggregate
double totalSampleSum = aggregate.getSum();
        
        The above approach has the disadvantages that the addValue calls must be synchronized on the
        SummaryStatistics instance maintained by the aggregate and each value addition updates the
        aggregate as well as the subsample. For applications that can wait to do the aggregation until all values
        have been added, a static
        
          aggregate method is available, as shown in the following example.
        This method should be used when aggregation needs to be done across threads.
        
// Create SummaryStatistics instances for the subsample data
SummaryStatistics setOneStats = new SummaryStatistics();
SummaryStatistics setTwoStats = new SummaryStatistics();
// Add values to the subsample SummaryStatistics instances
setOneStats.addValue(2);
setOneStats.addValue(3);
setTwoStats.addValue(2);
setTwoStats.addValue(4);
...
// Aggregate the subsample statistics
Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();
aggregate.add(setOneStats);
aggregate.add(setTwoStats);
StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);

// Full sample data is reported by aggregatedStats
double totalSampleSum = aggregatedStats.getSum();";"class";"addValue";"org.apache.commons.math3.stat.descriptive.SummaryStatistics.addValue"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[1]";"newSampleData";"AbstractMultipleLinearRegression#newSampleData(double[],int,int),";"Data for OLS models can be loaded in a single double[] array, consisting of concatenated rows of data, each containing
           the regressand (Y) value, followed by regressor values; or using a double[][] array with rows corresponding to
           observations. GLS models also require a double[][] array representing the covariance matrix of the error terms.  See
           
           AbstractMultipleLinearRegression#newSampleData(double[],int,int),  
           
           OLSMultipleLinearRegression#newSampleData(double[], double[][]) and 
           
           GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"class";"newSampleData";"org.apache.commons.math3.stat.regression.AbstractMultipleLinearRegression.newSampleData"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[2]";"newSampleData";"OLSMultipleLinearRegression#newSampleData(double[], double[][]) and";"Data for OLS models can be loaded in a single double[] array, consisting of concatenated rows of data, each containing
           the regressand (Y) value, followed by regressor values; or using a double[][] array with rows corresponding to
           observations. GLS models also require a double[][] array representing the covariance matrix of the error terms.  See
           
           AbstractMultipleLinearRegression#newSampleData(double[],int,int),  
           
           OLSMultipleLinearRegression#newSampleData(double[], double[][]) and 
           
           GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"class";"newSampleData";"org.apache.commons.math3.stat.regression.OLSMultipleLinearRegression.newSampleData"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[5]/p[5]/a[3]";"newSampleData";"GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"Data for OLS models can be loaded in a single double[] array, consisting of concatenated rows of data, each containing
           the regressand (Y) value, followed by regressor values; or using a double[][] array with rows corresponding to
           observations. GLS models also require a double[][] array representing the covariance matrix of the error terms.  See
           
           AbstractMultipleLinearRegression#newSampleData(double[],int,int),  
           
           OLSMultipleLinearRegression#newSampleData(double[], double[][]) and 
           
           GLSMultipleLinearRegression#newSampleData(double[],double[][],double[][]) for details.";"class";"newSampleData";"org.apache.commons.math3.stat.regression.GLSMultipleLinearRegression.newSampleData"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[13]/tt[3]";"applyTo(Vector3D)";"generic methods: applyTo(Vector3D) and";"These examples show that a rotation means what the user wants it to
          mean, so this class does not push the user towards one specific
          definition and hence does not provide methods like
          projectVectorIntoDestinationFrame or
          computeTransformedDirection. It provides simpler and more
          generic methods: applyTo(Vector3D) and
          applyInverseTo(Vector3D).";"method";"applyTo";"org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyTo"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[7]/p[1]/a[1]";"org.apache.commons.math3.stat.correlation";"org.apache.commons.math3.stat.correlation package computes covariances";"The 
          org.apache.commons.math3.stat.correlation package computes covariances
          and correlations for pairs of arrays or columns of a matrix.
          
          Covariance computes covariances, 
          
          PearsonsCorrelation provides Pearson's Product-Moment correlation coefficients and
          
          SpearmansCorrelation computes Spearman's rank correlation.";"field";"correlation";"org.apache.commons.math3.stat.correlation.SpearmansCorrelation.correlation"
"math/doc/manual3.1/math/userguide/geometry.html";"/html/body/div[4]/div/div/div[2]/p[14]/tt[7]";"applyTo(Rotation)";"provides the methods: applyTo(Rotation) and";"Since a rotation is basically a vectorial operator, several
          rotations can be composed together and the composite operation
          r = r1 o r2 (which means that for each
          vector u, r(u) = r1(r2(u)))
          is also a rotation. Hence we can consider that in addition to vectors, a
          rotation can be applied to other rotations as well (or to itself). With our
          previous notations, we would say we can apply r1 to
          r2 and the result we get is r =
          r1 o r2. For this purpose, the class
          provides the methods: applyTo(Rotation) and
          applyInverseTo(Rotation).";"method";"applyTo";"org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyTo"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/ul/li[4]/tt[1]";"gTest(expected, observed)";"gTest(expected, observed), which is the tail probability beyond";"The G test implementation provides two p-values:
           gTest(expected, observed), which is the tail probability beyond
           g(expected, observed) in the ChiSquare distribution with degrees
           of freedom one less than the common length of input arrays and 
           gTestIntrinsic(expected, observed) which is the same tail
           probability computed using a ChiSquare distribution with one less degeree
           of freedom.";"method";"gTest";"org.apache.commons.math3.stat.inference.TestUtils.gTest"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/ul/li[4]/tt[2]";"g(expected, observed)";"g(expected, observed) in the ChiSquare distribution with degrees";"The G test implementation provides two p-values:
           gTest(expected, observed), which is the tail probability beyond
           g(expected, observed) in the ChiSquare distribution with degrees
           of freedom one less than the common length of input arrays and 
           gTestIntrinsic(expected, observed) which is the same tail
           probability computed using a ChiSquare distribution with one less degeree
           of freedom.";"method";"g";"org.apache.commons.math3.stat.inference.TestUtils.g"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/ul/li[4]/tt[3]";"gTestIntrinsic(expected, observed)";"gTestIntrinsic(expected, observed) which is the same tail";"The G test implementation provides two p-values:
           gTest(expected, observed), which is the tail probability beyond
           g(expected, observed) in the ChiSquare distribution with degrees
           of freedom one less than the common length of input arrays and 
           gTestIntrinsic(expected, observed) which is the same tail
           probability computed using a ChiSquare distribution with one less degeree
           of freedom.";"method";"gTestIntrinsic";"org.apache.commons.math3.stat.inference.TestUtils.gTestIntrinsic"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[7]/tt[3]";"sum((expected[i] - observed[i])^2 / expected[i])";"sum((expected[i] - observed[i])^2 / expected[i])";"To compute a chi-square statistic measuring the agreement between a
          long[] array of observed counts and a double[]
          array of expected counts, use:
          
long[] observed = {10, 9, 11};
double[] expected = {10.1, 9.8, 10.3};
System.out.println(TestUtils.chiSquare(expected, observed));
          
          the value displayed will be
          sum((expected[i] - observed[i])^2 / expected[i])";"unknown";"sum";"org.apache.commons.math3.stat.StatUtils.sum"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[10]/tt[3]";"sum((counts[i][j] - expected[i][j])^2/expected[i][j])";"sum((counts[i][j] - expected[i][j])^2/expected[i][j])";"To compute a chi-square statistic statistic associated with a
          
          chi-square test of independence based on a two-dimensional (long[][])
          counts array viewed as a two-way table, use:
          
TestUtils.chiSquareTest(counts);
          
          The rows of the 2-way table are
          count[0], ... , count[count.length - 1]. 
          The chi-square statistic returned is
          sum((counts[i][j] - expected[i][j])^2/expected[i][j])
          where the sum is taken over all table entries and
          expected[i][j] is the product of the row and column sums at
          row i, column j divided by the total count.";"unknown";"sum";"org.apache.commons.math3.stat.StatUtils.sum"
"math/doc/manual3.1/math/userguide/stat.html";"/html/body/div[4]/div/div/div[8]/dl/dd[18]/tt";"gDataSetsComparison";"gDataSetsComparison for the test statistic";"To evaluate the hypothesis that two sets of counts come from the
          same underlying distribution, use long[] arrays for the counts and
          gDataSetsComparison for the test statistic
          
long[] obs1 = new long[]{268, 199, 42};
long[] obs2 = new long[]{807, 759, 184};
System.out.println(TestUtils.gDataSetsComparison(obs1, obs2)); // G statistic
System.out.println(TestUtils.gTestDataSetsComparison(obs1, obs2)); // p-value";"class";"gDataSetsComparison";"org.apache.commons.math3.stat.inference.TestUtils.gDataSetsComparison"
"math/doc/manual3.1/math/userguide/analysis.html";"/html/body/div[4]/div/div/div[3]/p[4]/tt[1]";"solve";"In order to use the root-finding features, first a solver object must";"In order to use the root-finding features, first a solver object must
          be created by calling its constructor, often providing relative and absolute
          accuracy. Using a solver object, roots of functions
          are easily found using the solve methods.  These methods takes
          a maximum iteration count maxEval, a function f,
          and either two domain values, min and max, or a
          startValue as parameters. If the maximal number of iterations
          count is exceeded, non-convergence is assumed and a ConvergenceException
          exception is thrown.  A suggested value is 100, which should be plenty, given that a
          bisection algorithm can't get any more accurate after 52 iterations because of the
          number of mantissa bits in a double precision floating point number. If a number of
          ill-conditioned problems is to be solved, this number can be decreased in order
          to avoid wasting time.
          Bracketed
          solvers also take an allowed solution
          enum parameter to specify which side of the final convergence interval should be
          selected as the root. It can be ANY_SIDE, LEFT_SIDE, RIGHT_SIDE,
          BELOW_SIDE or ABOVE_SIDE. Left and right are used to specify the root along
          the function parameter axis while below and above refer to the function value axis. The solve methods
          compute a value c such that:";"unknown";"solve";"org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[4]/p[1]/tt[1]";"solve()";"The solve() methods of the DecompositionSolver";"The solve() methods of the DecompositionSolver
          interface support solving linear systems of equations of the form AX=B, either
          in linear sense or in least square sense. A RealMatrix instance is
          used to represent the coefficient matrix of the system. Solving the system is a
          two phases process: first the coefficient matrix is decomposed in some way and
          then a solver built from the decomposition solves the system. This allows to
          compute the decomposition and build the solver only once if several systems have
          to be solved with the same coefficient matrix.";"method";"solve";"org.apache.commons.math3.linear.DecompositionSolver.solve"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[4]";"getV()";"getV(), getD() and getVT() methods of the";"The getEigenvalue(), getEigenvalues(), getEigenVector(),
          getV(), getD() and getVT() methods of the
          EigenDecomposition interface support solving eigenproblems of the form
          AX = lambda X where lambda is a real scalar.";"method";"getV";"org.apache.commons.math3.linear.EigenDecomposition.getV"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[2]/tt[6]";"getVT()";"getV(), getD() and getVT() methods of the";"The getEigenvalue(), getEigenvalues(), getEigenVector(),
          getV(), getD() and getVT() methods of the
          EigenDecomposition interface support solving eigenproblems of the form
          AX = lambda X where lambda is a real scalar.";"method";"getVT";"org.apache.commons.math3.linear.EigenDecomposition.getVT"
"math/doc/manual3.1/math/userguide/linear.html";"/html/body/div[4]/div/div/div[5]/p[3]/tt[4]";"getV()";"getV() methods of the SingularValueDecomposition interface";"The getSingularValues(), getU(), getS() and
        getV() methods of the SingularValueDecomposition interface
        allow to solve singular values problems of the form AXi = lambda Yi where lambda is a
        real scalar, and where the Xi and Yi vectors form orthogonal bases of their respective
        vector spaces (which may have different dimensions).";"method";"getV";"org.apache.commons.math3.linear.SingularValueDecomposition.getV"
