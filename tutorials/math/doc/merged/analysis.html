<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Jan 9, 2013 ( $Revision: 1.1 $ ) -->
<!-- $HeadURL: https://svn.apache.org/repos/asf/commons/proper/commons-skin/trunk/src/main/resources/META-INF/maven/site.vm $ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
  <title>
    The Commons Math User Guide - Numerical Analysis</title> 
  <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style> 
  <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" /> 
  <meta name="Date-Revision-yyyymmdd" content="20130109" /> 
  <meta http-equiv="Content-Language" content="en" /> 
  <link rel="stylesheet" type="text/css" media="all" href="../css/prettify.css" /> 
  <script src="../js/prettify.js" type="text/javascript"></script> 
  <script type="text/javascript">window.onload=function() {
            prettyPrint();
        }</script> 
 </head> 
 <body class="composite"> 
  <div id="banner"> 
   <div id="bannerLeft"> 
    <a href="http://commons.apache.org/" title="Apache Commons logo"> <img src="../images/commons-logo.png" alt="Apache Commons logo" /> </a> 
   </div> 
   <!-- id="bannerLeft" --> 
   <div id="bannerRight"> 
    <a href="../index.html"> <img src="../images/math.gif" alt="Commons Math" /> </a> 
   </div> 
   <!-- id="bannerRight" --> 
   <div class="clear"> 
    <hr /> 
   </div> 
  </div> 
  <div id="breadcrumbs"> 
   <div class="xleft"> 
    <span id="publishDate">Last Published: 09 January 2013</span> &nbsp;| 
    <span id="projectVersion">Version: 3.1.1</span> 
   </div> 
   <div class="xright"> 
    <a href="http://www.apachecon.com/" class="externalLink" title="ApacheCon">ApacheCon</a> | 
    <a href="http://www.apache.org" class="externalLink" title="Apache">Apache</a> | 
    <a href="../../" title="Commons">Commons</a> 
   </div> 
   <div class="clear"> 
    <hr /> 
   </div> 
  </div> 
  <div id="leftColumn"> 
   <div id="navcolumn"> 
    <h5>Math</h5> 
    <ul> 
     <li class="none"> <a href="../index.html" title="Overview">Overview</a> </li> 
     <li class="none"> <a href="../download_math.cgi" title="Downloads">Downloads</a> </li> 
     <li class="none"> <a href="../apidocs/index.html" title="Latest API docs (development)">Latest API docs (development)</a> </li> 
     <li class="none"> <a href="../api-3.1.1/index.html" title="Javadoc (3.1.1 release)">Javadoc (3.1.1 release)</a> </li> 
     <li class="none"> <a href="../api-3.1/index.html" title="Javadoc (3.1 release)">Javadoc (3.1 release)</a> </li> 
     <li class="none"> <a href="../api-3.0/index.html" title="Javadoc (3.0 release)">Javadoc (3.0 release)</a> </li> 
     <li class="none"> <a href="../api-2.2/index.html" title="Javadoc (2.2 release)">Javadoc (2.2 release)</a> </li> 
     <li class="none"> <a href="../issue-tracking.html" title="Issue Tracking">Issue Tracking</a> </li> 
     <li class="none"> <a href="http://svn.apache.org/viewvc/commons/proper/math/trunk" class="externalLink" title="Source Repository (current)">Source Repository (current)</a> </li> 
     <li class="none"> <a href="http://wiki.apache.org/commons/Math" class="externalLink" title="Wiki">Wiki</a> </li> 
     <li class="none"> <a href="../developers.html" title="Developers Guide">Developers Guide</a> </li> 
     <li class="none"> <a href="../proposal.html" title="Proposal">Proposal</a> </li> 
    </ul> 
    <h5>User Guide</h5> 
    <ul> 
     <li class="none"> <a href="../userguide/index.html" title="Contents">Contents</a> </li> 
     <li class="none"> <a href="../userguide/overview.html" title="Overview">Overview</a> </li> 
     <li class="none"> <a href="../userguide/stat.html" title="Statistics">Statistics</a> </li> 
     <li class="none"> <a href="../userguide/random.html" title="Data Generation">Data Generation</a> </li> 
     <li class="none"> <a href="../userguide/linear.html" title="Linear Algebra">Linear Algebra</a> </li> 
     <li class="none"> <strong>Numerical Analysis</strong> </li> 
     <li class="none"> <a href="../userguide/special.html" title="Special Functions">Special Functions</a> </li> 
     <li class="none"> <a href="../userguide/utilities.html" title="Utilities">Utilities</a> </li> 
     <li class="none"> <a href="../userguide/complex.html" title="Complex Numbers">Complex Numbers</a> </li> 
     <li class="none"> <a href="../userguide/distribution.html" title="Distributions">Distributions</a> </li> 
     <li class="none"> <a href="../userguide/fraction.html" title="Fractions">Fractions</a> </li> 
     <li class="none"> <a href="../userguide/transform.html" title="Transform Methods">Transform Methods</a> </li> 
     <li class="none"> <a href="../userguide/geometry.html" title="3D Geometry">3D Geometry</a> </li> 
     <li class="none"> <a href="../userguide/optimization.html" title="Optimization">Optimization</a> </li> 
     <li class="none"> <a href="../userguide/ode.html" title="Ordinary Differential Equations">Ordinary Differential Equations</a> </li> 
     <li class="none"> <a href="../userguide/genetics.html" title="Genetic Algorithms">Genetic Algorithms</a> </li> 
     <li class="none"> <a href="../userguide/filter.html" title="Filters">Filters</a> </li> 
    </ul> 
    <h5>Project Documentation</h5> 
    <ul> 
     <li class="collapsed"> <a href="../project-info.html" title="Project Information">Project Information</a> </li> 
     <li class="collapsed"> <a href="../project-reports.html" title="Project Reports">Project Reports</a> </li> 
    </ul> 
    <h5>Commons</h5> 
    <ul> 
     <li class="none"> <a href="../../" title="Home">Home</a> </li> 
     <li class="none"> <a href="http://www.apache.org/licenses/" class="externalLink" title="License">License</a> </li> 
     <li class="collapsed"> <a href="../../components.html" title="Components">Components</a> </li> 
     <li class="collapsed"> <a href="../../sandbox/index.html" title="Sandbox">Sandbox</a> </li> 
     <li class="collapsed"> <a href="../../dormant/index.html" title="Dormant">Dormant</a> </li> 
    </ul> 
    <h5>General Information</h5> 
    <ul> 
     <li class="none"> <a href="../../volunteering.html" title="Volunteering">Volunteering</a> </li> 
     <li class="none"> <a href="../../patches.html" title="Contributing Patches">Contributing Patches</a> </li> 
     <li class="none"> <a href="../../building.html" title="Building Components">Building Components</a> </li> 
     <li class="none"> <a href="../../releases/index.html" title="Releasing Components">Releasing Components</a> </li> 
     <li class="none"> <a href="http://wiki.apache.org/commons/FrontPage" class="externalLink" title="Wiki">Wiki</a> </li> 
    </ul> 
    <h5>ASF</h5> 
    <ul> 
     <li class="none"> <a href="http://www.apache.org/foundation/how-it-works.html" class="externalLink" title="How the ASF works">How the ASF works</a> </li> 
     <li class="none"> <a href="http://www.apache.org/foundation/getinvolved.html" class="externalLink" title="Get Involved">Get Involved</a> </li> 
     <li class="none"> <a href="http://www.apache.org/dev/" class="externalLink" title="Developer Resources">Developer Resources</a> </li> 
     <li class="none"> <a href="http://www.apache.org/foundation/sponsorship.html" class="externalLink" title="Sponsorship">Sponsorship</a> </li> 
     <li class="none"> <a href="http://www.apache.org/foundation/thanks.html" class="externalLink" title="Thanks">Thanks</a> </li> 
    </ul> 
    <a href="http://www.apache.org/events/current-event.html" title="ApacheCon" class="poweredBy"> <img class="poweredBy" alt="ApacheCon" src="http://www.apache.org/events/current-event-125x125.png" /> </a> 
    <a href="http://maven.apache.org/" title="Maven" class="poweredBy"> <img class="poweredBy" alt="Maven" src="http://maven.apache.org/images/logos/maven-feather.png" /> </a> 
   </div> 
  </div> 
  <div id="bodyColumn"> 
   <div id="contentBox"> 
    <!-- Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. --> 
    <!-- $Id: analysis.html,v 1.1 2013/08/12 15:49:58 gpetro6 Exp $ --> 
    <div class="section"> 
     <h2>4 Numerical Analysis<a name="a4_Numerical_Analysis"></a></h2> 
     <div class="section"> 
      <h3>4.1 Overview<a name="a4.1_Overview"></a></h3> 
      <p> The analysis package is the parent package for algorithms dealing with real-valued functions of one real variable. It contains dedicated sub-packages providing numerical root-finding, integration, interpolation and differentiation. It also contains a polynomials sub-package that considers polynomials with real coefficients as differentiable real functions. </p> 
      <p> Functions interfaces are intended to be implemented by user code to represent their domain problems. The algorithms provided by the library will then operate on these function to find their roots, or integrate them, or ... Functions can be multivariate or univariate, real vectorial or matrix valued, and they can be differentiable or not. </p> 
     </div> 
     <div class="section"> 
      <h3>4.2 Error handling<a name="a4.2_Error_handling"></a></h3> 
      <p> For user-defined functions, when the method encounters an error during evaluation, users must use their <i>own</i> unchecked exceptions. The following example shows the recommended way to do that, using root solving as the example (the same construct should be used for ODE integrators or for optimizations). </p> 
      <div class="source"> 
       <pre>private static class LocalException extends RuntimeException {

   // the x value that caused the problem
   private final double x;

   public LocalException(double x) {
     this.x = x;
   }

   public double getX() {
     return x;
   }

 }

 private static class MyFunction implements UnivariateFunction {
   public double value(double x) {
     double y = hugeFormula(x);
     if (somethingBadHappens) {
       throw new LocalException(x);
     }
     return y;
   }
 }

 public void compute() {
   try {
     solver.solve(maxEval, new MyFunction(a, b, c), min, max);
   } catch (LocalException le) {
     // retrieve the x value
   }
 }
 </pre> 
      </div> 
      <p> As shown in this example the exception is really something local to user code and there is a guarantee Apache Commons Math will not mess with it. The user is safe. </p> 
     </div> 
     <div class="section"> 
      <h3>4.3 Root-finding<a name="a4.3_Root-finding"></a></h3> 
      <p> <a href="../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html"> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.UnivariateSolver" api="UnivariateSolver" kind="class">
          UnivariateSolver 
        </clt></a>, <a href="../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html"> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver" api="UnivariateDifferentiableSolver" kind="class">
          UnivariateDifferentiableSolver 
        </clt></a> and <a href="../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html"> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.PolynomialSolver" api="PolynomialSolver" kind="class">
          PolynomialSolver 
        </clt></a> provide means to find roots of <a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a>, <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html">differentiable univariate real-valued functions</a>, and <a href="../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
      <font size="+1"></font> 
      <table class="bodyTable" border="1" align="center"> 
       <tbody> 
        <tr class="a"> 
         <td colspan="5"><font size="+2">Root solvers</font></td> 
        </tr> 
        <tr class="b"> 
         <td>Name</td> 
         <td>Function type</td> 
         <td>Convergence</td> 
         <td>Needs initial bracketing</td> 
         <td>Bracket side selection</td> 
        </tr> 
        <tr class="a"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html">Bisection</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>linear, guaranteed</td> 
         <td>yes</td> 
         <td>yes</td> 
        </tr> 
        <tr class="b"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html">Brent-Dekker</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>super-linear, guaranteed</td> 
         <td>yes</td> 
         <td>no</td> 
        </tr> 
        <tr class="a"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html">bracketing n<sup>th</sup> order Brent</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>variable order, guaranteed</td> 
         <td>yes</td> 
         <td>yes</td> 
        </tr> 
        <tr class="b"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html">Illinois Method</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>super-linear, guaranteed</td> 
         <td>yes</td> 
         <td>yes</td> 
        </tr> 
        <tr class="a"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html">Laguerre's Method</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html">polynomial functions</a></td> 
         <td>cubic for simple root, linear for multiple root</td> 
         <td>yes</td> 
         <td>no</td> 
        </tr> 
        <tr class="b"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>quadratic close to roots</td> 
         <td>yes</td> 
         <td>no</td> 
        </tr> 
        <tr class="a"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html">Muller's Method</a> using modulus to deal with real-valued functions</td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>quadratic close to root</td> 
         <td>yes</td> 
         <td>no</td> 
        </tr> 
        <tr class="b"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html">Newton-Raphson's Method</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html">differentiable univariate real-valued functions</a></td> 
         <td>quadratic, non-guaranteed</td> 
         <td>no</td> 
         <td>no</td> 
        </tr> 
        <tr class="a"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html">Pegasus Method</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>super-linear, guaranteed</td> 
         <td>yes</td> 
         <td>yes</td> 
        </tr> 
        <tr class="b"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html">Regula Falsi (false position) Method</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>linear, guaranteed</td> 
         <td>yes</td> 
         <td>yes</td> 
        </tr> 
        <tr class="a"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html">Ridder's Method</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>super-linear</td> 
         <td>yes</td> 
         <td>no</td> 
        </tr> 
        <tr class="b"> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html">Secant Method</a></td> 
         <td><a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html">univariate real-valued functions</a></td> 
         <td>super-linear, non-guaranteed</td> 
         <td>yes</td> 
         <td>no</td> 
        </tr> 
       </tbody> 
      </table> 
      <p> Some algorithms require that the initial search interval brackets the root (i.e. the function values at interval end points have opposite signs). Some algorithms preserve bracketing throughout computation and allow user to specify which side of the convergence interval to select as the root. It is also possible to force a side selection after a root has been found even for algorithms that do not provide this feature by themselves. This is useful for example in sequential search, for which a new search interval is started after a root has been found in order to find the next root. In this case, user must select a side to ensure his loop is not stuck on one root and always return the same solution without making any progress. </p> 
      <p> There are numerous non-obvious traps and pitfalls in root finding. First, the usual disclaimers due to the way real world computers calculate values apply. If the computation of the function provides numerical instabilities, for example due to bit cancellation, the root finding algorithms may behave badly and fail to converge or even return bogus values. There will not necessarily be an indication that the computed root is way off the true value. Secondly, the root finding problem itself may be inherently ill-conditioned. There is a &quot;domain of indeterminacy&quot;, the interval for which the function has near zero absolute values around the true root, which may be large. Even worse, small problems like roundoff error may cause the function value to &quot;numerically oscillate&quot; between negative and positive values. This may again result in roots way off the true value, without indication. There is not much a generic algorithm can do if ill-conditioned problems are met. A way around this is to transform the problem in order to get a better conditioned function. Proper selection of a root-finding algorithm and its configuration parameters requires knowledge of the analytical properties of the function under analysis and numerical analysis techniques. Users are encouraged to consult a numerical analysis text (or a numerical analyst) when selecting and configuring a solver. </p> 
      <p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt>
        <clt fqn="org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve" api="solve" kind="unknown">
         solve
        </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
        <clt fqn="org.apache.commons.math3.exception.ConvergenceException" api="ConvergenceException" kind="class">
          ConvergenceException 
        </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href="../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html">Bracketed solvers</a> also take an <a href="../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
      <ul> 
       <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
       <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
      </ul> 
      <p> Typical usage: </p> 
      <div class="source"> 
       <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
      </div> 
      <p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
      <div class="source"> 
       <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
      </div> 
      <p> The <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.BrentSolver" api="BrentSolver" kind="class">
          BrentSolver 
        </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
      <p> The <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver" api="BracketingNthOrderBrentSolver" kind="class">
          BracketingNthOrderBrentSolver 
        </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p> 
      <p> The <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.SecantSolver" api="SecantSolver" kind="class">
          SecantSolver 
        </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
      <p> The <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver" api="RegulaFalsiSolver" kind="class">
          RegulaFalsiSolver 
        </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
      <p> The <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.IllinoisSolver" api="IllinoisSolver" kind="class">
          IllinoisSolver 
        </clt></tt> and <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.PegasusSolver" api="PegasusSolver" kind="class">
          PegasusSolver 
        </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
      <p> The <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.BisectionSolver" api="BisectionSolver" kind="class">
          BisectionSolver 
        </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p> 
      <p> The <tt> 
        <clt fqn="org.apache.commons.math3.analysis.solvers.UnivariateSolver" api="UnivariateSolver" kind="class">
          UnivariateSolver 
        </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
      <table border="0" class="bodyTable"> 
       <tbody> 
        <tr class="a"> 
         <th>Property</th> 
         <th>Purpose</th> 
        </tr> 
        <tr class="b"> 
         <td>Absolute accuracy</td> 
         <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
        </tr> 
        <tr class="a"> 
         <td>Relative accuracy</td> 
         <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
        </tr> 
        <tr class="b"> 
         <td>Function value accuracy</td> 
         <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
        </tr> 
       </tbody> 
      </table> 
     </div> 
     <div class="section"> 
      <h3>4.4 Interpolation<a name="a4.4_Interpolation"></a></h3> 
      <p> A <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator" api="UnivariateInterpolator" kind="class">
          UnivariateInterpolator 
        </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"> 
        <clt fqn="org.apache.commons.math3.analysis.UnivariateFunction" api="UnivariateFunction" kind="class">
          UnivariateFunction 
        </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
      <p>Typical usage:</p> 
      <div class="source"> 
       <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
      </div> 
      <p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p> 
      <p> The polynomial function returned by the Neville's algorithm is a single polynomial guaranteed to pass exactly through the interpolation points. The degree of the polynomial is the number of points minus 1 (i.e. the interpolation polynomial for a three points set will be a quadratic polynomial). Despite the fact the interpolating polynomials is a perfect approximation of a function at interpolation points, it may be a loose approximation between the points. Due to <a class="externalLink" href="http://en.wikipedia.org/wiki/Runge's_phenomenon">Runge's phenomenom</a> the error can get worse as the degree of the polynomial increases, so adding more points does not always lead to a better interpolation. </p> 
      <p> Loess (or Lowess) interpolation is a robust interpolation useful for smoothing univariate scaterplots. It has been described by William Cleveland in his 1979 seminal paper <a class="externalLink" href="http://www.math.tau.ac.il/~yekutiel/MA%20seminar/Cleveland%201979.pdf">Robust Locally Weighted Regression and Smoothing Scatterplots</a>. This kind of interpolation is computationally intensive but robust. </p> 
      <p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class="externalLink" href="http://www.dudziak.com/microsphere.pdf">MS thesis</a>. </p> 
      <p> <a class="externalLink" href="http://en.wikipedia.org/wiki/Hermite_interpolation">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.interpolation.HermiteInterpolator" api="HermiteInterpolator" kind="class">
          HermiteInterpolator 
        </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
      <div class="source"> 
       <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
      </div> 
      <p> A <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator" api="BivariateGridInterpolator" kind="class">
          BivariateGridInterpolator 
        </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href="../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html"> 
        <clt fqn="org.apache.commons.math3.analysis.BivariateFunction" api="BivariateFunction" kind="class">
          BivariateFunction 
        </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p> 
      <p> In <a class="externalLink" href="http://en.wikipedia.org/wiki/Bicubic_interpolation">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator" api="BicubicSplineInterpolator" kind="class">
          BicubicSplineInterpolator 
        </clt></a> computes a <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html"> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator" api="SmoothingPolynomialBicubicSplineInterpolator" kind="class">
          SmoothingPolynomialBicubicSplineInterpolator 
        </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
      <p> A <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator" api="TrivariateGridInterpolator" kind="class">
          TrivariateGridInterpolator 
        </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href="../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html"> 
        <clt fqn="org.apache.commons.math3.analysis.TrivariateFunction" api="TrivariateFunction" kind="class">
          TrivariateFunction 
        </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p> 
      <p> In <a class="externalLink" href="http://en.wikipedia.org/wiki/Tricubic_interpolation">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator" api="TricubicSplineInterpolator" kind="class">
          TricubicSplineInterpolator 
        </clt></a> computes a <a href="../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html"> tricubic interpolating function</a>. </p> 
     </div> 
     <div class="section"> 
      <h3>4.5 Integration<a name="a4.5_Integration"></a></h3> 
      <p> A <a href="../apidocs/org/apache/commons/math3/analysis/integration/UnivariateIntegrator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.integration.UnivariateIntegrator" api="UnivariateIntegrator" kind="class">
          UnivariateIntegrator 
        </clt></a> provides the means to numerically integrate <a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"> univariate real-valued functions</a>. Commons-Math includes implementations of the following integration algorithms: </p> 
      <ul> 
       <li><a href="../apidocs/org/apache/commons/math3/analysis/integration/RombergIntegrator.html"> Romberg's method</a></li> 
       <li><a href="../apidocs/org/apache/commons/math3/analysis/integration/SimpsonIntegrator.html"> Simpson's method</a></li> 
       <li><a href="../apidocs/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.html"> trapezoid method</a></li> 
       <li><a href="../apidocs/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.html"> Legendre-Gauss method</a></li> 
      </ul> 
     </div> 
     <div class="section"> 
      <h3>4.6 Polynomials<a name="a4.6_Polynomials"></a></h3> 
      <p> The <a href="../apidocs/org/apache/commons/math3/analysis/polynomials/package-summary.html"> org.apache.commons.math3.analysis.polynomials</a> package provides real coefficients polynomials. </p> 
      <p> The <a href="../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"> 
        <clt fqn="org.apache.commons.math3.analysis.polynomials.PolynomialFunction" api="PolynomialFunction" kind="class">
          PolynomialFunction 
        </clt></a> class is the most general one, using traditional coefficients arrays. The <a href="../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialsUtils.html"> 
        <clt fqn="org.apache.commons.math3.analysis.polynomials.PolynomialsUtils" api="PolynomialsUtils" kind="class">
          PolynomialsUtils 
        </clt></a> utility class provides static factory methods to build Chebyshev, Hermite, Jacobi, Laguerre and Legendre polynomials. Coefficients are computed using exact fractions so these factory methods can build polynomials up to any degree. </p> 
     </div> 
     <div class="section"> 
      <h3>4.7 Differentiation<a name="a4.7_Differentiation"></a></h3> 
      <p> The <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html"> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
      <p> The core class is <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.DerivativeStructure" api="DerivativeStructure" kind="class">
          DerivativeStructure 
        </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction" api="UnivariateDifferentiableFunction" kind="class">
          UnivariateDifferentiableFunction 
        </clt></a> interface. Any differentiable function should implement this interface. </p> 
      <p> The main idea behind the <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.DerivativeStructure" api="DerivativeStructure" kind="class">
          DerivativeStructure 
        </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class="externalLink" href="http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p> 
      <p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.DerivativeStructure" api="DerivativeStructure" kind="class">
          DerivativeStructure 
        </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
      <div class="source"> 
       <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
      </div> 
      <p> In fact, there are no notions of <i>variables</i> in the framework, so neither <tt>x</tt> nor <tt>y</tt> are considered to be variables per se. They are both considered to be <i>functions</i> and to depend on implicit free parameters which are represented only by indices in the framework. The <tt>x</tt> instance above is there considered by the framework to be a function of free parameter <tt>p0</tt> at index 0, and as <tt>y</tt> is computed from <tt>x</tt> it is the result of a functions composition and is therefore also a function of this <tt>p0</tt> free parameter. The <tt>p0</tt> is not represented by itself, it is simply defined implicitely by the 0 index above. This index is the third argument in the constructor of the <tt>x</tt> instance. What this constructor means is that we built <tt>x</tt> as a function that depends on one free parameter only (first constructor argument set to 1), that can be differentiated up to order 3 (second constructor argument set to 3), and which correspond to an identity function with respect to implicit free parameter number 0 (third constructor argument set to 0), with current value equal to 2.5 (fourth constructor argument set to 2.5). This specific constructor defines identity functions, and identity functions are the trick we use to represent variables (there are of course other constructors, for example to build constants or functions from all their derivatives if they are known beforehand). From the user point of view, the <tt>x</tt> instance can be seen as the <tt>x</tt> variable, but it is really the identity function applied to free parameter number 0. As the identity function, it has the same value as its parameter, its first derivative is 1.0 with respect to this free parameter, and all its higher order derivatives are 0.0. This can be checked by calling the getValue() or getPartialDerivative() methods on <tt>x</tt>. </p> 
      <p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative" api="getPartialDerivative" kind="method">
          z.getPartialDerivative(1) 
        </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
      <p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p> 
      <p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative" api="getPartialDerivative" kind="class">
          getPartialDerivative 
        </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p> 
      <div class="source"> 
       <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
      </div> 
      <p> There are several ways a user can create an implementation of the <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction" api="UnivariateDifferentiableFunction" kind="class">
          UnivariateDifferentiableFunction 
        </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.DerivativeStructure" api="DerivativeStructure" kind="class">
          DerivativeStructure 
        </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href="../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"> 
        <clt fqn="org.apache.commons.math3.analysis.UnivariateFunction" api="UnivariateFunction" kind="class">
          UnivariateFunction 
        </clt></a> and to pass it to an existing implementation of the <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator" api="UnivariateFunctionDifferentiator" kind="class">
          UnivariateFunctionDifferentiator 
        </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.DerivativeStructure" api="DerivativeStructure" kind="class">
          DerivativeStructure 
        </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p> 
      <p> Apache Commons Math provides one implementation of the <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator" api="UnivariateFunctionDifferentiator" kind="class">
          UnivariateFunctionDifferentiator 
        </clt></a> interface: <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator" api="FiniteDifferencesDifferentiator" kind="class">
          FiniteDifferencesDifferentiator 
        </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
      <p> Another implementation of the <a href="../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html"> 
        <clt fqn="org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator" api="UnivariateFunctionDifferentiator" kind="class">
          UnivariateFunctionDifferentiator 
        </clt></a> interface is under development in the related project <a class="externalLink" href="http://commons.apache.org/sandbox/nabla/">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div class="clear"> 
   <hr /> 
  </div> 
  <div id="footer"> 
   <div class="center">
     Copyright &copy; 2003-2013 
    <a href="http://www.apache.org/">The Apache Software Foundation</a>. All Rights Reserved. 
   </div> 
   <div class="center">
     Apache Commons, Apache Commons Math, Apache, the Apache feather logo, and the Apache Commons project logos are trademarks of The Apache Software Foundation. All other marks mentioned may be trademarks or registered trademarks of their respective owners. 
   </div> 
   <div class="clear"> 
    <hr /> 
   </div> 
  </div>  
 </body>
</html>