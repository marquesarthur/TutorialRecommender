,"Map Implementations","Map Implementations","<div id=""PageTitle""> 
 <h1>Map Implementations</h1> 
</div> 
<p><code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations are grouped into general-purpose, special-purpose, and concurrent implementations.</p>","Map","java.util.Map","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","Map","java.util.Map","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","HashMap","java.util.HashMap","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","TreeMap","java.util.TreeMap","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","LinkedHashMap","java.util.LinkedHashMap","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","SortedMap","java.util.SortedMap","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","Collection","java.util.Collection","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","Set","java.util.Set","class",0
,"Map Implementations","General-Purpose Map Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a> implementations are <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html""><code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html""><code> 
   <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
     TreeMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html""><code> 
   <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
     LinkedHashMap 
   </clt></code></a>. If you need <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> operations or key-ordered <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>-view iteration, use <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>; if you want maximum speed and don't care about iteration order, use <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>; if you want near-<code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> performance and insertion-order iteration, use <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>. In this respect, the situation for <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is analogous to <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Likewise, everything else in the <a class=""TutorialLink"" target=""_top"" href=""../implementations/set.html"">Set Implementations</a> section also applies to <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides two capabilities that are not available with <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. When you create a <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code>, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, <code> 
  <clt fqn=""java.util.LinkedHashMap"" api=""LinkedHashMap"" kind=""class"">
    LinkedHashMap 
  </clt></code> provides the <code> 
  <clt fqn=""java.util.LinkedHashMap.removeEldestEntry"" api=""LinkedHashMap"" kind=""method"">
   LinkedHashMap.removeEldestEntry
  </clt></code> method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p>","LinkedHashSet","java.util.LinkedHashSet","class",0
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","Map","java.util.Map","class",0
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","EnumMap","java.util.EnumMap","class",0
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","WeakHashMap","java.util.WeakHashMap","class",0
,"Map Implementations","Special-Purpose Map Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>There are three special-purpose Map implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html""><code> 
   <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
     EnumMap 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html""><code> 
   <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
     WeakHashMap 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html""><code> 
   <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
     IdentityHashMap 
   </clt></code></a>. <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code>, which is internally implemented as an <code>array</code>, is a high-performance <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation for use with enum keys. This implementation combines the richness and safety of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an <code> 
  <clt fqn=""java.util.EnumMap"" api=""EnumMap"" kind=""class"">
    EnumMap 
  </clt></code> in preference to an array.</p> 
<p><code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code> is an implementation of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the <code> 
  <clt fqn=""java.util.WeakHashMap"" api=""WeakHashMap"" kind=""class"">
    WeakHashMap 
  </clt></code>. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p>","IdentityHashMap","java.util.IdentityHashMap","class",0
,"Map Implementations","Special-Purpose Map Implementations - part 2","<h3>Special-Purpose Map Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> is an identity-based <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based &quot;node table&quot; that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting &quot;spoof attacks&quot; that are a result of intentionally perverse <code>equals</code> methods because <code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> never invokes the <code>equals</code> method on its keys. An added benefit of this implementation is that it is fast.</p>","IdentityHashMap","java.util.IdentityHashMap","class",0
,"Map Implementations","Special-Purpose Map Implementations - part 2","<h3>Special-Purpose Map Implementations - part 2</h3>
<p><code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> is an identity-based <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based &quot;node table&quot; that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting &quot;spoof attacks&quot; that are a result of intentionally perverse <code>equals</code> methods because <code> 
  <clt fqn=""java.util.IdentityHashMap"" api=""IdentityHashMap"" kind=""class"">
    IdentityHashMap 
  </clt></code> never invokes the <code>equals</code> method on its keys. An added benefit of this implementation is that it is fast.</p>","Map","java.util.Map","class",0
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","Map","java.util.Map","class",0
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","ConcurrentMap","java.util.concurrent.ConcurrentMap","class",0
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","ConcurrentHashMap","java.util.concurrent.ConcurrentHashMap","class",0
,"Map Implementations","Concurrent Map Implementations","<h2>Concurrent 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Implementations</h2> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html""><code>java.util.concurrent</code></a> package contains the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
     ConcurrentMap 
   </clt></code></a> interface, which extends <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> with atomic <code>putIfAbsent</code>, <code>remove</code>, and <code>replace</code> methods, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html""><code> 
   <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
     ConcurrentHashMap 
   </clt></code></a> implementation of that interface.</p> 
<p><code> 
  <clt fqn=""java.util.concurrent.ConcurrentHashMap"" api=""ConcurrentHashMap"" kind=""class"">
    ConcurrentHashMap 
  </clt></code> is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>: in addition to implementing <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code>, it supports all the legacy methods peculiar to <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>. Again, if you don't need the legacy operations, be careful to manipulate it with the <code> 
  <clt fqn=""java.util.concurrent.ConcurrentMap"" api=""ConcurrentMap"" kind=""class"">
    ConcurrentMap 
  </clt></code> interface.</p>","Hashtable","java.util.Hashtable","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","Set","java.util.Set","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","Map","java.util.Map","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","HashSet","java.util.HashSet","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","ArrayList","java.util.ArrayList","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","LinkedList","java.util.LinkedList","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","HashMap","java.util.HashMap","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","TreeSet","java.util.TreeSet","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","Comparator","java.util.Comparator","class",0
,"Answers to Questions and Exercises:","Questions","<h2>Questions</h2> 
<ol> 
 <li>Question: You plan to write a program that uses several basic collection interfaces: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>, <code>List</code>, <code>Queue</code>, and <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>. You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> <code>List</code>: <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> <code>Queue</code>: <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code>: <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code>Question: If you need a <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> implementation that provides value-ordered iteration, which class should you use? Answer: <code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code> guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the <code> 
   <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
     Comparator 
   </clt></code> provided.</li> 
 <li>Question: Which class do you use to access wrapper implementations? Answer: You use the <code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code> class, which provides static methods that operate on or return collections.</li> 
</ol>","Collections","java.util.Collections","class",0
,"Answers to Questions and Exercises:","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Exercise: Write a program that reads a text file, specified by the first command line argument, into a <code>List</code>. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/io/File.html#length()""><code> 
    <clt fqn=""java.io.File.length"" api=""File"" kind=""method"">
     java.io.File.length
    </clt></code></a> to obtain the size of the file, then divide by an assumed size of an average line. Answer: Since we are accessing the <code>List</code> randomly, we will use <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code>. We estimate the number of lines by taking the file size and dividing by 50. We then double that figure, since it is more efficient to overestimate than to underestmate. 
  <div class=""codeblock""> 
   <pre>
import java.util.*;
import java.io.*;
public class FileList {
public static void main(String[] args) {
final int assumedLineLength = 50;
File file = new File(args[0]);
List&lt;String&gt; fileList = 
new ArrayList&lt;String&gt;((int)(file.length() / assumedLineLength) * 2);
BufferedReader reader = null;
int lineCount = 0;
try {
reader = new BufferedReader(new FileReader(file));
for (String line = reader.readLine(); line != null;
line = reader.readLine()) {
fileList.add(line);
lineCount++;
}
} catch (IOException e) {
System.err.format(&quot;Could not read %s: %s%n&quot;, file, e);
System.exit(1);
} finally {
if (reader != null) {
try {
reader.close();
} catch (IOException e) {}
}
}
int repeats = Integer.parseInt(args[1]);
Random random = new Random();
for (int i = 0; i &lt; repeats; i++) {
System.out.format(&quot;%d: %s%n&quot;, i,
fileList.get(random.nextInt(lineCount - 1)));
}
}
}
</pre> 
  </div> This program actually spends most of its time reading in the file, so pre-allocating the <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> has little affect on its performance. Specifying an initial capacity in advance is more likely to be useful when your program repeatly creates large <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> objects without intervening I/O.</li> 
</ol>","File","java.io.File.length","class",0
,"Answers to Questions and Exercises:","Exercises","<h2>Exercises</h2> 
<ol> 
 <li>Exercise: Write a program that reads a text file, specified by the first command line argument, into a <code>List</code>. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/io/File.html#length()""><code> 
    <clt fqn=""java.io.File.length"" api=""File"" kind=""method"">
     java.io.File.length
    </clt></code></a> to obtain the size of the file, then divide by an assumed size of an average line. Answer: Since we are accessing the <code>List</code> randomly, we will use <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code>. We estimate the number of lines by taking the file size and dividing by 50. We then double that figure, since it is more efficient to overestimate than to underestmate. 
  <div class=""codeblock""> 
   <pre>
import java.util.*;
import java.io.*;
public class FileList {
public static void main(String[] args) {
final int assumedLineLength = 50;
File file = new File(args[0]);
List&lt;String&gt; fileList = 
new ArrayList&lt;String&gt;((int)(file.length() / assumedLineLength) * 2);
BufferedReader reader = null;
int lineCount = 0;
try {
reader = new BufferedReader(new FileReader(file));
for (String line = reader.readLine(); line != null;
line = reader.readLine()) {
fileList.add(line);
lineCount++;
}
} catch (IOException e) {
System.err.format(&quot;Could not read %s: %s%n&quot;, file, e);
System.exit(1);
} finally {
if (reader != null) {
try {
reader.close();
} catch (IOException e) {}
}
}
int repeats = Integer.parseInt(args[1]);
Random random = new Random();
for (int i = 0; i &lt; repeats; i++) {
System.out.format(&quot;%d: %s%n&quot;, i,
fileList.get(random.nextInt(lineCount - 1)));
}
}
}
</pre> 
  </div> This program actually spends most of its time reading in the file, so pre-allocating the <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> has little affect on its performance. Specifying an initial capacity in advance is more likely to be useful when your program repeatly creates large <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> objects without intervening I/O.</li> 
</ol>","ArrayList","java.util.ArrayList","class",0
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code> 
  <clt fqn=""java.util.ArrayList.isEmpty"" api=""ArrayList"" kind=""method"">
   peek
  </clt></code>, and <code> 
  <clt fqn=""java.util.ArrayList.contains"" api=""ArrayList"" kind=""method"">
   element
  </clt></code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.ArrayList.add"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Queue","java.util.Queue","class",0
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code> 
  <clt fqn=""java.util.ArrayList.isEmpty"" api=""ArrayList"" kind=""method"">
   peek
  </clt></code>, and <code> 
  <clt fqn=""java.util.ArrayList.contains"" api=""ArrayList"" kind=""method"">
   element
  </clt></code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.ArrayList.add"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","LinkedList","java.util.LinkedList","class",0
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code> 
  <clt fqn=""java.util.ArrayList.isEmpty"" api=""ArrayList"" kind=""method"">
   peek
  </clt></code>, and <code> 
  <clt fqn=""java.util.ArrayList.contains"" api=""ArrayList"" kind=""method"">
   element
  </clt></code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.ArrayList.add"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","PriorityQueue","java.util.PriorityQueue","class",0
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code> 
  <clt fqn=""java.util.ArrayList.isEmpty"" api=""ArrayList"" kind=""method"">
   peek
  </clt></code>, and <code> 
  <clt fqn=""java.util.ArrayList.contains"" api=""ArrayList"" kind=""method"">
   element
  </clt></code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.ArrayList.add"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Comparator","java.util.Comparator","class",0
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code> 
  <clt fqn=""java.util.ArrayList.isEmpty"" api=""ArrayList"" kind=""method"">
   peek
  </clt></code>, and <code> 
  <clt fqn=""java.util.ArrayList.contains"" api=""ArrayList"" kind=""method"">
   element
  </clt></code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.ArrayList.add"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","ArrayList","java.util.ArrayList","class",0
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code> 
  <clt fqn=""java.util.ArrayList.isEmpty"" api=""ArrayList"" kind=""method"">
   peek
  </clt></code>, and <code> 
  <clt fqn=""java.util.ArrayList.contains"" api=""ArrayList"" kind=""method"">
   element
  </clt></code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.ArrayList.add"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Collection","java.util.Collection","class",0
,"Queue Implementations","General-Purpose Queue Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>As mentioned in the previous section, <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> implements the <code>Queue</code> interface, providing first in, first out (FIFO) queue operations for <code>add</code>, <code>poll</code>, and so on.</p> 
<p>The <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html""><code> 
   <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
     PriorityQueue 
   </clt></code></a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>.</p> 
<p>The queue retrieval operations ? <code>poll</code>, <code>remove</code>, <code> 
  <clt fqn=""java.util.ArrayList.isEmpty"" api=""ArrayList"" kind=""method"">
   peek
  </clt></code>, and <code> 
  <clt fqn=""java.util.ArrayList.contains"" api=""ArrayList"" kind=""method"">
   element
  </clt></code> ? access the element at the head of the queue. The <em> 
  <clt fqn=""java.awt.Queue.head"" api=""Queue"" kind=""field"">
   Queue.head of the queue
  </clt></em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p> 
<p><code> 
  <clt fqn=""java.util.ArrayList.add"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> and its iterator implement all of the optional methods of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code>Iterator</code> interfaces. The iterator provided in method <code>iterator</code> is not guaranteed to traverse the elements of the <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   PriorityQueue
  </clt></code> in any particular order. For ordered traversal, consider using <code> 
  <clt fqn=""java.util.Arrays"" api=""Arrays"" kind=""class"">
    Arrays.sort(pq.toArray()) 
  </clt></code>.</p>","Arrays","java.util.Arrays","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","Queue","java.awt.Queue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","BlockingQueue","java.util.concurrent.BlockingQueue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","LinkedBlockingQueue","java.util.concurrent.LinkedBlockingQueue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","ArrayBlockingQueue","java.util.concurrent.ArrayBlockingQueue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","PriorityBlockingQueue","java.util.concurrent.PriorityBlockingQueue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","DelayQueue","java.util.concurrent.DelayQueue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","SynchronousQueue","java.util.concurrent.SynchronousQueue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","TransferQueue","java.util.concurrent.SynchronousQueue.TransferQueue","class",0
,"Queue Implementations","Concurrent Queue Implementations","<h2>Concurrent 
 <clt fqn=""java.awt.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Implementations</h2> 
<p>The <code>java.util.concurrent</code> package contains a set of synchronized <code>Queue</code> interfaces and classes. <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html""><code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code></a> extends <code>Queue</code> with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.LinkedBlockingQueue"" api=""LinkedBlockingQueue"" kind=""class"">
      LinkedBlockingQueue 
    </clt></code></a> ? an optionally bounded FIFO blocking queue backed by linked nodes</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ArrayBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.ArrayBlockingQueue"" api=""ArrayBlockingQueue"" kind=""class"">
      ArrayBlockingQueue 
    </clt></code></a> ? a bounded FIFO blocking queue backed by an array</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html""><code> 
    <clt fqn=""java.util.concurrent.PriorityBlockingQueue"" api=""PriorityBlockingQueue"" kind=""class"">
      PriorityBlockingQueue 
    </clt></code></a> ? an unbounded blocking priority queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html""><code> 
    <clt fqn=""java.util.concurrent.DelayQueue"" api=""DelayQueue"" kind=""class"">
      DelayQueue 
    </clt></code></a> ? a time-based scheduling queue backed by a heap</li> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html""><code> 
    <clt fqn=""java.util.concurrent.SynchronousQueue"" api=""SynchronousQueue"" kind=""class"">
      SynchronousQueue 
    </clt></code></a> ? a simple rendezvous mechanism that uses the <code> 
   <clt fqn=""java.util.concurrent.BlockingQueue"" api=""BlockingQueue"" kind=""class"">
     BlockingQueue 
   </clt></code> interface</li> 
</ul> 
<p>In JDK 7, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TransferQueue.html""><code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code></a> is a specialized <code> 
  <clt fqn=""java.util.ArrayList.addAll"" api=""ArrayList"" kind=""method"">
   BlockingQueue
  </clt></code> in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. <code> 
  <clt fqn=""java.util.ArrayList.remove"" api=""ArrayList"" kind=""method"">
   TransferQueue
  </clt></code> has a single implementation:</p> 
<ul> 
 <li> <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedTransferQueue.html""><code>LinkedTransferQueue</code></a> ? an unbounded <code> 
   <clt fqn=""java.util.concurrent.SynchronousQueue.TransferQueue"" api=""TransferQueue"" kind=""class"">
     TransferQueue 
   </clt></code> based on linked nodes</li> 
</ul>","ArrayList","java.util.ArrayList","class",0
,"Set Implementations","Set Implementations","<div id=""PageTitle""> 
 <h1>Set Implementations</h1> 
</div> 
<p>The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations are grouped into general-purpose and special-purpose implementations.</p>","Set","java.util.Set","class",0
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","Set","java.util.Set","class",0
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","HashSet","java.util.HashSet","class",0
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","TreeSet","java.util.TreeSet","class",0
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","LinkedHashSet","java.util.LinkedHashSet","class",0
,"Set Implementations","General-Purpose Set Implementations","<h2>General-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are three general-purpose <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html""><code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html""><code> 
   <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
     TreeSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html""><code> 
   <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
     LinkedHashSet 
   </clt></code></a>. Which of these three to use is generally straightforward. <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is much faster than <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, or if value-ordered iteration is required, use <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>; otherwise, use <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. It's a fair bet that you'll end up using <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> most of the time.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> is in some sense intermediate between <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. The <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> implementation spares its clients from the unspecified, generally chaotic ordering provided by <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> without incurring the increased cost associated with <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code>.</p>","SortedSet","java.util.SortedSet","class",0
,"Set Implementations","General-Purpose Set Implementations - part 2","<h3>General-Purpose Set Implementations - part 2</h3>
<p>One thing worth keeping in mind about <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is that iteration is linear in the sum of the number of entries and the number of buckets (the <em>capacity</em>). Thus, choosing an initial capacity that's too high can waste both space and time. On the other hand, choosing an initial capacity that's too low wastes time by copying the data structure each time it's forced to increase its capacity. If you don't specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the <code> 
  <clt fqn=""java.util.ArrayList.size"" api=""ArrayList"" kind=""method"">
   int
  </clt></code> constructor. The following line of code allocates a <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> whose initial capacity is 64.</p> 
<div class=""codeblock""> 
 <pre>
Set&lt;String&gt; s = new HashSet&lt;String&gt;(64);
</pre> 
</div>","HashSet","java.util.HashSet","class",0
,"Set Implementations","General-Purpose Set Implementations - part 2","<h3>General-Purpose Set Implementations - part 2</h3>
<p>One thing worth keeping in mind about <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is that iteration is linear in the sum of the number of entries and the number of buckets (the <em>capacity</em>). Thus, choosing an initial capacity that's too high can waste both space and time. On the other hand, choosing an initial capacity that's too low wastes time by copying the data structure each time it's forced to increase its capacity. If you don't specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the <code> 
  <clt fqn=""java.util.ArrayList.size"" api=""ArrayList"" kind=""method"">
   int
  </clt></code> constructor. The following line of code allocates a <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> whose initial capacity is 64.</p> 
<div class=""codeblock""> 
 <pre>
Set&lt;String&gt; s = new HashSet&lt;String&gt;(64);
</pre> 
</div>","ArrayList","java.util.ArrayList","class",0
,"Set Implementations","General-Purpose Set Implementations - part 3","<h3>General-Purpose Set Implementations - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> class has one other tuning parameter called the <em>load factor</em>. If you care a lot about the space consumption of your <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, read the <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do.</p> 
<p>If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> has the same tuning parameters as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, but iteration time is not affected by capacity. <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> has no tuning parameters.</p>","HashSet","java.util.HashSet","class",0
,"Set Implementations","General-Purpose Set Implementations - part 3","<h3>General-Purpose Set Implementations - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> class has one other tuning parameter called the <em>load factor</em>. If you care a lot about the space consumption of your <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, read the <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do.</p> 
<p>If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> has the same tuning parameters as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, but iteration time is not affected by capacity. <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> has no tuning parameters.</p>","LinkedHashSet","java.util.LinkedHashSet","class",0
,"Set Implementations","General-Purpose Set Implementations - part 3","<h3>General-Purpose Set Implementations - part 3</h3>
<p>The <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> class has one other tuning parameter called the <em>load factor</em>. If you care a lot about the space consumption of your <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, read the <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do.</p> 
<p>If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem.</p> 
<p><code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> has the same tuning parameters as <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>, but iteration time is not affected by capacity. <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> has no tuning parameters.</p>","TreeSet","java.util.TreeSet","class",0
,"Set Implementations","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<div class=""codeblock""> 
 <pre>
for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))
System.out.println(d);
</pre> 
</div> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<div class=""codeblock""> 
 <pre>
EnumSet.of(Style.BOLD, Style.ITALIC)
</pre> 
</div> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","Set","java.util.Set","class",0
,"Set Implementations","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<div class=""codeblock""> 
 <pre>
for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))
System.out.println(d);
</pre> 
</div> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<div class=""codeblock""> 
 <pre>
EnumSet.of(Style.BOLD, Style.ITALIC)
</pre> 
</div> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","EnumSet","java.util.EnumSet","class",0
,"Set Implementations","Special-Purpose Set Implementations","<h2>Special-Purpose 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Implementations</h2> 
<p>There are two special-purpose <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html""><code> 
   <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
     EnumSet 
   </clt></code></a> and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html""><code> 
   <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
     CopyOnWriteArraySet 
   </clt></code></a>.</p> 
<p><code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> is a high-performance <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single <code>long</code>. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The <code> 
  <clt fqn=""java.util.EnumSet"" api=""EnumSet"" kind=""class"">
    EnumSet 
  </clt></code> class provides a static factory that makes it easy.</p> 
<div class=""codeblock""> 
 <pre>
for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY))
System.out.println(d);
</pre> 
</div> 
<p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p> 
<div class=""codeblock""> 
 <pre>
EnumSet.of(Style.BOLD, Style.ITALIC)
</pre> 
</div> 
<p><code> 
  <clt fqn=""java.util.concurrent.CopyOnWriteArraySet"" api=""CopyOnWriteArraySet"" kind=""class"">
    CopyOnWriteArraySet 
  </clt></code> is a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation backed up by a copy-on-write array. All mutative operations, such as <code>add</code>, <code>set</code>, and <code>remove</code>, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations, the <code>add</code>, <code>remove</code>, and <code>contains</code> methods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p>","CopyOnWriteArraySet","java.util.concurrent.CopyOnWriteArraySet","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","Set","java.util.Set","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","HashSet","java.util.HashSet","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","List","java.util.List","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","ArrayList","java.util.ArrayList","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","Map","java.util.Map","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","HashMap","java.util.HashMap","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","Queue","java.util.Queue","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","LinkedList","java.util.LinkedList","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","Deque","java.util.Deque","class",0
,"Summary of Implementations","Summary of Implementations","<div id=""PageTitle""> 
 <h1>Summary of Implementations</h1> 
</div> 
<p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">Interfaces lesson</a>.</p> 
<p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p> 
<ul> 
 <li>For the <code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
     HashSet 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
     ArrayList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
     HashMap 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code><clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">Queue</clt></code> interface, <code> 
   <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
     LinkedList 
   </clt></code> is the most commonly used implementation.</li> 
 <li>For the <code> 
   <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
     Deque 
   </clt></code> interface, <code> 
   <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
     ArrayDeque 
   </clt></code> is the most commonly used implementation.</li> 
</ul> 
<p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p> 
<p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p> 
<p>The <code>java.util.concurrent</code> package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p>","ArrayDeque","java.util.ArrayDeque","class",0
,"Summary of Implementations","Summary of Implementations - part 2","<h3>Summary of Implementations - part 2</h3>
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class (as opposed to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface), provides static methods that operate on or return collections, which are known as Wrapper implementations.</p> 
<p>Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.</p>","Collections","java.util.Collections","class",0
,"Summary of Implementations","Summary of Implementations - part 2","<h3>Summary of Implementations - part 2</h3>
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections 
  </clt></code> class (as opposed to the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface), provides static methods that operate on or return collections, which are known as Wrapper implementations.</p> 
<p>Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.</p>","Collection","java.util.Collection","class",0
,"Wrapper Implementations","Wrapper Implementations","<div id=""PageTitle""> 
 <h1>Wrapper Implementations</h1> 
</div> 
<p>Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the <em>decorator</em> pattern. Although it may seem a bit exotic, it's really pretty straightforward.</p> 
<p>These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections 
   </clt></code></a> class, which consists solely of static methods.</p>","Collections","java.util.Collections","class",0
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);
</pre> 
</div> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<div class=""codeblock""> 
 <pre>
List&lt;Type&gt; list = Collections.synchronizedList(new ArrayList&lt;Type&gt;());
</pre> 
</div> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p> 
<div class=""codeblock""> 
 <pre>
Collection&lt;Type&gt; c = Collections.synchronizedCollection(myCollection);
synchronized(c) {
for (Type e : c)
foo(e);
}
</pre> 
</div>","Collection","java.util.Collection","class",0
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);
</pre> 
</div> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<div class=""codeblock""> 
 <pre>
List&lt;Type&gt; list = Collections.synchronizedList(new ArrayList&lt;Type&gt;());
</pre> 
</div> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p> 
<div class=""codeblock""> 
 <pre>
Collection&lt;Type&gt; c = Collections.synchronizedCollection(myCollection);
synchronized(c) {
for (Type e : c)
foo(e);
}
</pre> 
</div>","Set","java.util.Set","class",0
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);
</pre> 
</div> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<div class=""codeblock""> 
 <pre>
List&lt;Type&gt; list = Collections.synchronizedList(new ArrayList&lt;Type&gt;());
</pre> 
</div> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p> 
<div class=""codeblock""> 
 <pre>
Collection&lt;Type&gt; c = Collections.synchronizedCollection(myCollection);
synchronized(c) {
for (Type e : c)
foo(e);
}
</pre> 
</div>","Map","java.util.Map","class",0
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);
</pre> 
</div> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<div class=""codeblock""> 
 <pre>
List&lt;Type&gt; list = Collections.synchronizedList(new ArrayList&lt;Type&gt;());
</pre> 
</div> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p> 
<div class=""codeblock""> 
 <pre>
Collection&lt;Type&gt; c = Collections.synchronizedCollection(myCollection);
synchronized(c) {
for (Type e : c)
foo(e);
}
</pre> 
</div>","SortedSet","java.util.SortedSet","class",0
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);
</pre> 
</div> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<div class=""codeblock""> 
 <pre>
List&lt;Type&gt; list = Collections.synchronizedList(new ArrayList&lt;Type&gt;());
</pre> 
</div> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p> 
<div class=""codeblock""> 
 <pre>
Collection&lt;Type&gt; c = Collections.synchronizedCollection(myCollection);
synchronized(c) {
for (Type e : c)
foo(e);
}
</pre> 
</div>","SortedMap","java.util.SortedMap","class",0
,"Wrapper Implementations","Synchronization Wrappers","<h2>Synchronization Wrappers</h2> 
<p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/List.html""><code>List</code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     Map 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     SortedSet 
   </clt></code></a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     SortedMap 
   </clt></code></a> ? has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);
</pre> 
</div> 
<p>Each of these methods returns a synchronized (thread-safe) <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p> 
<div class=""codeblock""> 
 <pre>
List&lt;Type&gt; list = Collections.synchronizedList(new ArrayList&lt;Type&gt;());
</pre> 
</div> 
<p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>.</p> 
<p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p> 
<div class=""codeblock""> 
 <pre>
Collection&lt;Type&gt; c = Collections.synchronizedCollection(myCollection);
synchronized(c) {
for (Type e : c)
foo(e);
}
</pre> 
</div>","Vector","java.util.Vector","class",0
,"Wrapper Implementations","Synchronization Wrappers - part 2","<h3>Synchronization Wrappers - part 2</h3>
<p>If an explicit iterator is used, the <code>iterator</code> method must be called from within the <code>synchronized</code> block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view of a synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is similar. It is imperative that the user synchronize on the synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> when iterating over any of its <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views rather than synchronizing on the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view itself, as shown in the following example.</p> 
<div class=""codeblock""> 
 <pre>
Map&lt;KeyType, ValType&gt; m = Collections.synchronizedMap(new HashMap&lt;KeyType, ValType&gt;());
...
Set&lt;KeyType&gt; s = m.keySet();
...
// Synchronizing on m, not s!
synchronized(m) {
while (KeyType k : s)
foo(k);
}
</pre> 
</div> 
<p>One minor downside of using wrapper implementations is that you do not have the ability to execute any <em>noninterface</em> operations of a wrapped implementation. So, for instance, in the preceding <code>List</code> example, you cannot call <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ensureCapacity(int)""><code>ensureCapacity</code></a> operation on the wrapped <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>.</p>","Collection","java.util.Collection","class",0
,"Wrapper Implementations","Synchronization Wrappers - part 2","<h3>Synchronization Wrappers - part 2</h3>
<p>If an explicit iterator is used, the <code>iterator</code> method must be called from within the <code>synchronized</code> block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view of a synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is similar. It is imperative that the user synchronize on the synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> when iterating over any of its <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views rather than synchronizing on the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view itself, as shown in the following example.</p> 
<div class=""codeblock""> 
 <pre>
Map&lt;KeyType, ValType&gt; m = Collections.synchronizedMap(new HashMap&lt;KeyType, ValType&gt;());
...
Set&lt;KeyType&gt; s = m.keySet();
...
// Synchronizing on m, not s!
synchronized(m) {
while (KeyType k : s)
foo(k);
}
</pre> 
</div> 
<p>One minor downside of using wrapper implementations is that you do not have the ability to execute any <em>noninterface</em> operations of a wrapped implementation. So, for instance, in the preceding <code>List</code> example, you cannot call <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ensureCapacity(int)""><code>ensureCapacity</code></a> operation on the wrapped <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>.</p>","Map","java.util.Map","class",0
,"Wrapper Implementations","Synchronization Wrappers - part 2","<h3>Synchronization Wrappers - part 2</h3>
<p>If an explicit iterator is used, the <code>iterator</code> method must be called from within the <code>synchronized</code> block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view of a synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is similar. It is imperative that the user synchronize on the synchronized <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> when iterating over any of its <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> views rather than synchronizing on the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> view itself, as shown in the following example.</p> 
<div class=""codeblock""> 
 <pre>
Map&lt;KeyType, ValType&gt; m = Collections.synchronizedMap(new HashMap&lt;KeyType, ValType&gt;());
...
Set&lt;KeyType&gt; s = m.keySet();
...
// Synchronizing on m, not s!
synchronized(m) {
while (KeyType k : s)
foo(k);
}
</pre> 
</div> 
<p>One minor downside of using wrapper implementations is that you do not have the ability to execute any <em>noninterface</em> operations of a wrapped implementation. So, for instance, in the preceding <code>List</code> example, you cannot call <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>'s <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ensureCapacity(int)""><code>ensureCapacity</code></a> operation on the wrapped <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code>.</p>","ArrayList","java.util.ArrayList","class",0
,"Wrapper Implementations","Unmodifiable Wrappers","<h2>Unmodifiable Wrappers</h2> 
<p>Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code>. Unmodifiable wrappers have two main uses, as follows:</p> 
<ul> 
 <li>To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.</li> 
 <li>To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.</li> 
</ul> 
<p>Like synchronization wrappers, each of the six core <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s);
public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list);
public static &lt;K,V&gt; Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;? extends T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m);
</pre> 
</div>","UnsupportedOperationException","java.lang.UnsupportedOperationException","class",0
,"Wrapper Implementations","Unmodifiable Wrappers","<h2>Unmodifiable Wrappers</h2> 
<p>Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an <code> 
  <clt fqn=""java.lang.UnsupportedOperationException"" api=""UnsupportedOperationException"" kind=""class"">
    UnsupportedOperationException 
  </clt></code>. Unmodifiable wrappers have two main uses, as follows:</p> 
<ul> 
 <li>To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.</li> 
 <li>To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.</li> 
</ul> 
<p>Like synchronization wrappers, each of the six core <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces has one static factory method.</p> 
<div class=""codeblock""> 
 <pre>
public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s);
public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list);
public static &lt;K,V&gt; Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m);
public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;? extends T&gt; s);
public static &lt;K,V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m);
</pre> 
</div>","Collection","java.util.Collection","class",0
,"Wrapper Implementations","Checked Interface Wrappers","<h2>Checked Interface Wrappers</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.checked 
  </clt></code> <em>interface</em> wrappers are provided for use with generic collections. These implementations return a <em>dynamically</em> type-safe view of the specified collection, which throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.</p>","Collections","java.util.Collections","class",0
,"Wrapper Implementations","Checked Interface Wrappers","<h2>Checked Interface Wrappers</h2> 
<p>The <code> 
  <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
    Collections.checked 
  </clt></code> <em>interface</em> wrappers are provided for use with generic collections. These implementations return a <em>dynamically</em> type-safe view of the specified collection, which throws a <code> 
  <clt fqn=""java.lang.ClassCastException"" api=""ClassCastException"" kind=""class"">
    ClassCastException 
  </clt></code> if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.</p>","ClassCastException","java.lang.ClassCastException","class",0
,"API Design","Parameters","<h2>Parameters</h2> 
<p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">interface</a> types. <b>Never</b> use an <a class=""TutorialLink"" target=""_top"" href=""../implementations/index.html"">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p> 
<p>Further, you should always use the least-specific type that makes sense. For example, don't require a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html""><code>List</code></a> or a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> if a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> would do. It's not that you should never require a <code>List</code> or a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a <code>List</code> on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""note""> 
 <strong>Caution:</strong>&nbsp;Never define your own ad hoc 
 <code>collection</code> class and require objects of this class on input. By doing this, you'd lose all the 
 <a class=""TutorialLink"" target=""_top"" href=""../intro/index.html"">benefits provided by the Java Collections Framework</a>. 
</div>","Set","java.util.Set","class",0
,"API Design","Parameters","<h2>Parameters</h2> 
<p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">interface</a> types. <b>Never</b> use an <a class=""TutorialLink"" target=""_top"" href=""../implementations/index.html"">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p> 
<p>Further, you should always use the least-specific type that makes sense. For example, don't require a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html""><code>List</code></a> or a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> if a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> would do. It's not that you should never require a <code>List</code> or a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a <code>List</code> on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""note""> 
 <strong>Caution:</strong>&nbsp;Never define your own ad hoc 
 <code>collection</code> class and require objects of this class on input. By doing this, you'd lose all the 
 <a class=""TutorialLink"" target=""_top"" href=""../intro/index.html"">benefits provided by the Java Collections Framework</a>. 
</div>","Collection","java.util.Collection","class",0
,"API Design","Parameters","<h2>Parameters</h2> 
<p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">interface</a> types. <b>Never</b> use an <a class=""TutorialLink"" target=""_top"" href=""../implementations/index.html"">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p> 
<p>Further, you should always use the least-specific type that makes sense. For example, don't require a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html""><code>List</code></a> or a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> if a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> would do. It's not that you should never require a <code>List</code> or a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a <code>List</code> on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""note""> 
 <strong>Caution:</strong>&nbsp;Never define your own ad hoc 
 <code>collection</code> class and require objects of this class on input. By doing this, you'd lose all the 
 <a class=""TutorialLink"" target=""_top"" href=""../intro/index.html"">benefits provided by the Java Collections Framework</a>. 
</div>","Map","java.util.Map","class",0
,"API Design","Parameters","<h2>Parameters</h2> 
<p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">interface</a> types. <b>Never</b> use an <a class=""TutorialLink"" target=""_top"" href=""../implementations/index.html"">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p> 
<p>Further, you should always use the least-specific type that makes sense. For example, don't require a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/list.html""><code><clt fqn=""java.util.List"" api=""List"" kind=""class"">List</clt></code></a> or a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     Set 
   </clt></code></a> if a <a class=""TutorialLink"" target=""_top"" href=""../interfaces/collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     Collection 
   </clt></code></a> would do. It's not that you should never require a <code>List</code> or a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a <code>List</code> on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""note""> 
 <strong>Caution:</strong>&nbsp;Never define your own ad hoc 
 <code>collection</code> class and require objects of this class on input. By doing this, you'd lose all the 
 <a class=""TutorialLink"" target=""_top"" href=""../intro/index.html"">benefits provided by the Java Collections Framework</a>. 
</div>","List","java.util.List","class",0
,"API Design","Return Values","<h2>Return Values</h2> 
<p>You can afford to be much more flexible with return values than with input parameters. It's fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces.</p> 
<p>For example, one could imagine an image-processing package, called <code>ImageList</code>, that returned objects of a new class that implements <code>List</code>. In addition to the <code>List</code> operations, <code>ImageList</code> could support any application-specific operations that seemed desirable. For example, it might provide an <code>indexImage</code> operation that returned an image containing thumbnail images of each graphic in the <code>ImageList</code>. It's critical to note that even if the API furnishes <code>ImageList</code> instances on output, it should accept arbitrary <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> (or perhaps <code>List</code>) instances on input.</p>","Collection","java.util.Collection","class",0
,"API Design","Return Values - part 2","<h3>Return Values - part 2</h3>
<p>In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, you should give the relevant method the return type of <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> rather than <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> instances are more time-consuming to build than ordinary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances and are also more powerful. Given that your module has already invested the time to build a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, as well as those that accept any <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","SortedMap","java.util.SortedMap","class",0
,"API Design","Return Values - part 2","<h3>Return Values - part 2</h3>
<p>In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, you should give the relevant method the return type of <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> rather than <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> instances are more time-consuming to build than ordinary <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instances and are also more powerful. Given that your module has already invested the time to build a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>, as well as those that accept any <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p>","Map","java.util.Map","class",0
,"Compatibility","Compatibility","<div id=""PageTitle""> 
 <h1>Compatibility</h1> 
</div> 
<p>The Java Collections Framework was designed to ensure complete interoperability between the core <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">collection interfaces</a> and the types that were used to represent collections in the early versions of the Java platform: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html""><code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code></a>, <a class=""TutorialLink"" target=""_top"" href=""../../java/nutsandbolts/arrays.html"">array</a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html""><code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code></a>. In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.</p>","Vector","java.util.Vector","class",0
,"Compatibility","Compatibility","<div id=""PageTitle""> 
 <h1>Compatibility</h1> 
</div> 
<p>The Java Collections Framework was designed to ensure complete interoperability between the core <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">collection interfaces</a> and the types that were used to represent collections in the early versions of the Java platform: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html""><code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code></a>, <a class=""TutorialLink"" target=""_top"" href=""../../java/nutsandbolts/arrays.html"">array</a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html""><code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code></a>. In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.</p>","Hashtable","java.util.Hashtable","class",0
,"Compatibility","Compatibility","<div id=""PageTitle""> 
 <h1>Compatibility</h1> 
</div> 
<p>The Java Collections Framework was designed to ensure complete interoperability between the core <a class=""TutorialLink"" target=""_top"" href=""../interfaces/index.html"">collection interfaces</a> and the types that were used to represent collections in the early versions of the Java platform: <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html""><code> 
   <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
     Vector 
   </clt></code></a>, <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html""><code> 
   <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
     Hashtable 
   </clt></code></a>, <a class=""TutorialLink"" target=""_top"" href=""../../java/nutsandbolts/arrays.html"">array</a>, and <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html""><code> 
   <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
     Enumeration 
   </clt></code></a>. In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.</p>","Enumeration","java.util.Enumeration","class",0
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));
</pre> 
</div> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Vector result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Hashtable result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
</pre> 
</div>","Collection","java.util.Collection","class",0
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));
</pre> 
</div> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Vector result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Hashtable result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
</pre> 
</div>","Arrays","java.util.Arrays","class",0
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));
</pre> 
</div> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Vector result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Hashtable result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
</pre> 
</div>","Vector","java.util.Vector","class",0
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));
</pre> 
</div> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Vector result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Hashtable result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
</pre> 
</div>","Hashtable","java.util.Hashtable","class",0
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));
</pre> 
</div> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Vector result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Hashtable result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
</pre> 
</div>","Map","java.util.Map","class",0
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));
</pre> 
</div> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Vector result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Hashtable result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
</pre> 
</div>","Enumeration","java.util.Enumeration","class",0
,"Compatibility","Upward Compatibility","<h2>Upward Compatibility</h2> 
<p>Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p> 
<p>Suppose the old API returns an array of objects and the new API requires a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a <code>List</code>. You use <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList(T...)""><code> 
   <clt fqn=""java.util.Arrays.asList"" api=""Arrays"" kind=""method"">
    Arrays.asList
   </clt></code></a> to pass an array to any method requiring a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));
</pre> 
</div> 
<p>If the old API returns a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> or a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code>, you have no work to do at all because <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> was retrofitted to implement the <code>List</code> interface, and <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> was retrofitted to implement <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Therefore, a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> or a <code>List</code>.</p> 
<div class=""codeblock""> 
 <pre>
Vector result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Similarly, a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> may be passed directly to any method calling for a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Hashtable result = oldMethod(arg);
newMethod(result);
</pre> 
</div> 
<p>Less frequently, an API may return an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> that represents a collection of objects. The <code> 
  <clt fqn=""java.util.Collections.list"" api=""Collections"" kind=""method"">
   Collections.list
  </clt></code> method translates an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
</pre> 
</div>","Collections","java.util.Collections","class",0
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""method"">
   Collection
  </clt></code> interface contains a <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> method designed expressly for this situation.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(c.toArray());
</pre> 
</div> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> ? the one that takes an array on input.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod((String[]) c.toArray(new String[0]));
</pre> 
</div> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(new Vector(c));
</pre> 
</div> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p> 
<div class=""codeblock""> 
 <pre>
Map m = newMethod();
oldMethod(new Hashtable(m));
</pre> 
</div>","Collection","java.util.Collection","class",0
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""method"">
   Collection
  </clt></code> interface contains a <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> method designed expressly for this situation.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(c.toArray());
</pre> 
</div> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> ? the one that takes an array on input.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod((String[]) c.toArray(new String[0]));
</pre> 
</div> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(new Vector(c));
</pre> 
</div> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p> 
<div class=""codeblock""> 
 <pre>
Map m = newMethod();
oldMethod(new Hashtable(m));
</pre> 
</div>","Object","java.lang.Object","class",0
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""method"">
   Collection
  </clt></code> interface contains a <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> method designed expressly for this situation.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(c.toArray());
</pre> 
</div> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> ? the one that takes an array on input.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod((String[]) c.toArray(new String[0]));
</pre> 
</div> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(new Vector(c));
</pre> 
</div> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p> 
<div class=""codeblock""> 
 <pre>
Map m = newMethod();
oldMethod(new Hashtable(m));
</pre> 
</div>","Vector","java.util.Vector","class",0
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""method"">
   Collection
  </clt></code> interface contains a <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> method designed expressly for this situation.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(c.toArray());
</pre> 
</div> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> ? the one that takes an array on input.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod((String[]) c.toArray(new String[0]));
</pre> 
</div> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(new Vector(c));
</pre> 
</div> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p> 
<div class=""codeblock""> 
 <pre>
Map m = newMethod();
oldMethod(new Hashtable(m));
</pre> 
</div>","String","java.lang.String","class",0
,"Compatibility","Backward Compatibility","<h2>Backward Compatibility</h2> 
<p>Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p> 
<p>Suppose the new API returns a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>, and the old API requires an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>. As you're probably aware, the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""method"">
   Collection
  </clt></code> interface contains a <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> method designed expressly for this situation.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(c.toArray());
</pre> 
</div> 
<p>What if the old API requires an array of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> (or another type) instead of an array of <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code>? You just use the other form of <code> 
  <clt fqn=""java.util.Collection.toArray"" api=""Collection"" kind=""method"">
   Collection.toArray
  </clt></code> ? the one that takes an array on input.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod((String[]) c.toArray(new String[0]));
</pre> 
</div> 
<p>If the old API requires a <code> 
  <clt fqn=""java.util.Vector"" api=""Vector"" kind=""class"">
    Vector 
  </clt></code>, the standard collection constructor comes in handy.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(new Vector(c));
</pre> 
</div> 
<p>The case where the old API requires a <code> 
  <clt fqn=""java.util.Hashtable"" api=""Hashtable"" kind=""class"">
    Hashtable 
  </clt></code> is handled analogously.</p> 
<div class=""codeblock""> 
 <pre>
Map m = newMethod();
oldMethod(new Hashtable(m));
</pre> 
</div>","Hashtable","java.util.Hashtable","class",0
,"Compatibility","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(Collections.enumeration(c));
</pre> 
</div>","Enumeration","java.util.Enumeration","class",0
,"Compatibility","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(Collections.enumeration(c));
</pre> 
</div>","Collections","java.util.Collections","class",0
,"Compatibility","Backward Compatibility - part 2","<h3>Backward Compatibility - part 2</h3>
<p>Finally, what do you do if the old API requires an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code>? This case isn't common, but it does happen from time to time, and the <a class=""APILink"" target=""_blank"" href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#enumeration(java.util.Collection)""><code> 
   <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
     Collections.enumeration 
   </clt></code></a> method was provided to handle it. This is a static factory method that takes a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> and returns an <code> 
  <clt fqn=""java.util.Enumeration"" api=""Enumeration"" kind=""class"">
    Enumeration 
  </clt></code> over the elements of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>.</p> 
<div class=""codeblock""> 
 <pre>
Collection c = newMethod();
oldMethod(Collections.enumeration(c));
</pre> 
</div>","Collection","java.util.Collection","class",0
,"Lesson: Introduction to Collections","What Is a Collections Framework?","<h2>What Is a 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Framework?</h2> 
<p>A <i>collections framework</i> is a unified architecture for representing and manipulating collections. All collections frameworks contain the following:</p> 
<ul> 
 <li><b>Interfaces:</b> These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.</li> 
 <li><b>Implementations:</b> These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.</li> 
 <li><b>Algorithms:</b> These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be <i>polymorphic</i>: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.</li> 
</ul> 
<p>Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk's collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.</p>","Collections","java.util.Collections","class",0
,"Lesson: Introduction to Collections","Benefits of the Java Collections Framework","<h2>Benefits of the Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Framework</h2> 
<p>The Java Collections Framework provides the following benefits:</p> 
<ul> 
 <li><b>Reduces programming effort:</b> By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level &quot;plumbing&quot; required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs.</li> 
 <li><b>Increases program speed and quality:</b> This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you're freed from the drudgery of writing your own data structures, you'll have more time to devote to improving programs' quality and performance.</li> 
 <li><b>Allows interoperability among unrelated APIs:</b> The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently.</li> 
 <li><b>Reduces effort to learn and to use new APIs:</b> Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away.</li> 
 <li><b>Reduces effort to design new APIs:</b> This is the flip side of the previous advantage. Designers and implementers don't have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces.</li> 
 <li><b>Fosters software reuse:</b> New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.</li> 
</ul>","Collections","java.util.Collections","class",0
